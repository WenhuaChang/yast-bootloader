/**
 * File:
 *	inst_bootloader.ycp
 *
 * Summary:
 *	called from proposal_bootloader.ycp when "AskUser" is needed
 *	determines the current bootloader type and calls the
 *	appropriate sub-module to configure the parameters
 *
 * Authors:
 *	Klaus Kaempf <kkaempf@suse.de>
 *
 * $Id$
 *
 */
{
    textdomain "bootloader";

    import "Arch";
    import "Mode";
    import "Installation";
    import "Boot";
    import "Storage";
    import "Kernel";

    import "Wizard";

    y2milestone("%1: %2 at %3", Boot::LoaderType, Boot::location, Boot::device);
    Wizard::OpenAcceptDialog();

    map loadertype2name = $[
	"lilo" : "LILO",
	"grub" : "GRUB",
	"silo" : "SILO",
	"milo" : "MILO",
	"aboot" : "aboot",
	"elilo" : "ELILO",
	"mips" : "dvh",
	"s390" : "zipl",
	"ppc" : "boot loader"
    ];
    string loadername = loadertype2name[Boot::LoaderType]:"LILO";

     term location = `Empty();

    if (Boot::LoaderType == "ppc")
    {
	import "BootPPC";
	location = BootPPC::AskOptions ();

    }
    else
    {
    location = `VBox(
			 `VStretch(),
			 `Left(
			       `RadioButton( `id( "mbr" ),
					     // Radio button for boot manager installation on /dev/hda or /dev/sda MBR
					     // %1 == name of boot manager, e.g. "LILO"
					     // %2 == device name of disk, e.g. "/dev/hda"
					     sformat (_("Write %1 to the boot disk ('&MBR' on %2)"), loadername, Boot::mbrDisk),
					     Boot::location == "mbr")
			       )
			 );

    if (StorageDevices::FloppyPresent)
    {
	location = add ( location,
			`Left(
			      `RadioButton( `id( "floppy" ),
					    // Radio button for boot manager installation on floppy only
					    // !! this is a button label, it must have a keyboard shortcut '&' !!
					    _("Create a boot &floppy"),
					    Boot::location == "floppy")
			      )
			);
    }

    location = add ( location,
		    `Left(
			  `RadioButton( `id("boot"),
					// Radio button for the boot manager installation: Have a different boot manager,
					// install in partition /boot only
					// %1 == name of boot manager, e.g. "LILO"
					sformat (_("Do &not use %1 (a different boot manager is required)"), loadername),
					Boot::location == "boot")
			  )
		    );
    }

    // build up 'custom' bootloader entry
    // offer all possible partitions in a ComboBox widget

    string default_text = "";
    if ((Boot::location == "custom")
	&& (substring (Boot::device, 0, 5) == "/dev/"))
    {
	default_text = Boot::device;
    }

    // convert ["/dev/hda1", "/dev/hda2", ... ]
    // to [ `item(`id("/dev/hda1"), "/dev/hda1"), `item(`id("/dev/hda2"), "/dev/hda2"), ...]

    list all_partitions = [];//Storage::GetPartitionList();

    // add device names to partition list
    map devices = Storage::GetTargetMap();
    devices = filter (`k, `v, devices, ``(! lookup (v, "is_lvm_vg", false)));

    foreach (`d, `cont, devices, ``{
	all_partitions = add (all_partitions, d);
	list parts = lookup (cont, "partitions", []);
	parts = filter (`p, parts, ``(is (p, map)));
	parts = filter (`p, parts, ``(lookup (p, "lvm_group", "") == "" && lookup (p, "raid_name", "") == "" && ! lookup (p, "delete", false)));
	parts = filter (`p, parts, ``(lookup (p, "type", `primary) == `primary || lookup (p, "type", `primary) == `extended));
	parts = filter (`p, parts, ``(lookup (p, "fstype", "") != "Linux swap"));

	foreach (`p, parts, ``{
	    string dev = lookup (p, "device", "");
	    if (dev != "")
		all_partitions = add (all_partitions, dev);
	});
    });

    list combo_partitions = [];

    // sort the all_partitions list by copying its elements
    // to a map which is key sorted by definition.

    map sorted_all_partitions = $[];
    foreach (`partition, all_partitions,
    ``{
	// key is partition, value is dummy (zero)
	sorted_all_partitions[partition] = 0;
    });

    // check if user selected a non-listed partition

    if ((default_text != "")
	&& (sorted_all_partitions[default_text]:1 == 1)) // if not in map, value defaults to 1
    {
	sorted_all_partitions[default_text] = 0;
    }


    foreach (`partition, `dummy, sorted_all_partitions,
    ``{
	if (partition == default_text)
	{
	    combo_partitions = add (combo_partitions, `item(`id(partition), partition, true));
	}
	else
	{
	    combo_partitions = add (combo_partitions, `item(`id(partition), partition));
	}
    });

    // XXX move this to a generic place
    if (Boot::LoaderType != "ppc")
    {
    location = add ( location,
		    `VSquash(
			     `HBox(
				   `Left(
					 `Bottom(
						 `RadioButton( `id("custom"), `opt(`notify),
							       // Radio button for bootloader installation:
							       // Other partition (enter name in text input field)
							       // %1 == name of boot manager, e.g. "LILO"
							       sformat (_("Write %1 to a different &partition:"), loadername),
							       (Boot::location == "custom")
							       )
						 )
					 ),
				   `HWeight(1,
					    // Layout trick: let the text have its nice size - the rest
					    // will do nicely for the input field.
					    `Bottom(
						    `ComboBox (`id(`custom_partition), `opt(`editable), "", combo_partitions)
						    )
					    )
				   )
			     )
		    );
    }

    location = `Frame(
		      // frame label for boot manager (%1) location radio buttons
		      sformat ("%1 location", loadername),
		      `VBox(
			    `VSpacing( 1 ),
			    `HBox(
				  `HSpacing( 1 ),
				  `HVSquash( `RadioButtonGroup(`id(`options), location) ),
				  `HSpacing( 2 )
				  ),
			    `VSpacing( 1 )
			    )
		      );

    // Input field for boot parameters

    term parameters = `VBox (`Left (`TextEntry (
			`id( `boot_params ),
			// Text input field to enter additional boot parameters
			_("&Kernel boot parameters:"),
			Kernel::cmdLine)
			));

    // boot manager specific settings

    list ui_parameters = [];
    string help_parameters = "";

    if (Boot::LoaderType == "lilo")
    {
	import "BootLILO";

	ui_parameters = BootLILO::AskParameters ();
	help_parameters = BootLILO::HelpParameters ();
    }
    else if (Boot::LoaderType == "grub")
    {
	import "BootGRUB";

	ui_parameters = BootGRUB::AskParameters ();
	help_parameters = BootGRUB::HelpParameters ();
    }
    else if (Boot::LoaderType == "silo")
    {
	import "BootSILO";

	ui_parameters = BootSILO::AskParameters ();
	help_parameters = BootSILO::HelpParameters ();
    }
    else if (Boot::LoaderType == "ppc")
    {
	import "BootPPC";

	ui_parameters = BootPPC::AskParameters ();
    }

    foreach (`uiterm, ui_parameters,
    ``{
	parameters = add (parameters, `VSpacing(0.5));
	parameters = add (parameters, uiterm);
    });

    parameters = `HBox (`HSpacing(4),
			`HWeight(75, parameters ),
			`HWeight(25, `HStretch()));

    parameters = `Frame(
			// frame label for boot manager (%1) parameters, %1 is bootloader (eg. LILO)
			sformat (_("%1 parameters"), loadername),

			`VBox(
			      `VSpacing( 1 ),
			      parameters,
			      `VSpacing( 1 )
			      )
			);

    // determine destination location of boot manager
    term contents =
	`HSquash(
		 `VBox(
		       `VStretch(),
		       location,
		       `VStretch(),
		       parameters,
		       `VStretch()
		       )
		 );


    //---------------------------------------------------------------

    // help text for the custom boot manager installation, 1 of 9
    // %1 = name of boot loader (e.g. "LILO")
    string helptext = sformat (_("<p>
The boot manager (%1) can be installed in the following ways:
</p>
"), loadername);

    // custom bootloader help text, 2 of 9
    helptext = helptext + _("<p>
- In the <b>MBR</b> (the Master Boot Record).  This is recommended whenever SuSE Linux
determines the system can be booted this way. The old MBR
will be saved to disk as a precaution.
</p>
");

    if (StorageDevices::FloppyPresent)
    {
	// custom bootloader help text, 3 of 9
	// this part will only be shown if a floppy drive is attached.
	helptext = helptext + _("<p>
- On a <b>floppy</b> disk.
Use this to avoid the risk of interference with an already existing
boot mechanism. Enable booting from floppy disk in
the BIOS of your machine to use this option.
</p>
");
    }

    // custom bootloader help text, 4 of 9
    helptext = helptext + _("<p>
- In the <b>/boot</b> partition.  Choose this option if you
have several operating systems installed on your hard drive and want to
continue using your old boot manager, such as <tt>loadlin</tt>. No changes
will be made to the existing MBR.<br>
The boot manager is always installed on the <b>/boot</b> partition.
Configure your <b>other boot manager</b> to start SuSE Linux.
</p>
");

    // custom bootloader help text, 5 of 9
    helptext = helptext + _("<p>
If you use this method, configure
your other boot manager (e.g., <tt>loadlin</tt>) accordingly.
</p>
");

    // custom bootloader help text, 6 of 9
    helptext = helptext + _("<p>
- In some <b>other</b> partition. Consider your system's restrictions
when selecting this option.</p>
");
    if (Arch::i386)
    {
	// optional part, only inserted on x86 architectures. 7 of 9
	helptext = helptext + _("<p>For example, most PCs have a BIOS limit that restricts booting to
hard disk cylinders smaller than 1024. Depending on the boot manager used,
you may or may not be able to boot from a logical partition.
</p>");
    }

    // custom bootloader help text, 8 of 9
    helptext = helptext + _("<p>
Enter the device name of the partition (e.g., <tt>/dev/hda3</tt>,
<tt>/dev/sdb</tt>) in the input field.
</p>
");

    // custom bootloader help text, 9 of 9
    helptext = helptext + _("<p>
If your system requires additional <b>kernel boot parameters</b>,
enter them in the corresponding input field. Most users will not need this.
</p>");

    helptext = helptext + help_parameters + "<br>";

    // dialog caption
    Wizard::SetContents(_("Custom boot manager installation"),
			    contents, helptext, WFM::Args(0), WFM::Args(1));

    // Event handling

    any ret = nil;

    repeat
    {
	ret = Wizard::UserInput();

	if (Boot::LoaderType == "ppc")
	{
		import "BootPPC";
		y2milestone("fooXXret %1", ret);
		BootPPC::UI_Poll( ret );
	}

	if ( ret == "custom" )
	{
	    // Just for convenience: If the user selects "custom partition", he
	    // needs to enter a value in the corresponding input field anyway,
	    // so move the keyboard focus there right away.

	    UI::SetFocus(`id(`custom_partition) );
	    continue;
	}
	if (ret == `next || ret == `back)
	{
	    any option = UI::QueryWidget (`id(`options), `CurrentButton);
		y2milestone("fooXXoption %1", option);
	    if (option == nil)
	    {
		if ( ret == `next )
		{
		    // popup User MUST choose one of the options
		    UI::MessagePopup(_("You must choose one of the
options to continue.
"));
		    continue;
		}
	    }
	    else if (is(option,string))
	    {
		Boot::location = option;
		Boot::manual_location = true;	// location was set manually

		if (option == "mbr")
		{
		    Boot::device = Boot::mbrDisk;
		}
		else if (option == "floppy")
		{
		    Boot::device =  StorageDevices::FloppyDevice;
		}
		else if (option == "boot")
		{
		    Boot::device = Boot::BootPartitionDevice;
		}
		else if (option == "custom")
		{
		    option = UI::QueryWidget(`id(`custom_partition), `Value);
		    if ((ret == `next)
			&& ((!is(option, string))
			    || (option == "")
			    || (substring (option, 0, 5) != "/dev/")))
		    {
			// popup custom boot loader field, must begin with "/dev/" but didn't
			UI::MessagePopup(_("You did not enter a partition."));
			continue;
		    }
		    if (is(option,string))
		    {
			Boot::device = option;
		    }
		}
		else if (option == "iseries_stmf")
		{
			option = UI::QueryWidget(`id(`ppc_iseries_streamfile), `Value);
			if (is (option, string))
			{
				BootPPC::ppc_iseries_streamfile = option;
			}
		}
		else if (option == "iseries_nwsstg")
		{
			option = UI::QueryWidget(`id(`custom_partition), `Value);
			if (is (option, string))
			{
				Boot::device = option;
			}
		}
		else if (option == "iseries_do_nothing")
		{
				BootPPC::ppc_activate_bootloader = false;
		}
	    }

	    option = UI::QueryWidget(`id(`boot_params), `Value);
	    if (is (option, string))
	    {
		Kernel::cmdLine = option;
	    }
	    if (size (ui_parameters) > 0)
	    {
		if (Boot::LoaderType == "lilo")
		{
		    import "BootLILO";

		    BootLILO::HandleParameters ();
		}
		else if (Boot::LoaderType == "grub")
		{
		    import "BootGRUB";

		    BootGRUB::HandleParameters ();
		}
		else if (Boot::LoaderType == "ppc")
		{
		    import "BootPPC";

		    BootPPC::HandleParameters ();
		}
	    }

	} // ret == next|back

    } until ( ret == `next || ret == `back || ret == `cancel );

    Wizard::CloseDialog();
    return ret;
}
