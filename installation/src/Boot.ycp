/**
 * File:
 *	Boot.ycp
 *
 * Module:
 *	Boot
 *
 * Summary:
 *	functions for bootload setup
 *
 * Authors:
 *	Klaus Kaempf <kkaempf@suse.de>
 *
 * $Id$
 *
 */
{
    module "Boot";

    import "Arch";
    import "Misc";
    import "Mode";

    import "StorageDevices";
    textdomain "bootloader";

    /**
     * @return list: modules for the initrd
     * (device driver and filesystem for the root partition)
     */
    global list initrdModules = [];

    /**
     * @return string: the systems boot mode, i.e.
     * "lilo", "grub", "silo", "milo", "aboot", "elilo", "ppc", "s390", "mips"
     */
    global string LoaderType = "";

    /**
     * @return string: vga value from cmdline
     */
    global string VgaType = "";

    /**
     * @return	string: boot device (partition)
     *
     */
    global string BootPartitionDevice = "";

    /**
     * @return	string: root device (partition)
     *
     */
    global string RootPartitionDevice = "";

    /**
     * @return	string: bootloader device location
     * "mbr", "floppy", or "custom"
     */
    global string location = "";

    /**
     * @return	boolean: bootloader device location was set manually
     */
    global boolean manual_location = false;

     /**
     * @return	string:  bootloader device
     * i.e. "/dev/hda" or "/dev/sdb2"
     */
    global string device = "";

    /**
     * @return	string: Boot disk (raw)
     *
     */
    global string bootDisk = "";

    /**
     * @return	string: The disk where the master boot record is located
     *
     */
    global string mbrDisk = "";

    /*
     * @return boolean: true if a single target system
     *
     */
    global boolean single_target = false;

    /**
     * @return list of strings: Other installed operating systems
     */
    global list others = [];

    /**
     * @return boolean: IDE and SCSI System
     *
     */
    global boolean mixed = false;

    /**
     * time of last change of partitioning
     */
    integer last_change = 0;

    /**
     * was already called the Set function?
     */
    boolean was_set = false;
    /**
      * true if no bootloader is selected to be installed
      */
    global boolean no_bootloader = false;

    //---------------------------------------------------------------

    // map of module arguments
    // $["module_name" : $["opt1":"val1", "opt2":"val2", ...], ...]
    map module_args = $[];

    //---------------------------------------------------------------

    /**
     * Constructor
     */

    global define void Boot()
    ``{
	if (! Mode::normal)
	{
	    string tmp_mods = SCR::Read( .etc.install_inf.InitrdModules );
	    if (tmp_mods != nil)
	    {
		list tmp_mod = splitstring( tmp_mods, " " );
		foreach( `t, tmp_mod, ``{ AddInitrdModule(t,""); });
	    }
	}
	y2milestone( "initrdModules %1", initrdModules );
	checkBootloader (false);
	return;
    }
    /**
     * reset configuration
     */
    global define void Reset () ``{
	device = "";
	location = "";
	Set ();
    }
    /**
      * detect bootloader for being used and set it to LoaderType variable
      * @param ask function Storage::UseLilo ()
      */
    global define void checkBootloader (boolean askStorage) ``{
	y2milestone ("Ask: %1", askStorage);
	LoaderType = SCR::Read (.probe.boot_arch);

	y2milestone ("LoaderType: %1", LoaderType);
	y2milestone ("Mode::Update: %1", Mode::update);
	y2milestone ("Mode::initial: %1", Mode::initial);

	if (((LoaderType == "grub")
	     || (LoaderType == "unknown"))		// hwinfo bug ?
	    && (Mode::update || Mode::normal))
	{
	    string sysconfig = SCR::Read (.sysconfig.bootloader.LOADER_TYPE);
	    y2milestone ("sysconfig:LOADER_TYPE %1", sysconfig);
	    if (sysconfig == "grub" || sysconfig == "lilo")
	        LoaderType = sysconfig;
	    else if (LoaderType == "unknown" || sysconfig==nil )
		LoaderType = (Mode::update) ? "lilo" : "grub";
	    y2milestone ("Bootloader update, using %1", LoaderType);
	}
	if (askStorage)
	{
	    import "Storage";
	    if (LoaderType == "grub" && Storage::UseLilo())
		LoaderType = "lilo";
	}
	no_bootloader = false;
	if ((Arch::i386 || Arch::x86_64) && (Mode::initial)){
	    if (LoaderType == "lilo" && ! Pkg::IsSelected ("lilo"))
		LoaderType = "grub";
	    if (LoaderType == "grub" && ! Pkg::IsSelected ("grub"))
		LoaderType = "lilo";
	    if (! (Pkg::IsSelected ("lilo") || Pkg::IsSelected ("grub")))
	    {
		no_bootloader = true;
	    }
	}
	y2milestone ("Setting bootloader type to %1", LoaderType);
	return;
    }


    /**
     * LbaSupport ()
     * @return boolean	LBA support available
     */
    global define boolean LbaSupport ()
    ``{
	if (LoaderType == "lilo")
	{
	    import "BootLILO";
	    return BootLILO::lba_support;
	}
	return true;
    }

    /**
     * AddInitrdModule ()
     * @param	string	name of module
     * @param	string	args of module
     *
     * add module to initrdModules
     */
    global define void AddInitrdModule (string modname, string modargs)
    ``{
	if ((!contains (initrdModules, modname))
	    || ((modname == "aic7xxx")
		 && !contains (initrdModules, "aic7xxx_old"))
	    || ((modname == "aic7xxx_old")
		 && !contains (initrdModules, "aic7xxx")))
	{
	    // usb and cdrom modules dont belong to initrd, they're loaded by hotplug

	    list modules_to_skip = [ "usbcore",
				     "usb-uhci",
				     "uhci",
				     "usb-ohci",
				     "input",
				     "hid",
				     "keybdev",
				     "mousedev",
				     "usb-storage",
				     "cdrom",
				     "ide-cd",
				     "sr_mod"
				     ];
	    if (Arch::ppc)
	    {
	        list ppc_modules_to_skip = [ "reiserfs",
					     "ext3",
					     "jbd",
					     "jfs",
					     "xfs",
					     ];
		modules_to_skip = union ( modules_to_skip, ppc_modules_to_skip );
	    }

	    if ( ! contains (modules_to_skip, modname ))
	    {
		initrdModules = add (initrdModules, modname);
	    }
	    if (size(modargs)  > 0)
	    {
		module_args[modname] = Misc::MergeOptions (modargs, $[]);
	    }
	}
	return;
    }

    /**
     * Check ()
     *
     * will warn if system may become non-bootable
     *
     */

    global define integer Check ()
    ``{
	// check /boot, /
	// check kernel <-> system

	return 0;
    }


    /**
     *  Set()
     *	@return boolean True if configuration is valid
     *  If nothing is configured, automatically determine values.
     *
     */

    global define boolean Set()
    ``{
	import "Storage";
	checkBootloader (true);

	last_change = Storage::GetTargetChangeTime();

	map mp = Storage::GetMountPoints();
	string actual_root = mp["/", 0]:"";
	string actual_boot = mp["/boot", 0]:actual_root;

	// don't change configuration if '/' and '/boot' were not changed
	// and location is "floppy", "mbr" or "boot"
	if (actual_boot == BootPartitionDevice && actual_root == RootPartitionDevice && location != "custom" && location != "")
	{
	    return true;
	}

	if (location == "custom")
	{
	    // check if target partition is (will be) present
	    map devices = Storage::GetTargetMap();

	    list all_partitions = [];

	    foreach (string d, map cont, devices, ``{
		all_partitions = add (all_partitions, d);
		list parts = cont["partitions"]:[];

		//remove deleted partitions
		parts = filter (map p, parts, ``(! p["delete"]:false ));
		parts = filter (map p, parts, ``(p["fstype"]:"" != "Linux swap"));

		foreach (map p, parts, ``{
		    string dev = p["device"]:"";
		    if (dev != "")
		    {
			all_partitions = add (all_partitions, dev);
		    }
		});
	    });

	    if (!contains(all_partitions, device))
	    {
		return false;
	    }
	    else if (actual_boot == BootPartitionDevice && actual_root == RootPartitionDevice)
	    {
		return true;
	    }
	}
	// else only refresh / and /boot location

	was_set = true;

	// get map of lists
	// $[ "/mount_point" : [partitionName, fsid, targetdevice, raid_type], ...]
	map mountPoints		= Storage::GetMountPoints();

	list mountdata_boot	= mountPoints["/boot"]:(mountPoints["/"]:[]);
	y2milestone( "mountPoints %1", mountPoints );
	y2milestone( "mountdata_boot %1", mountdata_boot );
	bootDisk		= mountdata_boot[2]:(mountPoints["/",2]:"");

	// check if /boot is on raid1
	boolean boot_is_raid1	= (mountdata_boot[3]:"" == "raid1");

	RootPartitionDevice	= mountPoints["/", 0]:"";

	if (bootDisk == ""
	    || RootPartitionDevice == "")
	{
	    y2error ("No mountpoint for / !!");
	}

	// if /boot changed, re-configure location
	if (BootPartitionDevice != mountPoints["/boot", 0]:RootPartitionDevice)
	{
	    BootPartitionDevice	= mountPoints["/boot", 0]:RootPartitionDevice;
	    if (!manual_location)
	    {
		// current location was not determined manually
		// so clear it here and force a re-calculation
		location = "";
	    }
	}

	if (boot_is_raid1)
	{
	    y2milestone ("/boot is on RAID1");
	    // use partitionName from GetMountPoints
	    mbrDisk		= mountdata_boot[0]:RootPartitionDevice;
	}
	else
	{
	    // normal mbr detection.
	    mbrDisk		= FindMbrDisk();
	}

	y2milestone( "bootDisk %1 mbrDisk %2", bootDisk, mbrDisk );
	y2milestone( "RootPartitionDevice %1 BootPartitionDevice %2",
	             RootPartitionDevice, BootPartitionDevice );

	// Do not configure location automatically if already set.
	if (location == "")
	{
	    ConfigureLocation();
	}
	else if (Mode::autoinst)
	{
	    if (location == "mbr")
	    {
		device = mbrDisk;
		y2milestone("location MBR, device = %1", device);
	    }
	    else if ( StorageDevices::FloppyPresent && location == "floppy")
	    {
		device   = StorageDevices::FloppyDevice;
	    }
	}

	y2milestone ("mbr at %1", mbrDisk);
	return true;
    }

    /**
     *  ConfigureLocation()
     *	return void: Where to install the bootloader.
     *  It just gives "mbr" or "floppy"
     */

    global define ConfigureLocation()
    ``{
	location = "mbr";			// default to mbr
	device	 = mbrDisk;

	if (!IsBootAccessible()			// above cyl 1024
	    && StorageDevices::FloppyPresent)
	{
	    // if we're on an old system without lba support
	    // (the last needs a too big initrd, see bugzilla #7864)

	    location = "floppy";		// floppy and fd0
	    device   = StorageDevices::FloppyDevice;
	}

	// location was automatically determined
	manual_location = false;

	y2milestone ("ConfigureLocation (%1 on %2)", location, device);
	return;
    }

    /**
     *	IsBootAccessible()
     *	@return boolean:
     *
     */

    global define IsBootAccessible()
    ``{
	import "Storage";
	boolean boot_partition_accessible = true;

	if (!LbaSupport())
	{
	    string boot_mount_point = "";
	    // check, if no /boot partition exists

	    if (lookup (Storage::GetMountPoints(), "/boot", "") == "")
	    {
		boot_mount_point = "/";
	    }
	    else
	    {
		boot_mount_point = "/boot";
	    }

	    // check if boot mount point is below cyl 1024

	    foreach (string dname, map ddata, Storage::GetTargetMap(),
	    ``{
		list partitions = ddata["partitions"]:[];
		if (partitions != [])
		{
		    foreach (`pentry, partitions,
		    ``{
			if (pentry["mount"]:"" == boot_mount_point)
			{
			    boot_partition_accessible = (1024 > pentry["region",0]:0);
			}
		    });
		}

	    });

	}
	if (boot_partition_accessible)
	    y2milestone("Boot partition accessible");
	else
	    y2milestone("Boot partition unaccessible");

	return (boot_partition_accessible);
    }


    /*
     * FindMbrDisk()
     * try to find the system's mbr device
     * @return string	mbr device
     */

    global define string FindMbrDisk()
    ``{
	// can hwinfo find the disk ?

	string probed_mbr_disk = SCR::Read(.probe.boot_disk);
	if (probed_mbr_disk != "")
	{
	    y2milestone ("MBR probed as %1", probed_mbr_disk);
	    return probed_mbr_disk;
	}

	// look for disk with bios_id 0x80

	list disks = SCR::Read(.probe.disk);
	string mbr_disk = disks[0,"dev_name"]:bootDisk;

	foreach (`disk, disks,
	``{
	    if (disk["bios_id"]:"" == "0x80")
	    {
		y2milestone ("disk with bios_id 0x80: %1", disk);
		mbr_disk = disk["dev_name"]:bootDisk;
	    }
	});

	y2milestone("MBR Disk: %1", mbr_disk);

	return mbr_disk;
    }


    /**
     * Save()
     * write status out (e.g. to /etc/sysconfig/...)
     *
     */

    global define void Save ()
    ``{
	if (! was_set)
	    Set ();

	string kernel_initrd = "";
	boolean modules_written = false;

	SCR::Execute (.target.bash, "/usr/bin/touch /etc/sysconfig/bootloader");

	if (Mode::update)
	{
	    // update: check for old lilo destination
	    SCR::Execute (.target.bash, "/usr/bin/touch /var/lib/YaST2/bootloader");
	    map old_user_settings = SCR::Read(.target.ycp, ["/var/lib/YaST2/bootloader", $[]]);
	    if (old_user_settings["lilo"]:"" == "floppy")
	    {
		Boot::location = "floppy";
	    }

	    // update !
	    // merge computed initrdModules with current settings
	    // keep old INITRD_MODULES, only add new modules

	    // (old variable already moved to sysconfig by aaa_base.

	    list old_initrd = [];
	    if (SCR::Read (.target.size, "/etc/sysconfig/bootloader") > 0)
		old_initrd = splitstring (SCR::Read (.sysconfig.kernel.INITRD_MODULES), " ");
	    map optmap = $[];

	    // loop over all initrdModules entries and add to
	    // old_initrd as needed.

	    foreach (`modname, initrdModules,
	    ``{
		// only those not already in INITRD_MODULES
		if (!contains (old_initrd, modname))
		{
		    // check for options for this module
		    // write to modules.conf if set
		    optmap = module_args[modname]:$[];
		    if (size (optmap) > 0)
		    {
			SCR::Write (.modules.options, optmap, modname);
			modules_written = true;
		    }
		    old_initrd = add (old_initrd, modname);
		}
	    });

	    y2milestone("Modules update for initrd:  %1", old_initrd);
	    kernel_initrd = mergestring (old_initrd, " ");
	}
	else		// install
	{
	    // write options to /etc/modules.conf
	    foreach (`modname, `optmap, module_args,
	    ``{
		if (size (optmap) > 0)
		{
		    SCR::Write (.modules.options, optmap, modname);
		    modules_written = true;
		}
	    });

	    y2milestone ("Modules for the initrd: %1", initrdModules);
	    kernel_initrd = mergestring (initrdModules, " ");
	}

	y2milestone ("Entries in /etc/sysconfig/kernel: %1", kernel_initrd);
	// write INITRD_MODULES
	SCR::Write (.sysconfig.kernel.INITRD_MODULES, kernel_initrd);
	SCR::Write (.sysconfig.kernel, nil);

	if (modules_written)
	{
	    SCR::Write (.modules, nil);
	}

	// write bootloader settings to /etc/sysconfig

	y2milestone ("Bootloader type is: %1", LoaderType);

	SCR::Write (.sysconfig.bootloader.LOADER_TYPE, LoaderType);
	SCR::Write (.sysconfig.bootloader.LOADER_TYPE.comment,
		       "\n# Type of bootloader in use.
# On i386 and compatibles \"grub\" and \"lilo\" are allowed.
# Other platforms can have their specific bootloaders.
# For making the change effect run bootloader configuration tool
# and configure newly selected bootloader.\n#\n");
	SCR::Write (.sysconfig.bootloader.LOADER_LOCATION, location);
	SCR::Write (.sysconfig.bootloader.LOADER_LOCATION.comment,
		       "\n# Location of boot loader. Shall contain \"mbr\",
# \"floppy\", \"boot\" or \"custom\"\n#\n");

	if (LoaderType == "lilo")
	{
	    import "BootLILO";
	    BootLILO::Save ();
	}
	if (LoaderType == "grub")
	{
	    import "BootGRUB";
	    BootGRUB::Save ();
	}
	SCR::Write (.sysconfig.bootloader, nil);
    }

    /**
     * Write ()
     * !! call Save() prior to Write() !!
     *
     * write the boot manager to the final destination
     * set up all required configuration files
     */

    global define boolean Write ()
    ``{
	if (! was_set)
	{
	    Save ();
	    Set ();
	}

	if (location == "boot")
	    return true;

	import "Storage";
	if (Mode::live_eval)
	    return true;

	y2milestone ("LoaderType %1", LoaderType);
	SCR::Execute (.target.bash, "/usr/bin/touch /var/lib/YaST2/bootloader");
	map m = SCR::Read (.target.ycp, "/var/lib/YaST2/bootloader");
	if (m == nil || ! is (m, map))
	    m = $[];
	map orig = lookup (m, "original", $[]);
	orig = add (orig, "device", device);
	m = add (m, "original", orig);
	SCR::Write (.target.ycp, "/var/lib/YaST2/bootloader", m);
	if (Boot::BootPartitionDevice == "" || Boot::RootPartitionDevice == "")
	{
	    import "Lilo";
	    Boot::BootPartitionDevice = lookup (lookup (Lilo::partmap, `boot, $[]), "dev", "/dev/hda3");
	    Boot::RootPartitionDevice = lookup (lookup (Lilo::partmap, `root, $[]), "dev", "/dev/hda3");
	    Boot::others = Storage::GetForeignPrimary();
	}

	SCR::Execute (.target.bash, "touch /etc/sysconfig/bootloader");

	if (LoaderType == "grub")
	{
	    import "BootGRUB";
	    return BootGRUB::Write();
	}
	else if (LoaderType == "lilo")
	{
	    import "BootLILO";
	    return BootLILO::Write();
	}
	else if (LoaderType == "silo")
	{
	    import "BootSILO";
	    return BootSILO::Write();
	}
	else if (LoaderType == "milo")
	{
	    import "BootMILO";
	    return BootMILO::Write();
	}
	else if (LoaderType == "aboot")
	{
	    import "BootABOOT";
	    return BootABOOT::Write();
	}
	else if (LoaderType == "elilo")
	{
	    import "BootELILO";
	    return BootELILO::Write();
	}
	else if (LoaderType == "ppc")
	{
	    import "BootPPC";
	    return BootPPC::Write();
	}
	else if (LoaderType == "s390")
	{
	    import "BootS390";
	    return BootS390::Write();
	}
	y2error ("Unknown LoaderType '%1'", LoaderType);
	return false;
    }


    global define AskShowErrorLog( ) ``{
	return UI::AnyQuestionPopup(
                                    // heading for a popup box
                                    _("An error occured during saving bootloader configuration"),
                                    // question in a popup box
                                    _("Would you like to see the installation log file?"),
                                    UI::YesButtonLabel(),
                                    UI::NoButtonLabel(),
                                    `focus_no );
    };



}
