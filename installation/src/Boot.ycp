/**
 * File:
 *	Boot.ycp
 *
 * Module:
 *	Boot
 *
 * Summary:
 *	functions for bootload setup
 *
 * Authors:
 *	Klaus Kaempf <kkaempf@suse.de>
 *
 * $Id$
 *
 */
{
    module "Boot";

    import "Arch";
    import "Misc";
    import "Mode";

    import "StorageDevices";
    import "Storage";

    /**
     * @return list: modules for the initrd
     * (device driver and filesystem for the root partition)
     */
    global list initrdModules = [];

    /**
     * @return string: the systems boot mode, i.e.
     * "lilo", "grub", "silo", "milo", "aboot", "elilo", "ppc", "s390", "mips"
     */
    global string LoaderType = "";

    /**
     * @return string: vga value from cmdline
     */
    global string VgaType = "";

    /**
     * @return	string: boot device (partition)
     *
     */
    global string BootPartitionDevice = "";

    /**
     * @return	string: root device (partition)
     *
     */
    global string RootPartitionDevice = "";

    /**
     * @return	string: bootloader device location
     * "mbr", "floppy", or "custom"
     */
    global string location = "";

    /**
     * @return	boolean: bootloader device location was set manually
     */
    global boolean manual_location = false;

     /**
     * @return	string:  bootloader device
     * i.e. "/dev/hda" or "/dev/sdb2"
     */
    global string device = "";

    /**
     * @return	string: Boot disk (raw)
     *
     */
    global string bootDisk = "";

    /**
     * @return	string: The disk where the master boot record is located
     *
     */
    global string mbrDisk = "";

    /*
     * @return boolean: true if a single target system
     *
     */
    global boolean single_target = false;

    /**
     * @return list of strings: Other installed operating systems
     */
    global list others = [];

    /**
     * @return boolean: IDE and SCSI System
     *
     */
    global boolean mixed = false;

    //---------------------------------------------------------------

    // map of module arguments
    // $["module_name" : $["opt1":"val1", "opt2":"val2", ...], ...]
    map module_args = $[];

    //---------------------------------------------------------------

    /**
     * Constructor
     */

    global define void Boot()
    ``{
	string tmp_mods = SCR::Read (.etc.install_inf.InitrdModules);
	if (tmp_mods != nil)
	{
	    initrdModules = splitstring (tmp_mods, " ");
	}

	LoaderType = SCR::Read (.probe.boot_arch);
	if (LoaderType == "grub"
	    && Mode::update
	    && SCR::Read (.target.size, "/etc/sysconfig/bootloader") > 0)
	{
	    string sysconfig = SCR::Read (.sysconfig.bootloader.LOADER_TYPE);
	    if (sysconfig == "grub" || sysconfig == "lilo")
		LoaderType = sysconfig;
	}
	y2milestone ("Setting bootloader type to %1", LoaderType);
	return;
    }


    /**
     * LbaSupport ()
     * @return boolean	LBA support available
     */
    global define boolean LbaSupport ()
    ``{
	if (LoaderType == "lilo")
	{
	    import "BootLILO";
	    return BootLILO::lba_support;
	}
	return true;
    }

    /**
     * AddInitrdModule ()
     * @param	string	name of module
     * @param	string	args of module
     *
     * add module to initrdModules
     */
    global define void AddInitrdModule (string modname, string modargs)
    ``{
	if ((!contains (initrdModules, modname))
	    || ((modname == "aic7xxx")
		 && !contains (initrdModules, "aic7xxx_old"))
	    || ((modname == "aic7xxx_old")
		 && !contains (initrdModules, "aic7xxx")))
	{
	    initrdModules = add (initrdModules, modname);
	    if (size(modargs)  > 0)
	    {
		module_args[modname] = Misc::MergeOptions (modargs, $[]);
	    }
	}
	return;
    }

    /**
     * Check ()
     *
     * will warn if system may become non-bootable
     *
     */

    global define integer Check ()
    ``{
	// check /boot, /
	// check kernel <-> system

	return 0;
    }


    /**
     *  Set()
     *	@return void
     *  If nothing is configured, automatically determine values.
     *
     */

    global define void Set()
    ``{
	// get map of lists
	// $[ "/mount_point" : [partitionName, fsid, targetdevice, raid_type], ...]
	map mountPoints		= Storage::GetMountPoints();

	list mountdata_boot	= mountPoints["/boot"]:(mountPoints["/"]:[]);
	bootDisk		= mountdata_boot[2]:(mountPoints["/",2]:"");

	// check if /boot is on raid1
	boolean boot_is_raid1	= (mountdata_boot[3]:"" == "raid1");

	RootPartitionDevice	= mountPoints["/", 0]:"";

	if (bootDisk == ""
	    || RootPartitionDevice == "")
	{
	    y2error ("No mountpoint for / !!");
	}

	// if /boot changed, re-configure location
	if (BootPartitionDevice != mountPoints["/boot", 0]:RootPartitionDevice)
	{
	    BootPartitionDevice	= mountPoints["/boot", 0]:RootPartitionDevice;
	    if (!manual_location)
	    {
		// current location was not determined manually
		// so clear it here and force a re-calculation
		location = "";
	    }
	}

	if (boot_is_raid1)
	{
	    y2milestone ("/boot is on RAID1");
	    // use partitionName from GetMountPoints
	    mbrDisk		= mountdata_boot[0]:RootPartitionDevice;
	}
	else
	{
	    // normal mbr detection.
	    mbrDisk		= FindMbrDisk();
	}

	// Do not configure location automatically if already set.
	if (location == "")
	{
	    ConfigureLocation();
	}
	else if (Mode::autoinst)
	{
	    if (location == "mbr")
	    {		
		device = mbrDisk;
		y2milestone("location MBR, device = %1", device);
	    }
	    else if ( StorageDevices::FloppyPresent && location == "floppy")
	    {
		device   = StorageDevices::FloppyDevice;
	    }
	}
	
	y2milestone ("mbr at %1", mbrDisk);
	return;
    }

    /**
     *  ConfigureLocation()
     *	return void: Where to install the bootloader.
     *  It just gives "mbr" or "floppy"
     */

    global define ConfigureLocation()
    ``{
	location = "mbr";			// default to mbr
	device	 = mbrDisk;

	if (!IsBootAccessible()			// above cyl 1024
	    && StorageDevices::FloppyPresent)
	{
	    // if we're on an old system without lba support
	    // (the last needs a too big initrd, see bugzilla #7864)

	    location = "floppy";		// floppy and fd0
	    device   = StorageDevices::FloppyDevice;
	}

	// location was automatically determined
	manual_location = false;

	y2milestone ("ConfigureLocation (%1 on %2)", location, device);
	return;
    }

    /**
     *	IsBootAccessible()
     *	@return boolean:
     *
     */

    global define IsBootAccessible()
    ``{
	boolean boot_partition_accessible = true;

	if (!LbaSupport())
	{
	    string boot_mount_point = "";
	    // check, if no /boot partition exists

	    if (lookup (Storage::GetMountPoints(), "/boot", "") == "")
	    {
		boot_mount_point = "/";
	    }
	    else
	    {
		boot_mount_point = "/boot";
	    }

	    // check if boot mount point is below cyl 1024

	    foreach (string dname, map ddata, Storage::GetTargetMap(),
	    ``{
		list partitions = ddata["partitions"]:[];
		if (partitions != [])
		{
		    foreach (`pentry, partitions,
		    ``{
			if (pentry["mount"]:"" == boot_mount_point)
			{
			    boot_partition_accessible = (1024 > pentry["region",0]:0);
			}
		    });
		}

	    });

	}
	if (boot_partition_accessible)
	    y2milestone("Boot partition accessible");
	else
	    y2milestone("Boot partition unaccessible");

	return (boot_partition_accessible);
    }


    /*
     * FindMbrDisk()
     * try to find the system's mbr device
     * @return string	mbr device
     */

    global define string FindMbrDisk()
    ``{
	// can hwinfo find the disk ?

	string probed_mbr_disk = SCR::Read(.probe.boot_disk);
	if (probed_mbr_disk != "")
	{
	    y2milestone ("MBR probed as %1", probed_mbr_disk);
	    return probed_mbr_disk;
	}

	// look for disk with bios_id 0x80

	list disks = SCR::Read(.probe.disk);
	string mbr_disk = bootDisk;

	foreach (`disk, disks,
	``{
	    if (disk["bios_id"]:"" == "0x80")
	    {
		y2milestone ("disk with bios_id 0x80: %1", disk);
		mbr_disk = disk["dev_name"]:bootDisk;
	    }
	});

	y2milestone("MBR Disk: %1", mbr_disk);

	return mbr_disk;
    }


    /**
     * Save()
     * write status out (e.g. to /etc/sysconfig/...)
     *
     */

    global define void Save ()
    ``{
	string kernel_initrd = "";
	boolean modules_written = false;

	SCR::Execute (.target.bash, "/usr/bin/touch /etc/sysconfig/bootloader");

	if (Mode::update)
	{
	    // update: check for old lilo destination
	    SCR::Execute (.target.bash, "/usr/bin/touch /var/lib/YaST2/settings.ycp");
	    map old_user_settings = SCR::Read(.target.ycp, ["/var/lib/YaST2/settings.ycp", $[]]);
	    if (old_user_settings["lilo"]:"" == "floppy")
	    {
		Boot::location = "floppy";
	    }

	    // update !
	    // merge computed initrdModules with current settings
	    // keep old INITRD_MODULES, only add new modules

	    // (old variable already moved to sysconfig by aaa_base.

	    list old_initrd = [];
	    if (SCR::Read (.target.size, "/etc/sysconfig/bootloader") > 0)
		old_initrd = splitstring (SCR::Read (.sysconfig.kernel.INITRD_MODULES), " ");
	    map optmap = $[];

	    // loop over all initrdModules entries and add to
	    // old_initrd as needed.

	    foreach (`modname, initrdModules,
	    ``{
		// only those not already in INITRD_MODULES
		if (!contains (old_initrd, modname))
		{
		    // check for options for this module
		    // write to modules.conf if set
		    optmap = module_args[modname]:$[];
		    if (size (optmap) > 0)
		    {
			SCR::Write (.modules.options, optmap, modname);
			modules_written = true;
		    }
		    old_initrd = add (old_initrd, modname);
		}
	    });

	    y2milestone("Modules update for initrd:  %1", old_initrd);
	    kernel_initrd = mergestring (old_initrd, " ");
	}
	else		// install
	{
	    // write options to /etc/modules.conf
	    foreach (`modname, `optmap, module_args,
	    ``{
		if (size (optmap) > 0)
		{
		    SCR::Write (.modules.options, optmap, modname);
		    modules_written = true;
		}
	    });

	    y2milestone ("Modules for the initrd: %1", initrdModules);
	    kernel_initrd = mergestring (initrdModules, " ");
	}

	y2milestone ("Entries in /etc/sysconfig/kernel: %1", kernel_initrd);
	// write INITRD_MODULES
	SCR::Write (.sysconfig.kernel.INITRD_MODULES, kernel_initrd);
	SCR::Write (.sysconfig.kernel, nil);

	if (modules_written)
	{
	    SCR::Write (.modules, nil);
	}

	// write bootloader settings to /etc/sysconfig

	y2milestone ("Bootloader type is: %1", LoaderType);

	SCR::Write (.sysconfig.bootloader.LOADER_TYPE, LoaderType);
	SCR::Write (.sysconfig.bootloader.LOADER_TYPE.comment,
		       "\n# Type of bootloader in use.\n#\n");
	SCR::Write (.sysconfig.bootloader.LOADER_LOCATION, location);
	SCR::Write (.sysconfig.bootloader.LOADER_LOCATION.comment,
		       "\n# Location of boot loader.\n#\n");

	if (LoaderType == "lilo")
	{
	    import "BootLILO";
	    BootLILO::Save ();
	}
	if (LoaderType == "grub")
	{
	    import "BootGRUB";
	    BootGRUB::Save ();
	}
	SCR::Write (.sysconfig.bootloader, nil);
    }

    /**
     * Write ()
     * !! call Save() prior to Write() !!
     *
     * write the boot manager to the final destination
     * set up all required configuration files
     */

    global define boolean Write ()
    ``{
	if (Mode::live_eval)
	    return true;

	y2milestone ("LoaderType %1", LoaderType);
	SCR::Execute (.target.bash, "/usr/bin/touch /var/lib/YaST2/settings.ycp");
	map m = SCR::Read (.target.ycp, "/var/lib/YaST2/bootloader");
	if (m == nil || ! is (m, map))
	    m = $[];
	map orig = lookup (m, "original", $[]);
	orig = add (orig, "device", device);
	m = add (m, "original", orig);
	SCR::Write (.target.ycp, "/var/lib/YaST2/bootloader", m);
        if (Boot::BootPartitionDevice == "" || Boot::RootPartitionDevice == "")
        {
            import "Lilo";
            Boot::BootPartitionDevice = lookup (lookup (Lilo::partmap, `boot, $[]), "dev", "/dev/hda3");
            Boot::RootPartitionDevice = lookup (lookup (Lilo::partmap, `root, $[]), "dev", "/dev/hda3");
            Boot::others = Storage::GetForeignPrimary();
        }

	SCR::Execute (.target.bash, "touch /etc/sysconfig/bootloader");

	if (LoaderType == "grub")
	{
	    import "BootGRUB";
	    return BootGRUB::Write();
	}
	else if (LoaderType == "lilo")
	{
	    import "BootLILO";
	    return BootLILO::Write();
	}
	else if (LoaderType == "silo")
	{
	    import "BootSILO";
	    return BootSILO::Write();
	}
	else if (LoaderType == "milo")
	{
	    import "BootMILO";
	    return BootMILO::Write();
	}
	else if (LoaderType == "aboot")
	{
	    import "BootABOOT";
	    return BootABOOT::Write();
	}
	else if (LoaderType == "elilo")
	{
	    import "BootELILO";
	    return BootELILO::Write();
	}
	else if (LoaderType == "ppc")
	{
	    import "BootPPC";
	    return BootPPC::Write();
	}
	else if (LoaderType == "s390")
	{
	    import "BootS390";
	    return BootS390::Write();
	}
	y2error ("Unknown LoaderType '%1'", LoaderType);
	return false;
    }


}
