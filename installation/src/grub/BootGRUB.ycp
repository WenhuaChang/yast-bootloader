/**
 * File:
 *	BootGRUB.ycp
 *
 * Module:
 *	BootGRUB
 *
 * Summary:
 *	functions for bootload setup
 *
 * Authors:
 *	Anas Nashif <nashif@suse.de>
 *
 * $Id$
 *
 */
{
    module "BootGRUB";

    textdomain "bootloader";

    import "Arch";
    import "Boot";
    import "Kernel";

    /**
     * @return boolean: LBA Support
     *
     */
    global boolean lba_support	= false;

    // ----------------------------------------------------

    /**
     * local parameters, set via UI
     */

    boolean activate = false;

    boolean linear = false;

    // ----------------------------------------------------

    /**
     * DisplayLogFile
     * Displaying log files
     * @ return 'ok_help
     */
    global define DisplayLogFile( string msg_text ) ``{
	    term text = `RichText( "<p>" + msg_text + "</p>" );
	    OpenDialog(`opt ( `decorated ),
		       `VBox (`HSpacing(75),
				// heading
			      `Heading( _("Error Log File")),
			      text,	// e.g. `Richtext()
			      `PushButton( `id(`ok_help), `opt(`default), OKButtonLabel() )
			      )
		       );

	    SetFocus(`id(`ok_help) );

	    any r = UserInput();
	    CloseDialog();
	    return (r);
    };


    /**
     * WriteUpdate
     * Calling mk_initrd and lilo while update.
     * @ return void
     */
    global define void WriteUpdate()
    ``{
	// Calling mk_initrd

	if ( SCR::Execute (.target.bash, "/sbin/mk_initrd >> /var/log/y2logmk_initrd 2>> /var/log/y2logmk_initrd") != 0 )
	{
	    any retAsk = UI::AskShowLog( "mk_initrd" );
	    if ( retAsk == `yes )
	    {
		string text = "";

		text = SCR::Read (.target.string, "/var/log/y2logmk_initrd");
		DisplayLogFile( text );
	    }
	}

	// Generate grafical login

	string menu = SCR::Read (.target.string, "/boot/grub/menu.lst");
	list lines = splitstring (menu, "\n");
	lines = filter (`l, lines, ``(substring (l, 0, 7) != "gfxmenu" && substring (l, 0, 5) != "color"));
	lines = prepend (lines, "color white/green black/light-gray");
	lines = prepend (lines, sformat ("gfxmenu %1%2%3", lilo2Grub (Boot::BootPartitionDevice), prefix,  "message"));
	menu = mergestring (lines, "\n");
	SCR::Write (.target.string, "/boot/grub/menu.lst", menu);

	string grub_conf = SCR::Read (.target.string, "/etc/grub.conf");
	string command = sformat ("echo \"%1\" | grub --batch ", grub_conf);
	SCR::Execute(.target.bash, command);
    }



    /**
     * Set
     * Set LILO parameters (used in autoinst mode)
     * @ return void
     */
    global define void Set(boolean act, boolean lin, boolean lba)
    ``{
	activate = act;
	linear = lin;
	lba_support = lba;
	return;
    }

    /**
     * ProbeLBA
     *
     * probe BIOS for lba support and set global lba_support accordingly
     */

    global define void ProbeLBA()
    ``{
	list internal_bios = SCR::Read (.probe.bios);
	lba_support = internal_bios[0, "lba_support"]:false;
	return;
    }


    /**
     * AskParameters
     *
     * helper function for inst_bootloader
     * provide ui code to ask LILO specific parameters
     *
     * @returns: list of <uicode>
     */

    global define list AskParameters ()
    ``{
	return [];
    }

    /**
     * HelpParameters
     *
     * help text for the values from AskParameters ()
     *
     * @returns: string of help text
     */

    global define string HelpParameters ()
    ``{
	return "";
    }


    /**
     * HandleParameters
     *
     * helper function for inst_bootloader
     * called after UI::UserInput() returned
     *  (only if AskParameters() returned a non-empty list)
     */

    global define void HandleParameters ()
    ``{
	return;
    }


    /**
     * write the LILO bootloader
     *
     */

    global define boolean Write ()
    ``{
	import "Mode";
	import "Boot";
	import "Misc";
	import "StorageDevices";
	import "Storage";
	import "Report";

	include "ui/common_popups.ycp";
	include "lilo/routines.ycp";
	include "lilo/io.ycp";

	SCR::Execute (.target.bash, "test -f /etc/grub.conf || touch /etc/grub.conf");
	SCR::Execute (.target.bash, "test -d /boot/grub || mkdir /boot/grub;");
	SCR::Execute (.target.bash, "test -f /boot/grub/menu.lst || touch /boot/grub/menu.lst;");
	if (! Mode::update)
	{
	    SCR::Execute (.target.bash, "test -f /boot/grub/device.map && rm /boot/grub/device.map");
	}
	SCR::Execute (.target.bash, "test -f /boot/grub/device.map || echo \"quit\" | /usr/sbin/grub --device-map=/boot/grub/device.map");

        if ( Mode::update )
        {
            // update mode
            WriteUpdate();
            return true;
        }

        // check for bios_id on a ide/scsi mixed system
	// check if bios_id is given for a target

	string dev_map = SCR::Read (.target.string, "/boot/grub/device.map");
	y2milestone ("Got device map: %1", dev_map);
	list maps = filter (`e, splitstring (dev_map, "\n"), ``(e != ""));
	maps = maplist (`e, maps, ``{return filter (`f, splitstring (e, " \t"), ``(f != ""));});
	map mapping = $[];
	foreach (`e, maps, ``{mapping = add (mapping, select (e, 1, ""), select (e, 0, ""));});

	map targetMap = Storage::GetTargetMap();
	foreach (`target_dev, `target, targetMap, ``{
	    string bios_id = target["bios_id"]:"";
	    if (bios_id != "")
	    {
	        string grub_dev = sformat ("(hd%1)", (tointeger (bios_id) - tointeger ("0x80")));
	        foreach (`e, `f, mapping, ``{
		    if (e == target_dev || f == grub_dev)
		        mapping = remove (mapping, e);
	        });
		mapping = add (mapping, target_dev, grub_dev);
	    }
	});
	dev_map = "";
	foreach (`k, `v, mapping, ``{
	    dev_map = dev_map + sformat("%1\t%2\n", v, k);
	});
	y2milestone ("Fixed device mapping: %1", dev_map);
	SCR::Write (.target.string, "/boot/grub/device.map", dev_map);


	// Boot setup start

	// additional message that needs to be displayed
	string confirm_boot_msg = Misc::boot_msg;

	integer doresult = 0;
	string docmd = "/usr/lib/YaST2/bin/dolilo /";

	string prefix = "";

	if (Boot::BootPartitionDevice == Boot::RootPartitionDevice)
	    prefix = "/boot/";
	else
	    prefix = "/";
	string root_dev = lilo2Grub (Boot::BootPartitionDevice);

	string boot_sect = Boot::device;
	map settings = $[
	    "root": root_dev,
	    "stage1" : sformat ("%1grub/stage1", prefix),
	    "stage2" : sformat ("%1grub/stage2", prefix),
	    "discswitch": true,
	    "device" : lilo2Grub (boot_sect),
	    "addr" : "0x8000",
	    "menu" : sformat ("%1%2grub/menu.lst", lilo2Grub (Boot::BootPartitionDevice), prefix)
	];
	saveGrubConf (settings);
	string grub_conf = getGrubConf (settings);

	string menu = "";
	menu = menu + sformat ("gfxmenu %1%2%3\n", lilo2Grub (Boot::BootPartitionDevice), prefix,  "message");
	menu = menu + "color white/green black/light-gray\n";
	menu = menu + "default 0\n";
	menu = menu + "timeout 8\n";

	menu = menu + "\n";

        // if syslinux recognized a framebuffer, pass it to lilo

        integer vga = tointeger (Boot::VgaType);
	string vgastring = "";
        if (vga > 0)
        {
            list fbdev = SCR::Read(.probe.fbdev);
            string unique_key = fbdev[0, "unique_key"]:"";
            if (size (unique_key) > 0)
            {
                HwStatus::Set (unique_key, `yes);
            }
	    vgastring = sformat (" vga=%1", vga);
        }

	menu = menu + "title linux\n";
	menu = menu + sformat ("   kernel %1 %2 %3\n", sformat ("%1%2%3", lilo2Grub (Boot::BootPartitionDevice), prefix,  "vmlinuz"),
	    sformat ("root=%1", Boot::RootPartitionDevice), sformat ("%1 %2", Kernel::cmdLine, vgastring));
	menu = menu + sformat ("   initrd %1%2%3\n", lilo2Grub (Boot::BootPartitionDevice), prefix,  "initrd");

	y2debug ("others = %1", Boot::others);
	if (size (Boot::others) > 0)
        {
	    foreach (`o, Boot::others, ``{
		list parts = splitstring (o, " ");
		while (select (parts, 0, " ") == "")
		    parts = remove (parts, 0);
		string dev = select (parts, 0, "");
		dev = lilo2Grub (dev);
		parts = remove (parts, 0);
		string label = mergestring (parts, " ");
		if (dev != "" && label != "")
		{
		    menu = menu + sformat ("title %1\n", label);
		    menu = menu + sformat ("   root %1\n", dev);
		    menu = menu + "   makeactive\n   chainloader +1\n";
		}
	    });
	}

	if (StorageDevices::FloppyPresent)
	{
	    menu = menu + "title floppy\n";
	    menu = menu + sformat ("   root %1\n   chainloader +1\n",
		lilo2Grub (StorageDevices::FloppyDevice));
	}

	menu = menu + "title failsafe\n";
	menu = menu + sformat ("   kernel %1 %2 %3\n", sformat ("%1%2%3", lilo2Grub (Boot::BootPartitionDevice), prefix,  "vmlinuz.shipped"),
            sformat ("root=%1", Boot::RootPartitionDevice), "ide=nodma apm=off acpi=off vga=normal nosmp maxcpus=0 disableapic 3");
	menu = menu + sformat ("   initrd %1%2%3\n", lilo2Grub (Boot::BootPartitionDevice), prefix,  "initrd.shipped");

	if (-1 != SCR::Read (.target.size, "/boot/memtest.bin"))
        {
	    menu = menu + "title memtest86\n";
	    menu = menu + sformat ("   kernel %1%2%3\n", lilo2Grub (Boot::BootPartitionDevice), prefix,  "memtest.bin");
        }

	SCR::Write (.target.string, "/boot/grub/menu.lst", menu);


	y2milestone ("Starting mk_initrd");
	SCR::Execute(.target.bash, "/sbin/mk_initrd");
	y2milestone ("Starting GRUB");
	string command = sformat ("echo \"%1\" | /usr/sbin/grub --batch ", grub_conf);
	SCR::Execute(.target.bash, command);
	y2milestone ("GRUB installed");

	return true;
    }

    /**
     *
     * Save parameters to sysconfig
     */

    global define void Save()
    ``{
    }

    /**
     * constructor
     *
     * initializes lba_support
     */

    global define void BootGRUB()
    ``{
	ProbeLBA();

	return;
    }


}
