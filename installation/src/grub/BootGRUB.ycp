/**
 * File:
 *	BootGRUB.ycp
 *
 * Module:
 *	BootGRUB
 *
 * Summary:
 *	functions for bootload setup
 *
 * Authors:
 *	Anas Nashif <nashif@suse.de>
 *
 * $Id$
 *
 */
{
    module "BootGRUB";

    textdomain "bootloader";

    import "Arch";
    import "Boot";
    import "Kernel";

    /**
     * @return boolean: LBA Support
     *
     */
    global boolean lba_support	= false;

    // ----------------------------------------------------

    /**
     * local parameters, set via UI
     */

    boolean activate = false;

    boolean linear = false;

    // ----------------------------------------------------

    /**
     * DisplayLogFile
     * Displaying log files
     * @ return 'ok_help
     */
    global define DisplayLogFile( string msg_text ) ``{
	    term text = `RichText( "<p>" + msg_text + "</p>" );
	    OpenDialog(`opt ( `decorated ),
		       `VBox (`HSpacing(75),
				// heading
			      `Heading( _("Error Log File")),
			      text,	// e.g. `Richtext()
			      `PushButton( `id(`ok_help), `opt(`default), OKButtonLabel() )
			      )
		       );

	    SetFocus(`id(`ok_help) );

	    any r = UserInput();
	    CloseDialog();
	    return (r);
    };


    /**
     * WriteUpdate
     * Calling mk_initrd and lilo while update.
     * @ return void
     */
    global define void WriteUpdate()
    ``{
	// Calling mk_initrd

	if ( SCR::Execute (.target.bash, "/sbin/mk_initrd >> /var/log/YaST2/y2logmk_initrd 2>> /var/log/YaST2/y2logmk_initrd") != 0 )
	{
	    any retAsk = UI::AskShowLog( "mk_initrd" );
	    if ( retAsk == `yes )
	    {
		string text = "";

		text = SCR::Read (.target.string, "/var/log/YaST2/y2logmk_initrd");
		DisplayLogFile( text );
	    }
	}

	// Generate grafical login

	string menu = SCR::Read (.target.string, "/boot/grub/menu.lst");
	list lines = splitstring (menu, "\n");
	lines = filter (`l, lines, ``(substring (l, 0, 7) != "gfxmenu" && substring (l, 0, 5) != "color"));
	lines = prepend (lines, "color white/green black/light-gray");
	if (SCR::Read (.target.size, "/boot/message") > 0)
	    lines = prepend (lines, sformat ("gfxmenu %1%2%3", lilo2Grub (Boot::BootPartitionDevice), prefix,  "message"));
	menu = mergestring (lines, "\n");

        if ((SCR::Read (.target.size, "/boot/initrd") < 0)
	   || (SCR::Read (.target.size, "/boot/initrd.shipped") < 0))
        {
            y2milestone ("no initrd created");
            menu_l = splitstring (menu, "\n");
            if (SCR::Read (.target.size, "/boot/initrd") < 0)
                menu_l = filter (`i, menu_l, ``(! issubstring (i, "/boot/initrd")));
            if (SCR::Read (.target.size, "/boot/initrd.shipped") < 0)
                menu_l = filter (`i, menu_l, ``(! issubstring (i, "/boot/initrd.shipped")));
            menu = mergestring (menu_l, "\n");
            SCR::Write (.target.string, "/boot/grub/menu.lst", menu);
        }

	SCR::Write (.target.string, "/boot/grub/menu.lst", menu);

	string grub_conf = SCR::Read (.target.string, "/etc/grub.conf");
	string command = sformat ("echo \"%1\" | grub --batch --device-map=/boot/grub/device.map  >>/var/log/YaST2/y2loggrub 2>>/var/log/YaST2/y2loggrub", grub_conf);
	if (Boot::location == "floppy")
	{
	    SCR::Execute(.target.umount, "/media/floppy"); // Just for safety
            // popup
            UI::MessagePopup(_("The GRUB boot sector will be written to a floppy disk.
Insert a formatted floppy and confirm with 'OK'.
"));
	    while (true)
	    {
		integer ret = SCR::Execute (.target.bash, sformat ("/bin/dd if=/dev/zero of=%1 bs=512 count=0", boot_sect));
		if (ret == 0)
		    ret = SCR::Execute(.target.bash, command);
		if (ret == 0)
		{
			// popup
		    UI::MessagePopup(_("The GRUB boot sector has been written to a floppy disk."));
		    break;
		}
		else
		{
		    // yes-no popup
                    if ( !UI::YesNoPopup(_("Could not write GRUB boot sector to the floppy.
Please check that the floppy disk is formatted
and that the write protection tab is removed.
Do you want to try again?")) )
                        break;          // no choosen
		}
	    }
	}
	else
	{
	    if (0 != SCR::Execute(.target.bash, command))
		// error popup
		UI::ErrorPopup (_("An error occured during saving bootloader configuration"));
	}
    }



    /**
     * Set
     * Set GRUB parameters (used in autoinst mode)
     * @ return void
     */
    global define void Set(boolean act, boolean lin, boolean lba)
    ``{
	activate = act;
	linear = lin;
	lba_support = lba;
	return;
    }

    /**
     * ProbeLBA
     *
     * probe BIOS for lba support and set global lba_support accordingly
     */

    global define void ProbeLBA()
    ``{
	list internal_bios = SCR::Read (.probe.bios);
	lba_support = internal_bios[0, "lba_support"]:false;
	return;
    }


    /**
     * AskParameters
     *
     * helper function for inst_bootloader
     * provide ui code to ask GRUB specific parameters
     *
     * @returns: list of <uicode>
     */

    global define list AskParameters ()
    ``{
	return [];
    }

    /**
     * HelpParameters
     *
     * help text for the values from AskParameters ()
     *
     * @returns: string of help text
     */

    global define string HelpParameters ()
    ``{
	return "";
    }


    /**
     * HandleParameters
     *
     * helper function for inst_bootloader
     * called after UI::UserInput() returned
     *  (only if AskParameters() returned a non-empty list)
     */

    global define void HandleParameters ()
    ``{
	return;
    }


    /**
     * write the GRUB bootloader
     *
     */

    global define boolean Write ()
    ``{
	import "Mode";
	import "Boot";
	import "Misc";
	import "StorageDevices";
	import "Storage";
	import "Report";

	include "ui/common_popups.ycp";
	include "lilo/routines.ycp";

	SCR::Execute (.target.bash, "test -f /etc/grub.conf || touch /etc/grub.conf");
	SCR::Execute (.target.bash, "test -d /boot/grub || mkdir /boot/grub;");
	SCR::Execute (.target.bash, "test -f /boot/grub/menu.lst || touch /boot/grub/menu.lst;");
	if (Mode::initial)
	{
	    SCR::Execute (.target.bash, "test -f /boot/grub/device.map && rm /boot/grub/device.map");
	}
	SCR::Execute (.target.bash, "test -f /boot/grub/device.map || echo \"quit\" | /usr/sbin/grub --batch --device-map=/boot/grub/device.map");

        if ( Mode::update )
        {
            // update mode
            WriteUpdate();
            return true;
        }

        // check for bios_id on a ide/scsi mixed system
	// check if bios_id is given for a target

	string dev_map = SCR::Read (.target.string, "/boot/grub/device.map");
	y2milestone ("Got device map: %1", dev_map);
	list maps = filter (`e, splitstring (dev_map, "\n"), ``(e != ""));
	maps = maplist (`e, maps, ``{return filter (`f, splitstring (e, " \t"), ``(f != ""));});
	map mapping = $[];
	foreach (`e, maps, ``{mapping = add (mapping, select (e, 1, ""), select (e, 0, ""));});

	map targetMap = Storage::GetTargetMap();
	foreach (`target_dev, `target, targetMap, ``{
	    string bios_id = target["bios_id"]:"";
	    if (bios_id != "")
	    {
	        string grub_dev = sformat ("(hd%1)", (tointeger (bios_id) - tointeger ("0x80")));
	        foreach (`e, `f, mapping, ``{
		    if (e == target_dev || f == grub_dev)
		        mapping = remove (mapping, e);
	        });
		mapping = add (mapping, target_dev, grub_dev);
	    }
	});
	dev_map = "";
	foreach (`k, `v, mapping, ``{
	    dev_map = dev_map + sformat("%1\t%2\n", v, k);
	});
	y2milestone ("Fixed device mapping: %1", dev_map);
	SCR::Write (.target.string, "/boot/grub/device.map", dev_map);


	// Boot setup start

	// additional message that needs to be displayed
	string confirm_boot_msg = Misc::boot_msg;

	integer doresult = 0;
	string docmd = "/usr/lib/YaST2/bin/dolilo /";

	string prefix = "";

	if (Boot::BootPartitionDevice == Boot::RootPartitionDevice)
	    prefix = "/boot/";
	else
	    prefix = "/";
	string root_dev = lilo2Grub (Boot::BootPartitionDevice);

	string boot_sect = Boot::device;
	map settings = $[
	    "root": root_dev,
	    "stage1" : sformat ("%1grub/stage1", prefix),
	    "stage2" : sformat ("%1grub/stage2", prefix),
	    "discswitch": true,
	    "device" : lilo2Grub (boot_sect),
	    "addr" : "0x8000",
	    "menu" : sformat ("%1%2grub/menu.lst", lilo2Grub (Boot::BootPartitionDevice), prefix)
	];
	saveGrubConf (settings);
	string grub_conf = getGrubConf (settings);

	string menu = "";
	if (SCR::Read (.target.size, "/boot/message") > 0)
	    menu = menu + sformat ("gfxmenu %1%2%3\n", lilo2Grub (Boot::BootPartitionDevice), prefix,  "message");
	menu = menu + "color white/green black/light-gray\n";
	menu = menu + "default 0\n";
	menu = menu + "timeout 8\n";

	menu = menu + "\n";

        // if syslinux recognized a framebuffer, pass it to lilo

        integer vga = tointeger (Boot::VgaType);
	string vgastring = "";
        if (vga > 0)
        {
            list fbdev = SCR::Read(.probe.fbdev);
            string unique_key = fbdev[0, "unique_key"]:"";
            if (size (unique_key) > 0)
            {
                HwStatus::Set (unique_key, `yes);
            }
	    vgastring = sformat (" vga=%1", vga);
        }

	menu = menu + "title linux\n";
	menu = menu + sformat ("   kernel %1 %2 %3\n", sformat ("%1%2%3", lilo2Grub (Boot::BootPartitionDevice), prefix,  "vmlinuz"),
	    sformat ("root=%1", Boot::RootPartitionDevice), sformat ("%1 %2", Kernel::cmdLine, vgastring));
	menu = menu + sformat ("   initrd %1%2%3\n", lilo2Grub (Boot::BootPartitionDevice), prefix,  "initrd");

	y2debug ("others = %1", Boot::others);
	if (size (Boot::others) > 0)
        {
	    foreach (`o, Boot::others, ``{
		list parts = splitstring (o, " ");
		while (select (parts, 0, " ") == "")
		    parts = remove (parts, 0);
		string dev = select (parts, 0, "");
		dev = lilo2Grub (dev);
		parts = remove (parts, 0);
		string label = mergestring (parts, " ");
		if (dev != "" && label != "")
		{
		    menu = menu + sformat ("title %1\n", label);
		    menu = menu + sformat ("   root %1\n", dev);
		    menu = menu + "   makeactive\n   chainloader +1\n";
		}
	    });
	}

	if (StorageDevices::FloppyPresent)
	{
	    menu = menu + "title floppy\n";
	    menu = menu + sformat ("   root %1\n   chainloader +1\n",
		lilo2Grub (StorageDevices::FloppyDevice));
	}

	menu = menu + "title failsafe\n";
	menu = menu + sformat ("   kernel %1 %2 %3\n", sformat ("%1%2%3", lilo2Grub (Boot::BootPartitionDevice), prefix,  "vmlinuz.shipped"),
            sformat ("root=%1", Boot::RootPartitionDevice), "ide=nodma apm=off acpi=off vga=normal nosmp maxcpus=0 disableapic 3");
	menu = menu + sformat ("   initrd %1%2%3\n", lilo2Grub (Boot::BootPartitionDevice), prefix,  "initrd.shipped");

	if (SCR::Read (.target.size, "/boot/memtest.bin") > 0)
        {
	    menu = menu + "title memtest86\n";
	    menu = menu + sformat ("   kernel %1%2%3\n", lilo2Grub (Boot::BootPartitionDevice), prefix,  "memtest.bin");
        }

	SCR::Write (.target.string, "/boot/grub/menu.lst", menu);

	y2milestone ("Starting mk_initrd");
	boolean ret = (0 == SCR::Execute(.target.bash, "/sbin/mk_initrd >> /var/log/YaST2/y2logmk_initrd 2>> /var/log/YaST2/y2logmk_initrd"));
        if (! ret)
        {
            any retAsk = UI::AskShowLog( "mk_initrd" );
            if ( retAsk == `yes )
            {
                string text = "";

                text = SCR::Read (.target.string, "/var/log/YaST2/y2logmk_initrd");
                DisplayLogFile( text );
            }
        }

	if ((SCR::Read (.target.size, "/boot/initrd") < 0)
	    || (SCR::Read (.target.size, "/boot/initrd.shipped") < 0))
	{
	    y2milestone ("no initrd created");
	    menu_l = splitstring (menu, "\n");
	    if (SCR::Read (.target.size, "/boot/initrd") < 0)
		menu_l = filter (`i, menu_l, ``(! issubstring (i, "/boot/initrd")));
	    if (SCR::Read (.target.size, "/boot/initrd.shipped") < 0)
		menu_l = filter (`i, menu_l, ``(! issubstring (i, "/boot/initrd.shipped")));
	    menu = mergestring (menu_l, "\n");
	    SCR::Write (.target.string, "/boot/grub/menu.lst", menu);
	}
	y2milestone ("Starting GRUB");
	string command = sformat ("echo \"%1\" | /usr/sbin/grub --batch --device-map=/boot/grub/device.map  >>/var/log/YaST2/y2loggrub 2>>/var/log/YaST2/y2loggrub", grub_conf);

        if (ret && Boot::location == "floppy")
        {
            SCR::Execute(.target.umount, "/media/floppy"); // Just for safety
            // popup
            UI::MessagePopup(_("The GRUB boot sector will be written to a floppy disk.
Insert a formatted floppy and confirm with 'OK'.
"));
            while (true)
            {
		ret = (0 == SCR::Execute (.target.bash, sformat ("/bin/dd if=/dev/zero of=%1 bs=512 count=0", boot_sect)));
		ret = ret && (0 == SCR::Execute(.target.bash, command));
                if (ret == true)
                {
                    UI::MessagePopup(_("The GRUB boot sector has been written to a floppy disk."));
                    break;
                }
                else
                {
                    // yes-no popup
                    if ( !UI::YesNoPopup(_("Could not write GRUB boot sector to the floppy.
Please check that the floppy disk is formatted
and that the write protection tab is removed.
Do you want to try again?")) )
                        break;          // no choosen
                }
            }
        }
        else
	{
	     ret = ret && (0 == SCR::Execute(.target.bash, command));
        }

	y2milestone ("GRUB installed");

	if (nil != findlastof (boot_sect, "/"))
	    boot_sect = substring (boot_sect, findlastof (boot_sect, "/") + 1);
	integer part = tointeger (substring (boot_sect, size (boot_sect) - 1));
	if (part != nil && part != 0)
	{
	    boot_sect = "/dev/" + substring (boot_sect, 0, size (boot_sect) - 1);
	    y2milestone ("Activating partition %1 on %2", part, boot_sect);
	    return 0 == SCR::Execute (.target.bash, sformat ("/sbin/sfdisk -A%1 %2", part, boot_sect));
	}
	if (! ret)
	    UI::ErrorPopup (_("An error occured during saving bootloader configuration"));
	return ret;
    }

    /**
     *
     * Save parameters to sysconfig
     */

    global define void Save()
    ``{
    }

    /**
     * constructor
     *
     * initializes lba_support
     */

    global define void BootGRUB()
    ``{
	ProbeLBA();

	return;
    }


}
