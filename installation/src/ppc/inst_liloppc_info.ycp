/**
 * DISABLED FIXME
 * $Id$
 *
 * Module:	inst_liloppc_info.ycp
 *
 * Author:	Olaf Hering <olh@suse.de>
 *
 * Purpose:	Installing the bootloader on ppc
 *
 */
{
    textdomain "bootloader";

    import "Arch";
    import "Boot";
    import "Storage";

    import "Wizard";

    // check going_backwards from Args(2)
    boolean workflow_lilo_expert = lookup (user_settings, "workflow_lilo_expert", false);

    if (!Arch::ppc || Arch::ppc_board_mac_nubus)
    {
        return `auto;
    }

    if ((WFM::Args(2) == true)
	&& workflow_lilo_expert)
    {
	return WFM::CallFunction( `inst_lilo_expert ( true, true ) );
    }

    string name_of_bootloader = "Lilo";

    // ----------------------------------------------------------------
    // get user_settings data

    string lilo			= lookup ( user_settings, "lilo", "" );
    string lilo_device		= lookup ( user_settings, "lilo_device", "" );

    // remember if LILO/Linux is alone (-> MBR)
    boolean lilo_alone		= lookup ( user_settings, "lilo_alone", false);

    boolean has_floppy		= lookup ( user_settings, "has_floppy", false);

    map mountPoints		= lookup ( user_settings, "mountpoints", $[]);

    // boot device (partition)
    string boot_device		= select (lookup(mountPoints, "/boot", lookup (mountPoints, "/", [])), 0);

    // boot disk (raw disk)
    string boot_device_disk	= select (lookup(mountPoints, "/boot", lookup (mountPoints, "/", [])), 2);

    string mbr_disk		= boot_device_disk;
    string root_device		= select (lookup (mountPoints, "/", []), 0);		// root device (partition)

    boolean whole_disk		= lookup ( user_settings, "whole_disk", false);

    boolean activate_boot_partition = true;
    boolean install_boot_loader = true;

    // ----------------------------------------------------------------
    // try to find the system's mbr device

    map targetMap		= Storage::GetTargetMap();
    if(Arch::board_mac_old || Arch::board_mac_nubus)
    {
      lilo = "pmac_old";
      } else if (Arch::board_mac_new)
      {
      lilo = "pmac_new";
      } else if (Arch::board_chrp)
      {
      lilo = "chrp";
      } else if (Arch::board_prep)
      {
      lilo = "prep";
      } else if (Arch::board_iseries)
      {
      lilo = "iseries";
      } else {
      lilo = "unknown";
      }

y2milestone("lilo %1",lilo);
y2milestone("lilo_device %1",lilo_device);
y2milestone("lilo_alone %1",lilo_alone);
y2milestone("has_floppy %1",has_floppy);
y2milestone("mountPoints %1",mountPoints);
y2milestone("boot_device %1",boot_device);
y2milestone("boot_device_disk %1",boot_device_disk);
y2milestone("mbr_disk %1",mbr_disk);
y2milestone("root_device %1",root_device);
y2milestone("whole_disk %1",whole_disk);
y2milestone("targetMap %1",targetMap);
y2milestone("user_settings %1",user_settings);




    // ----------------------------------------------------------------
    // check for automatic lilo settings

    string info_msg = "";
    list possible_boot_partitions = [];
    list pdisk_partitions = [];
    integer maybe_the_bootpartition = -1;

    if((lilo == "pmac_new") || (lilo == "pmac_old"))
    {

		integer i = 0;
		integer j = 0;
		integer partition_counter = 0;
		integer partition_size = 0;
		integer boot_partition_size = -1;
		string partition_name = "";
		string volume_name = "";
		integer partition_number = 0;
		y2milestone("running on %1 ", lilo);
		// info message
		info_msg =  _( "
A NewWorld PowerMacintosh must be booted with yaboot.

Please select the boot volume for the bootloader.
You can also specify the volume of your MacOS 9/X installation.
");

	// check for available Apple_HFS partitions for the bootloader
	foreach (`dname, `ddata, targetMap,
	``{
		list partitions = lookup (ddata, "partitions", []);
		if (partitions != [])
		{
		y2milestone("111partitions2 %1",partitions);
			foreach (`pentry, partitions,
			``{
				partition_name = lookup (pentry, "fstype", "");
				partition_number = lookup (pentry, "nr", "");
				i = find(partition_name, "(");
				j = size(partition_name) - i - 2;
				volume_name = substring(partition_name,i+1,size(partition_name) - i - 2);
				i = 0;
				i = find(partition_name, "Apple_HFS" );
				if (i != 0)
				{
					i = find(partition_name, "Apple_Bootstrap" );
				}
				if (i == 0)
				{
					partition_size = (select(lookup(pentry, "region",[]),1) / 2) / 1024;
					partition_counter = partition_counter + 1;
					possible_boot_partitions = add(possible_boot_partitions,dname + partition_number);
					pdisk_partitions = add(pdisk_partitions,`item(`id(partition_counter), "" + partition_size + " Mb  " + volume_name));
					if ( (partition_size < boot_partition_size) || (boot_partition_size < 0))
					{
						maybe_the_bootpartition = partition_counter;
						y2milestone("partition_counter could be bootpartition %1 partition_size %2 boot_partition_size %3",partition_counter,partition_size,boot_partition_size);
						boot_partition_size = partition_size;
					}
				}
		y2milestone("possible_boot_partitions %1", possible_boot_partitions);
		y2milestone("pdisk_partitions %1", pdisk_partitions);
			});
		}
	});

    } // lilo == pmac_new

    if(lilo == "prep" || lilo == "chrp")
    {

	integer partition_type = 0;
	integer partition_number = 0;
	integer partition_counter = 0;
	y2milestone("running on %1 ", lilo);

	// check for available partitions of type "41 PReP Boot Partition" for the bootloader
	foreach (`dname, `ddata, targetMap,
	``{
		list partitions = lookup (ddata, "partitions", []);
		y2milestone("partitions %1",partitions);
		if (partitions != [])
		{
		y2milestone("partitions2 %1",partitions);
			foreach (`pentry, partitions,
			``{
				partition_type = lookup (pentry, "fsid", "");
				partition_number = lookup (pentry, "nr", "");
		y2milestone("dname %1 partition_type %2 partition_number %3 ",dname,partition_type, partition_number);
				if(partition_type == 65)
				{
				partition_counter = partition_counter + 1;
				possible_boot_partitions = add(possible_boot_partitions,(dname + partition_number));
				pdisk_partitions = add(pdisk_partitions,`item(`id(partition_counter), "" + dname + partition_number));
				}
		y2milestone("possible_BOOT_partitions %1",possible_boot_partitions);
		y2milestone("PDISK_partitions %1", pdisk_partitions);
			});
		}
	});

    } // lilo == prep

    term optional_button = `Empty();

    // determine destination location of lilo boot loader
    term contents = `VBox(`Label( info_msg ), optional_button);

    // help text system start configuration, boot manager, (%1 == lilo, elilo, ...) and so on
    // help part 1 of 7
    string help_text = sformat (_("<p>
SuSE Linux comes with a boot manager, <b><i>%1</i></b>, which is capable of
starting Linux as well as other operating systems.
</p>"), name_of_bootloader);


	if ( (lilo == "pmac_new") || (lilo == "pmac_old"))
	{
	contents = add(contents,
			`VBox(
				`ComboBox(`id(`real_boot_partition),
					// combo box
					_("Select your &boot volume:"),
					pdisk_partitions)
			)
                     );
		if (size(pdisk_partitions) > 1)
		{
			contents = add(contents,
					`VBox(
						`ComboBox(`id(`real_macos_partition),
							// combo box
							_("Select your partition for &MacOS:"),
							pdisk_partitions)
					)
				    );
		}
	}
	else // ! pmac_new
	{
	contents = add(contents,
			`VBox(
				`ComboBox(`id(`real_boot_partition),
					// combo box
					_("Select your partition for the &boot loader:"),
					pdisk_partitions)
			)
               );
	} // ! pmac_new

	contents = add ( contents,
			`HBox(
			  `HSpacing(4),
			  `HWeight(75, `VCenter(
				`VBox(
					`Left(`TextEntry(
						`id( `boot_params ),
						// Text input field to enter additional boot parameters
						_("&Kernel boot parameters:"),
						Boot::parameters
							)
						),
					`VSpacing(0.8),
					`Left(`CheckBox(
						`id( `activate ),
						// check box: activate partition where LILO is installed ?
						_("Ac&tivate LILO partition"),
						activate_boot_partition
							)
						)
					)
					)
				),
				`HWeight(25, `HStretch() )
			  )
			);


    // Suggested LILO installation - can be overridden with expert mode.
    Wizard::SetContents(_("System Boot Configuration"),
			    contents,
			    help_text,
			    WFM::Args(0), WFM::Args(1));

   // assume the smallest Apple_HFS partition is the boot volume
   if(Arch::board_mac)
   {
	   UI::ChangeWidget(`id(`real_boot_partition),`Value, maybe_the_bootpartition);
	   if((maybe_the_bootpartition > 1) && (size(possible_boot_partitions) > 1))
	   {
		UI::ChangeWidget(`id(`real_macos_partition),`Value, 1);
	   }
   }
    // Event handling

    any ret = nil;

    while (true)
    {

	ret = UI::UserInput();

	if ((ret == `abort)
	    && WFM::CallFunction(`inst_confirm_abort(`painless)))
	{
	    return `abort;
	}

	if ( ret == `next || ret == `back )
	{
	    any option = UI::QueryWidget(`id(`real_boot_partition), `Value);
	    y2milestone("option = %1", option);
	    {
		change (user_settings, "ppc_boot_device", select(possible_boot_partitions,option - 1));
	    }

	    option = UI::QueryWidget(`id(`real_macos_partition), `Value);
	    y2milestone("option = %1", option);
	    if (option != nil)
	    {
		change (user_settings, "other_device", select(possible_boot_partitions,option - 1));
	    }

	    option = UI::QueryWidget(`id(`boot_params), `Value);
	    y2milestone("option = %1", option);
	    if (is (option, string))
	    {
		Boot::parameters = option;
	    }

	    option = UI::QueryWidget(`id(`activate), `Value);
	    y2milestone("option = %1", option);
	    if (is (option, boolean))
	    {
		change (user_settings, "lilo_activate", option);
	    }

	    change (user_settings, "workflow_lilo_expert", false);

	    y2milestone("ppc_boot_device %1 other_device %2 boot_parameters %3 lilo_activate %4 ",
		lookup(user_settings, "ppc_boot_device",""),
		lookup(user_settings,"other_device",""),
		Boot::parameters,
		lookup(user_settings,"lilo_activate",""));

	    return ret;
	}

    }

    // NOTREACHED
}

