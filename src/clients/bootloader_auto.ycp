/**
 * File:
 *      bootloader_auto.ycp
 *
 * Module:
 *      Bootloader installation and configuration
 *
 * Summary:
 *      Bootloader autoinstallation preparation
 *
 * Authors:
 *      Jiri Srain <jsrain@suse.cz>
 *
 * $Id$
 *
 */
{
    textdomain "bootloader";

    y2milestone("----------------------------------------");
    y2milestone("bootloader auto started");

    import "Arch";
    import "Bootloader";
    import "BootCommon";
    import "Wizard";
    import "Initrd";
    import "Progress";

    include "bootloader/routines/routines.ycp";

    Progress::off();

    /**
      * Translate the autoinstallation map to the Export map
      * @param ai map the autoinstallation map
      * @return map the export map
      */
    define map<string,any> AI2Export (map<string,any> ai) ``{
	// bootloader type and location stuff
	map exp = $[
	    "loader_type" : ai["loader_type"]:"",
	    "location" : ai["location"]:"",
	    "loader_device" : ai["loader_device"]:"",
	    "specific" : $[],
	];
	if (Arch::ppc)
	{
	    if (haskey (ai, "prep_boot_partition"))
	    {
		exp["specific", "prep_boot_partition"]
		    = ai["prep_boot_partition"]:"";
	    }
	    if (haskey (ai, "streamfile"))
	    {
		exp["specific", "streamfile"]
		    = ai["streamfile"]:"";
	    }
	    if (haskey (ai, "iseries_write_slot_a"))
	    {
		exp["specific", "iseries_write_slot_a"]
		    = ai["iseries_write_slot_a"]:true;
	    }
	    if (haskey (ai, "iseries_write_slot_b"))
	    {
		exp["specific", "iseries_write_slot_b"]
		    = ai["iseries_write_slot_b"]:true;
	    }
	    if (haskey (ai, "of_defaultdevice"))
	    {
		exp["specific", "of_defaultdevice"]
		    = ai["of_defaultdevice"]:false;
	    }
	}

	// initrd stuff
	list modlist = [];
	map modsett = $[];
	foreach(map mod, ai["initrd_modules"]:[], ``{
	    modlist = add(modlist, mod["module"]:"");
	    modsett = add(modsett, mod["module"]:"", mod["module_args"]:$[]);
	});
	if (size(modlist) > 0 )
	    exp["initrd"] = $[ "list": modlist, "settings" : modsett ];

	// sections stuff
	exp["specific", "sections"] = maplist (list s, ai["sections"]:[], ``{
	    return nil;

	});
	string default_key = BootCommon::getDefaultKey ();
	if (haskey (ai, "default"))
	{
	    any default_val = nil;
	    if (BootCommon::getDefaultType () == `index)
	    {
		integer index = BootCommon::getDefaultFirstIndex () -1;
		foreach (map s, ai["sections"]:[], ``{
		    index = index + 1;
		    if (s["title"]:"" == ai["default"]:"")
			default_val = index;
		});
	    }
	    else
	    {
		default_val = ai["default"]:"";
	    }
	    if (default_val != nil) // TODO check section existence
	    {
		exp["specific", "global"] = filter (
		    map m,
		    exp["specific", "global"]:[],
		``(
		    m["key"]:"" != default_key
		));
		exp["specific", "global"] = add (exp["specific", "global"]:[],
		    $[
			"key" : default_key,
			"value" : default_val,
		    ]
		);
	    }
	}
	ai["default"] = nil;
	any default_val
	    = lookup_value (exp["specific", "global"]:[], default_key, nil);
	string default = nil;
	if (default_val != nil)
	{
	    if (BootCommon::getDefaultType () == `index)
	    {
		default = (string)(ai["sections", (integer)default_val, "title"]:nil);
	    }
	    else
	    {
		default = (string) default_val;
	    }
	}
	if (default != nil)
	    ai["default"] = default;

	return (map<string,any>)exp;
    }

    /**
      * Translate the Export map to the autoinstallation map
      * @param exp map the export map
      * @return map the autoinstallation map
      */
    define map<string,any> Export2AI (map<string,any> exp) ``{
	// bootloader type and location stuff
	map ai = $[
	    "loader_type" : exp["loader_type"]:"",
	    "location" : exp["location"]:"",
	    "loader_device" : exp["loader_device"]:"",
	];
	if (Arch::ppc)
	{
	    if (haskey (exp["specific"]:$[], "prep_boot_partition"))
	    {
		ai["prep_boot_partition"]
		    = exp["specific", "prep_boot_partition"]:"";
	    }
	    if (haskey (exp["specific"]:$[], "iseries_streamfile"))
	    {
		ai["streamfile"]
		    = exp["specific", "iseries_streamfile"]:"";
	    }
	    if (haskey (exp["specific"]:$[], "iseries_write_slot_a"))
	    {
		ai["iseries_write_slot_a"]
		    = exp["specific", "iseries_write_slot_a"]:true;
	    }
	    if (haskey (exp["specific"]:$[], "iseries_write_slot_b"))
	    {
		ai["iseries_write_slot_b"]
		    = exp["specific", "iseries_write_slot_b"]:true;
	    }
	    if (haskey (exp["specific"]:$[], "of_defaultdevice"))
	    {
		ai["of_defaultdevice"]
		    = exp["specific", "of_defaultdevice"]:false;
	    }
	}

	// initrd stuff
	list<map> ayinitrd = maplist(string m, exp["initrd", "list"]:[], ``{
	    map tmp = $[];
	    tmp["module"] = m;
	    if (exp["initrd", "settings", m]:$[] != $[])
		tmp["module_args"] = exp["initrd", "settings", m]:$[];
	    return (tmp);
	});
	if (size(ayinitrd) > 0 )
	    ai["initrd_modules"] = ayinitrd;

	// sections stuff
	ai["sections"] = maplist (list s, exp["specific", "sections"]:[], ``{
	    return nil;
	});
	string default = nil;
	string default_key = BootCommon::getDefaultKey ();
	any default_val
	    = lookup_value (exp["specific", "global"]:[], default_key, nil);
	if (default_val != nil)
	{
	    if (BootCommon::getDefaultType () == `index)
	    {
		default = (string)(ai["sections", (integer)default_val, "title"]:nil);
	    }
	    else
	    {
		default = (string) default_val;
	    }
	}
	if (default != nil)
	    ai["default"] = default;
	return (map<string,any>)ai;
    }


    any ret = nil;
    string func = "";
    map param = $[];

    /* Check arguments */
    if(size((list)WFM::Args()) > 0 && is(WFM::Args(0), string)) {
	func = (string)WFM::Args(0);
	if(size((list)WFM::Args()) > 1 && is(WFM::Args(1), map))
	    param = (map)WFM::Args(1);
    }
    y2debug("func=%1", func);
    y2debug("param=%1", param);

    if(func == "Import")
    {
	ret = Bootloader::Import(AI2Export ((map<string,any>)param));
    }
    /**
      * Create a summary
      * return string
      */
    else if(func == "Summary") {
	ret = "<UL>"
            + mergestring (maplist (string l, Bootloader::Summary(),
		``("<LI>" + l)),
		"\n")
            + "</UL>";
    }
    /**
      * Reset configuration
      * return map or list
      */
    else if (func == "Reset") {
	Bootloader::Reset();
	ret =  ($[]);
    }
    /**
      * Change configuration
      * return symbol (i.e. `finish || `accept || `next || `cancel || `abort)
      */
    else if (func == "Change") {
	ret = Bootloader::BootloaderAutoSequence ();
	return ret;
    }
    /**
      * Return configuration data
      * return map or list
      */
    else if (func == "Export") {
	ret = Export2AI ((map<string,any>)Bootloader::Export());
    }
    /**
      * Write configuration data
      * return boolean
      */
    else if (func == "Write") {
	ret = Bootloader::Write();
    }
    else if (func == "Read") {
	Initrd::Read ();
	ret = Bootloader::Read();
    }

    /* unknown function */
    else {
	y2error("unknown function: %1", func);
	ret =  false;
    }
    Progress::on();

    y2debug("ret=%1", ret);
    y2milestone("bootloader_auto finished");
    y2milestone("----------------------------------------");

    return ret;

/* EOF */

}
