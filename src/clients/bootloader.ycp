/**
 * File:
 *      bootloader.ycp
 *
 * Module:
 *      Bootloader installation and configuration
 *
 * Summary:
 *      Main file of bootloader configuration
 *
 * Authors:
 *      Jiri Srain <jsrain@suse.cz>
 *
 * $Id$
 *
 */
{
    textdomain "bootloader";
    import "Arch";
    import "BootCommon";
    import "Bootloader";
    import "CommandLine";
    import "Mode";
    import "Progress";
    import "Wizard";
    import "RichText";

    include "bootloader/routines/routines.ycp";
    include "commandline/commandline.ycp";

// --------------------------------------------------------------------------
// --------------------------------- cmd-line handlers

    /**
      * CommandLine handler for running GUI
      * @return boolean true if settings were saved
      */
    define boolean GuiHandler () ``{
        symbol ret = nil;
	ret = Bootloader::BootloaderSequence ();

        if (ret == `abort || ret == `back || ret == `nil)
            return false;
        return true;
    }

    /**
     * Print summary of basic options
     * @param options a list of parameters passed as args
     * @return boolean false
     */
    define boolean BootloaderSummaryHandler (map options ) ``{
        CommandLine::Print (RichText::Rich2Plain(
            "<br>"+mergestring (Bootloader::Summary (), "<br>")));
        return false; // do not call Write...
    }

    define boolean BootloaderModifySection (string section,
	string key, any value)
    ``{
	if (section == nil)
	{
	    BootCommon::globals = modifySection (
		BootCommon::globals,
		key,
		value
	    );
	    return true;
	}
	else
	{
	    integer index = BootCommon::getSectionIndex (section);
	    if (index != nil)
	    {
		BootCommon::sections[index] = modifySection (
		    BootCommon::sections[index]:[],
		    key,
		    value
		);
		return true;
	    }
	    else
	    {
		// command line error report, %1 is section name
		CommandLine::Print (sformat (_("Section %1 not found."),
		    section));
		return false;
	    }
	}
	return false;


    }

    /**
     * Set specified option in specified section
     * @param options a list of parameters passed as args
     * @return boolean true on success
     */
    define boolean BootloaderSetHandler (map options) ``{
	string section = (string)(options["section"]:nil);
	string option = (string)(options["option"]:nil);
	any value = options["value"]:nil;
	if (value == nil)
	{
	    // command line error report
	    CommandLine::Print (_("Value was not specified."));
	    return false;
	}
	return BootloaderModifySection (section, option, value);
    }

    /**
     * Delete specified option in specified section
     * @param options a list of parameters passed as args
     * @return boolean true on success
     */
    define boolean BootloaderDeleteHandler (map options) ``{
	string section = (string)(options["section"]:nil);
	if (! haskey (options, "option"))
	{
	    integer index = BootCommon::getSectionIndex (section);
	    if (index == nil)
	    {
		// command line error report, %1 is section name
		CommandLine::Print (sformat (_("Section %1 not found."),
		    section));
		return false;
	    }
	    BootCommon::sections[index] = nil;
	    BootCommon::sections = filter (list<map> s, BootCommon::sections, ``(
		s != nil
	    ));
	    return true;
	}
	string option = (string)(options["option"]:nil);
	return BootloaderModifySection (section, option, nil);
    }

    /**
     * Add a new bootloader section with specified name
     * @param options a list of parameters passed as args
     * @return boolean true on success
     */
    define boolean BootloaderAddHandler (map options) ``{
	string section = (string)(options["section"]:nil);
	if (section == nil)
	{
	    // command line error report
	    CommandLine::Print (_("Section name must be specified."));
	    return false;
	}
	BootCommon::sections = add (BootCommon::sections, [
	    $[
		"key" : BootCommon::getSectionTitle (),
		"value" : section,
	    ]
	]);
    }

    /**
     * Print the value of specified option of specified section
     * @param options a list of parameters passed as args
     * @return boolean true on success
     */
    define boolean BootloaderPrintHandler (map options) ``{
	string section = (string)(options["section"]:nil);
	string option = (string)(options["option"]:nil);
	if (option == nil)
	{
	    // command line error report
	    CommandLine::Print (_("Option was not specified."));
	    return false;
	}
	any value = nil;
	if (section == nil)
	{
	    value = lookup_value (BootCommon::globals, option, nil);
	}
	else
	{
	    integer index = BootCommon::getSectionIndex (section);
	    if (index != nil)
	    {
		value = lookup_value (
		    BootCommon::sections[index]:[], option, nil);
	    }
	}
	if (value == nil)
	    // command line error report
	    CommandLine::Print (_("Specified option does not exist."));
	else
	    // command line, %1 is the value of bootloader option
	    CommandLine::Print (sformat (_("Value: %1"), value));
	return false;
    }

    /* the command line description map */
    map cmdline = $[
	"id"		: "bootloader",
	// command line help text for Printer module
	"help"		: _("Boot loader configuration module"),
	"guihandler"	: GuiHandler,
	"initialize"	: Bootloader::Read,
	"finish"	: Bootloader::Write,
	"actions"	: $[
	    "summary"	: $[
		"handler"	: BootloaderSummaryHandler,
		// command line help text for summary action
		"help"		: _("Configuration summary of boot loader")
	    ],
	    "delete"	: $[
		"handler"	: BootloaderDeleteHandler,
		// command line help text for delete action
		"help"		: _("Delete a global option or option of a section"),
	    ],
	    "set"	: $[
		"handler"	: BootloaderSetHandler,
		// command line help text for set action
		"help"		: _("Set a global option or option of a section"),
	    ],
	    "add"	: $[
		"handler"	: BootloaderAddHandler,
		// command line help text for add action
		"help"		: _("Add a new section"),
	    ],
	    "print"	: $[
		"handler"	: BootloaderPrintHandler,
		// command line help text for print action
		"help"		: _("Print value of specified option"),
	    ],
	],
        "options"	: $[
	    "section"	: $[
		// command line help text for an option
		"help"		: _("The name of the section"),
		"type"		: "string",
            ],
	    "option"	: $[
		// command line help text for an option
		"help"		: _("The key of the option"),
		"type"		: "string",
            ],
	    "value"	: $[
		// command line help text for an option
		"help"		: _("The value of the option"),
		"type"		: "string",
            ],
	],
        "mappings"	: $[
            "summary"		: [],
	    "delete"		: [ "section", "option" ],
	    "set"		: [ "section", "option", "value" ],
	    "add"		: [ "section" ],
	    "print"		: [ "section", "option" ],
	],
    ];

    y2milestone ("Starting bootloader configuration module");
    boolean skip_io = false;
    integer i = 0;
    while (i < size ((list)WFM::Args()))
    {
	if (.noio == WFM::Args (i) || ".noio" == WFM::Args (i))
	{
	    skip_io = true;
	    BootCommon::save_on_finish = false;
	}
	i = i + 1;
    }

    boolean ret = CommandLineRun (cmdline);
//    boolean ret = GuiHandler ();
/*
    Wizard::CreateDialog ();

    if (! skip_io)
    {
// run Progress bar
	list stages = [
	    // progress stage, text in dialog (short, infinitiv)
	    _("Check boot loader"),
	    // progress stage, text in dialog (short, infinitiv)
	    _("Read partitioning"),
	    // progress stage, text in dialog (short, infinitiv)
	    _("Load boot loader settings"),
	];
	list titles = [
	    // progress stage, text in dialog (short)
	    _("Checking boot loader..."),
	    // progress stage, text in dialog (short)
	    _("Reading partitioning..."),
	    // progress stage, text in dialog (short)
	    _("Loading boot loader settings..."),
	];
	// progress bar caption
	Progress::New (_("Initializing boot loader configuration tool..."),
	    " ", 3, stages, titles, getInitProgressHelp ());

	Progress::NextStage ();
	if (testAbort ())
	    return `back;

	Bootloader::getLoaderType ();

	Progress::NextStage ();
	if (testAbort ())
	    return `back;

	BootCommon::DetectDisks ();
	BootCommon::getFloppyDevices ();
        Progress::NextStage ();
        if (testAbort ())
            return `back;

	Bootloader::Read ();
	Progress::Finish ();
	if (testAbort ())
	    return `back;
    }

    symbol ret = Bootloader::runWizard ();

    if (! skip_io)
    {
	if (ret == `next)
	    Bootloader::Write ();
    }
*/
    y2milestone ("Finishing bootloader configuration module");
    return ret;
}
