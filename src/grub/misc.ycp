/**
 * File:
 *      include/bootloader/grub/misc.ycp
 *
 * Module:
 *      Bootloader installation and configuration
 *
 * Summary:
 *      Miscelaneous functions for configuring and installing GRUB bootloader
 *
 * Authors:
 *      Jiri Srain <jsrain@suse.cz>
 *
 * $Id$
 *
 */

{
    textdomain "bootloader";
    import "Storage";

    /**
      * Read GRUB device maping from /boot/grub/device.map file
      * @return list of lists like
      * [["(hd0)", "/dev/hda"], ["(fd0)", "/dev/fd0"]]
      */
    global define list readDeviceMap () ``{
	string s_map = SCR::Read (.target.string, "/boot/grub/device.map");
	list devmap = string2devMap (s_map);
	y2milestone ("Read device map: %1", devmap);
	return devmap;
    }

    /**
      * generate string from device map list
      * @param devmap list device map
      * @return string device map as string to save to file
      */
    global define string devMap2string (list devmap) ``{
        string res = "";
        foreach (`m, devmap, ``{
            res = res + m[0]:"" + "\t" + m[1]:"" + "\n";
        });
	return res;
    }

    /**
      * parse device map string to device-map list
      * @param s_map string device map as string read from file
      * @return list device map
      */
    global define list string2devMap (string s_map) ``{
        list lines = splitstring (s_map, "\n");
        lines = filter (`l, lines, ``(l != ""));
        list devmap = maplist (`l, lines, ``(splitstring (l, " \t")));
        devmap = maplist (`l, devmap, ``(filter (`e, l, ``(e != ""))));
	return devmap;
    }

    /**
      * Save GRUB device map to file readable for GRUB
      * @param devmap list device map the same way as read with readDeviceMap
      * @return boolean true on success
      */
    global define boolean saveDeviceMap (list devmap) ``{
	string res = devMap2string (devmap);
	return SCR::Write (.target.string, "/boot/grub/device.map", res);
    }

    /**
      * Generate device map proposal
      * @return list generated device map
      */
    global define list proposeDeviceMap () ``{
	map ids = $[];
	list mapping = [];
        map targetMap = Storage::GetTargetMap();
	// add devices with know bios_id
        foreach (`target_dev, `target, targetMap, ``{
            string bios_id = target["bios_id"]:"";
            if (bios_id != "")
            {
		integer index = tointeger (bios_id) - tointeger ("0x80");
                string grub_dev = sformat ("(hd%1)", index);
                mapping = add (mapping, [grub_dev, target_dev]);
		ids[index] = true;
            }
        });
	// and guess other devices
	foreach (`target_dev, `target, targetMap, ``{
            string bios_id = target["bios_id"]:"";
            if (bios_id == "")
            {
		integer index = 0;
		while (ids[index]:false)
		    index = index + 1;
                string grub_dev = sformat ("(hd%1)", index);
                mapping = add (mapping, [grub_dev, target_dev]);
		ids[index] = true;
            }
        });
	if (StorageDevices::FloppyPresent)
	{
	    mapping = add (mapping, ["(fd0)", StorageDevices::FloppyDevice]);
	}
	y2milestone ("Detected device mapping: %1", mapping);
	return mapping;
    }

    /**
     * translate UNIX device /dev/hda to grub device (hd0)
     * @param o_dev string UNIX device
     * @return string grub device
     */
    global define string unixDev2grubDev (string o_dev) ``{
        integer i = 0;
        map p_dev = Storage::GetDiskPartition (o_dev);
        any num = p_dev["nr"]:0;
        o_dev = p_dev["disk"]:"";
        if (findlastof (o_dev, "/") == nil)
            o_dev = o_dev + "/dev/";
	string dev =
	    select (
		select (
		    filter (`l, device_map, ``(l[1]:"" == o_dev)), 0, []
		), 0, ""
	    );
	if (dev == "")
	    dev = "(null)";
        else if (num != 0 && num != "")
        {
            num = num - 1;
            string number = sformat ("%1", num);
            dev = substring (dev, 0, size (dev) - 1) + "," + number + ")";
        }
        return dev;
    }

    /**
      * translate grub device (hd0) to UNIX device /dev/hda
      * @param o_dev string grub device
      * @return string UNIX device
      */
    global define string grubDev2unixDev (string o_dev) ``{
	string number = "";
	if (o_dev == nil)
	    return o_dev;
	if (findfirstof (o_dev, ",") != nil)
	{
	    number = substring (o_dev, (findfirstof (o_dev, ",") + 1));
	    number = substring (number, 0, (size (number) - 1));
	    o_dev = substring (o_dev, 0, findfirstof (o_dev, ",")) + ")";
	}
        string dev =
            select (
                select (
                    filter (`l, device_map, ``(l[0]:"" == o_dev)), 0, []
                ), 1, ""
            );
	if (dev == "")
	    dev = "/dev/null";
	else if (number != "")
	{
	    integer num = tointeger (number);
	    num = num + 1;
	    dev = Storage::GetDeviceName (dev, num);
	}
	return dev;
    }

    /**
      * translate filename path (eg. (hd0,0)/kernel) to list of device
      *  and relative path
      * @param pth string fileststem path (eg. (hd0,0)/vmlinuz)
      * @return list containing device and relative path,
      *  eg. ["(hd0,0)", "/vmlinuz"]
      */
    global define list splitDevPath (string devpth) ``{
	integer brake = findfirstof (devpth, ")") + 1;
	list ret = [];
	if (brake != nil)
	{
	    ret[0] = substring (devpth, 0, brake);
	    ret[1] = substring (devpth, brake);
	}
	else
	{
	    ret[0] = nil;
	    ret[1] = devpth;
	}
        return ret;
    }

    /**
      * translate list of device and relative path
      *  to filename path (eg. (hd0,0)/kernel)
      * @param devpth list of two strings, first for device name, second for
      *  relative path (eg. ["(hd0,0)", "/vmlinuz"])
      * @return string fileststem path (eg. (hd0,0)/vmlinuz)
      */
    global define string mergeDevPath (list devpth) ``{
        if (substring (devpth[1]:"", 0, 1) != "/")
            devpth[1] = "/" + devpth[1]:"";
	string ret = devpth[0]:"" + devpth[1]:"";
        return ret;
    }

    /**
      * translate UNIX filename to grub path
      * @param filename string UNIX-style filename (eg. "/boot/vmlinuz")
      * @return string GRUB-like filename (eg. "(hd0,0)/vmlinuz")
      */
    global define string file2grub (string filename) ``{
	list split = BootCommon::splitPath (filename);
	split[0] = unixDev2grubDev (split[0]:"");
	return mergeDevPath (split);
    }

    /**
      * translate grub path to UNIX filename
      * @param grubpath string GRUB-like filename (eg. "(hd0,0)/vmlinux")
      * @return string UNIX-style filename (eg. "/boot/vmlinuz")
      */
    global define string grub2file (string grubpath) ``{
	list split = splitDevPath (grubpath);
	split[0] = grubDev2unixDev (split[0]:"");
	return BootCommon::mergePath (split);
    }

    /**
      * parse /etc/grub file
      * @return map of settings
      */
    global define map readGrubConf () ``{
	return parseGrubConf (SCR::Read (.target.string, "/etc/grub.conf"));
    }

    /**
      * parse /etc/grub file from other file
      * @param filename string name of file
      * @return map of settings
      */
    global define map parseGrubConf (string file) ``{
	if (file == "" || file == nil)
	    return $[];
	list lines = splitstring (file, "\n");
	lines = filter (`l, lines, ``(l != ""));
	map settings = $[];
	string root = "";
	foreach (`l, lines, ``{
	    list entries = splitstring (l, " ");
	    entries = filter (`e, entries, ``(e != ""));
	    if (select (entries, 0, "") == "root")
	        root = select (entries, 1, "");
	    else if (select (entries, 0, "") == "install")
	    {
	        integer shift = 0;
	        string tmp = select (entries, 1 + shift, "");
	        while (substring (tmp, 0, 2) == "--")
	        {
		    string prefix = settings["s2prefix"]:"";
		    prefix = prefix + " " + tmp;
	            settings = add (settings, "s2prefix", prefix);
	            shift = shift + 1;
	            tmp = select (entries, 1 + shift, "");
	        }
	        settings = add (settings, "stage1", tmp);
	        tmp = select (entries, 2 + shift, "");
	        if ("d" == tmp)
	        {
	            settings = add (settings, "discswitch", true);
	            shift = shift + 1;
	            tmp = select (entries, 2 + shift, "");
	        }
	        settings = add (settings, "device", tmp);
	        tmp = select (entries, 3 + shift, "");
	        settings = add (settings, "stage2", tmp);
	        tmp = select (entries, 4 + shift, "");
	        settings = add (settings, "addr", tmp);
	        tmp = select (entries, 5 + shift, "");
	        if (substring (tmp, 0, 1) == "/")
	            tmp = sformat ("%1%2", root, tmp);
	        settings = add (settings, "menu", tmp);
	    }
	    settings = add (settings, "root", root);
	});
	return settings;
    }



    /*e
      * get /etc/grub.conf file from settings as string
      * @param settings map of settings
      * @return string file contents
      */
    global define string getGrubConf (map settings) ``{
	string res = "";
	string root = sformat ("root %1\n", lookup (settings, "root", ""));
	res = sformat (lookup (settings, "discswitch", false)
	    ? "install %6 %1 d %2 %3 %4 %5"
	    : "install %6 %1 %2 %3 %4 %5",
	        lookup (settings, "stage1", ""),
	        lookup (settings, "device", ""),
	        lookup (settings, "stage2", ""),
	        lookup (settings, "addr", ""),
	        lookup (settings, "menu", ""),
		lookup (settings, "s2prefix", ""));
	res = sformat ("%1%2\nquit\n", root, res);
	return res;
    }

    /**
      * save /etc/grub.conf
      * @param settings map settings
      * @return boolean true if success
      */
    global define boolean saveGrubConf (map settings) ``{
	if (settings == $[])
	    return true;
	return SCR::Write (.target.string, "/etc/grub.conf",
	    getGrubConf (settings));
    }

    /**
      * Propose /etc/grub.con
      * @return map grub-conf file
      */
    global define map proposeGrubConf () ``{
	list(string) stage1 = splitDevPath (file2grub ("/boot/grub/stage1"));
	list(string) stage2 = splitDevPath (file2grub ("/boot/grub/stage2"));
	return $[
	    "discswitch" : true,
	    "root" : stage1[0]:"",
	    "stage1" : stage1[1]:"",
	    "device" : unixDev2grubDev(BootCommon::loader_device),
	    "stage2" : stage2[1]:"",
	    "addr" : "0x8000",
	    "menu" : file2grub ("/boot/grub/menu.lst"),
	    "s2prefix" : "--stage2=/boot/grub/stage2",
	];
    }

    /**
      * Remaps values of map src according to mapping
      * @param src map source map
      * @param mapping map mapping description
      * @return map modified map
      */
    global define map remapDisks (map src, map mapping) ``{
	foreach (`k, `v, mapping, ``{
	   mapping = add (mapping, substring (k, 0, size (k) - 1) + ",",
				substring (v, 0, size (v) - 1) + ",");

	});
	map m1 = $[];
	map m2 = $[];
	integer counter = 0;
	foreach (`k, `v, mapping, ``{
	    string scounter = sformat ("\\*\\*\\*\n%1\n*\\*\\*\\", counter);
	    m1[k] = scounter;
	    m2[scounter] = v;
	    counter = counter + 1;
	});

	map ret = mapmap (`k, `v, src, ``{
	    if (is (v, string))
	    {
		foreach (`s, `d, m1, ``{
		    v = BootCommon::replaceAll (v, s, d);
		});
		foreach (`s, `d, m2, ``{
		    v = BootCommon::replaceAll (v, s, d);
		});
	    }
	    return [k, v];
	});
	return ret;
    }




}
