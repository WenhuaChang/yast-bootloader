/**
 * File:
 *      include/bootloader/grub/widgets.ycp
 *
 * Module:
 *      Bootloader installation and configuration
 *
 * Summary:
 *      Widgets specific for GRUB bootloader
 *
 * Authors:
 *      Jiri Srain <jsrain@suse.cz>
 *
 * $Id$
 *
 */


{

    import "BootCommon";
    include "ui/common_messages.ycp";
    include "bootloader/routines/popups.ycp";
    include "bootloader/grub/helps.ycp";

    textdomain "bootloader";

    /**
      * Get map of dialogs and widgets
      * @return map of dialogs and widgets
      */
    global define map GetWidgets () ``{
        return $[
	    "sections" : ``(BootGRUB::getSectionsWidget ()),
	    "singlesection" : ``(BootGRUB::getSingleSectionWidget ()),
	    "globalsection" : ``(BootGRUB::getGlobalSectionWidget ()),
	    "passwd" : ``(BootGRUB::getPasswdWidget ()),
	    "tableentries" :$[
		"__location": ``(BootGRUB::getTargetWidget ()),
		"__sections" : ``(BootGRUB::getSectionsTableEntry ()),
		"__default_section" : ``(BootGRUB::getDefaultSectionTableEntry ()),
		"__section_type" : ``(BootGRUB::getSectionTypeWidget ()),
		"title" : ``(BootGRUB::getTitleWidget ()),
		"timeout" : ``(BootGRUB::getTimeoutWidget ()),
		"password" : ``(BootGRUB::getPasswdWidget ()),
		"gfxmenu" : ``(BootGRUB::getGfxMenuWidget ()),
		"__diskorder" : ``(BootGRUB::getOrderPopup ()),
	    ],
        ];
    }

    /**
      * Get map of Target widget
      * @return map of Target widget
      */
    global define map getTargetWidget () ``{
	map ret = BootCommon::getTargetWidget ();
	ret["handle"] = ``(BootGRUB::targetWrite ());
	return ret;
    }

    /**
      * Ask how to chang section floppy <-> hard disk when changing bootloader
      * location between disk and floppy
      * @param to string new bootloader location ("floppy" or "hard disk")
      * @return boolean true if user wants to change the section
      */
    global define boolean changeSection (string to) ``{
	string message = "";
	if (to == "floppy")
		// yes-no popup
	    message = _("You chose to install the boot loader to the floppy.
The menu of the boot loader contains an entry to boot from the floppy.
Replace it with an entry to boot from the hard disk?");
	else
		// yes-no popup
	    message = _("You chose to install the boot loader to the hard disk.
The menu of the boot loader contains an entry to boot from the hard disk.
Replace it with an entry  to boot from the floppy?");
	return UI::YesNoPopup (message);
    }

    /**
      * Handle function of widget
      * @param op any operation to handle
      * @param tosave list of operations, which lead to closing & saving widget
      * @return any changed op (if needed)
      */
    global define any targetWrite (any op, list tosave) ``{
	any ret = BootCommon::targetWrite (op, tosave);
	if (contains (tosave, op))
	{
//	    y2error ("SEC: %1", BootCommon::sections);
//	    list sections = BootCommon::sections;
	    list sections = BootCommon::tmp_store["sections"]:[];
//	    y2milestone ("Possibly needed to change the floppy bl entry");
	    if (issubstring (BootCommon::loader_device, "/dev/fd")||
		BootCommon::location == "floppy")
	    {
//		y2milestone ("BL saving to floppy");
		sections = maplist (`s, sections, ``{
		    if (s["title"]:"" == "floppy" && changeSection ("floppy"))
		    {
//			y2milestone ("Floppy found");
			s = $[
			    "__order__" : ["title", "root", "chainloader"],
			    "title" : "hard disk",
			    "root" : "(hd0)",
			    "chainloader" : "+1",
	                    "__intern__" : $[
		                "changed" : false,
		                "auto" : true,
		                "devs" : [],
		            ],
			];
		    }
		    return s;
		});
	    }
	    else
	    {
//		y2milestone ("BL saving to disk");
		sections = maplist (`s, sections, ``{
		    if (s["title"]:"" == "hard disk"
			&& changeSection ("disk"))
		    {
//			y2milestone ("Disk found");
			s = $[
			    "__order__" : ["title", "root", "chainloader"],
			    "title" : "floppy",
			    "root" : "(fd0)",
			    "chainloader" : "+1",
                            "__intern__" : $[
                                "changed" : false,
                                "auto" : true,
                                "devs" : [],
                            ],
			];
		    }
		    return s;
		});
	    }
//	    BootCommon::sections = sections;
	    BootCommon::tmp_store["sections"] = sections;
//	    y2error ("SEC: %1", BootCommon::sections);
	}
	return ret;
    }


    /**
      * Update list of optoins to show in table
      * @param options map of options including order
      * @return list of option to show
      */
    global define list UpdateOptionsList (map options) ``{
	any type = BootCommon::tmp_store["section_type"]:"";
	list _options = [];
	if (type == `global)
	{
            options = filter (`o, `v, options,
		``(o != "boot" && o != "default"));
            options = filter (`o, `v, options, ``(o != "loader_type"
                && o != "location" && o != "default_section" && o != "sections"
                && o != `repl_mbr && o != "activate" && o != `diskorder
            ));

            list done = [];
            map cont = $[];
            list order = options["__order__"]:[];
            foreach (`o, order, ``{
                if (haskey (options, o))
                {
                    done = add (done, o);
                    cont = add (cont, o, "");
                }
            });
            foreach (`k, `v, options, ``{
                if (! haskey (cont, k))
                {
                    done = add (done, k);
                    cont = add (cont, k, "");
                }
            });
            _options = done;

            _options = prepend (_options, "__sep1");
            _options = prepend (_options, "__repl_mbr");
            _options = prepend (_options, "activate");
            _options = prepend (_options, "__sections");
            _options = prepend (_options, "__default_section");
	    _options = prepend (_options, "__diskorder");
            _options = prepend (_options, "__location");
            _options = prepend (_options, "__sep2");
            _options = prepend (_options, "__loader_type");
	}
	else
	{
	    options = filter (`k, `v, options, ``(k != "type" && k != "title"));
	    list done = [];
	    map cont = $[];
	    list order = options["__order__"]:[];
	    foreach (`o, order, ``{
		if (haskey (options, o))
		{
		    done = add (done, o);
		    cont = add (cont, o, "");
		}
	    });
	    foreach (`k, `v, options, ``{
		if (! haskey (cont, k))
		{
		    done = add (done, k);
		    cont = add (cont, k, "");
		}
	    });
	    _options = done;

	    _options = prepend (_options, "__sep1");
	    _options = prepend (_options, "__section_type");
	    _options = prepend (_options, "title");
	}
	return _options;
    }

    /**
      * Get map of widget
      * @return map of widget
      */
    global define map getSectionsWidget () ``{
	map ret = BootCommon::getSectionsWidget ();
	ret["restore"] = ``(BootGRUB::sectionsRead ());
	ret["handle"] = ``(BootGRUB::sectionsHandle ());
	return ret;
    }

    /**
      * Redraw table of sections
      * @param sects list of sections
      */
    global define void sectionsRedrawTable (list sects) ``{
	integer order = -1;
	list sec = maplist (map s, sects, ``{
	    order = order + 1;
	    string other_dev = s["root"]:s["rootnoverify"]:"";
	    string kernel_img = s["kernel"]:"";
	    kernel_img = select (filter (`p, splitstring (kernel_img, " "),
		``(p != "")
	    ), 0, "");
	    string root = BootCommon::getKernelParamFromLine
		(s["kernel"]:"", "root");
	    if (root != "" && root != "false")
		root = sformat (", root=%1", root);
	    else
		root = "";
	    if (substring (kernel_img, 0, 1) != "(")
		kernel_img = other_dev + kernel_img;
	    return `item (`id (s["title"]:""),
		BootCommon::tmp_store["globals", "default"]:0 == order
		    ? UI::Glyph (`CheckMark) : "",
		s["title"]:"",
		// table cell
		s["kernel"]:"" == "" ? _("other")
			// table cell
		    : _("image"),
		s["kernel"]:"" != ""
		? sformat ("%1   (%2%3)",
		    kernel_img,
		    BootGRUB::grubDev2unixDev (
			select (BootGRUB::splitDevPath (kernel_img), 0, "")
		    ),
		    root
		)
		: sformat ("%1   (%2)", other_dev,
		    BootGRUB::grubDev2unixDev (other_dev))
	    );

	});
	UI::ChangeWidget (`id (`sects), `Items, sec);
    }

    /**
      * Assign default section
      * @param title string title of section to become default
      */
    global define void sectionsAssignDefault (string title) ``{
	integer index = 0;
	integer counter = 0;
	foreach (`s, BootCommon::tmp_store["sections"]:[], ``{
	    if (s["title"]:"" == title)
		index = counter;
	    counter = counter + 1;
	});
	BootCommon::tmp_store["globals", "default"] = index;
    }

    /**
      * Read function of a widget
      */
    global define void sectionsRead () ``{
	sectionsRedrawTable (BootCommon::tmp_store["sections"]:[]);
	UI::SetFocus (`id (`sects));
    }

    /**
      * Handle function of widget
      * @param op any operation to handle
      * @param tosave list of operations, which lead to closing & saving widget
      * @return any changed op (if needed)
      */
    global define any sectionsHandle (any op, list tosave) ``{
        string current = UI::QueryWidget (`id (`sects), `CurrentItem);
        integer counter = 0;
        integer index = 0;
	integer default = BootCommon::tmp_store["globals", "default"]:0;
	string default_title //= _sect["title"]:"";
	    = BootCommon::tmp_store["sections", default, "title"]:"";
        foreach (`s, BootCommon::tmp_store["sections"]:[], ``{
            if (s["title"]:"" == current)
                index = counter;
            counter = counter + 1;
        });
        list sects = BootCommon::tmp_store["sections"]:[];
        if (op == `up)
        {
            if (index > 0)
            {
                sects = BootCommon::swapItems(sects, index, index - 1);
                index = index - 1;
                BootCommon::tmp_store["sections"] = sects;
		sectionsAssignDefault (default_title);
                sectionsRedrawTable (sects);
                UI::ChangeWidget (`id (`sects), `CurrentItem,
                    sects[index, "title"]:0);
            }
        }
        else if (op == `down)
        {
            if (index < (size(sects) - 1))
            {
                sects = BootCommon::swapItems(sects, index, index + 1);
                index = index + 1;
                BootCommon::tmp_store["sections"] = sects;
		sectionsAssignDefault (default_title);
                sectionsRedrawTable (sects);
                UI::ChangeWidget (`id (`sects), `CurrentItem,
                    sects[index, "title"]:0);
            }
        }
	else if (op == `default)
	{
	    BootCommon::tmp_store["globals", "default"] = index;
	    sectionsRedrawTable (sects);
	    UI::ChangeWidget (`id (`sects), `CurrentItem,
		sects[index, "title"]:0);
	}
	else if (op == `add)
	{
            BootCommon::tmp_store["active_section"] = $[];
            BootCommon::tmp_store["active_section_name"] = "";
            BootCommon::tmp_store["section_type"] = "image";
	}
	else if (op == `edit)
	{
            y2milestone ("Editing title %1, index %2", current, index);
            BootCommon::tmp_store["active_section"] = eval (sects[index]:$[]);
            BootCommon::tmp_store["active_section_name"]
                = sects[index, "title"]:"";
            BootCommon::tmp_store["section_type"]
                = sects[index, "kernel"]:"" == "" ? "other" : "image";

            BootCommon::tmp_store["changed_single_sect"]
                = eval (BootCommon::changed_settings[sects[index, "title"]:""]:$[]);
            y2milestone ("Changed settings: %1", BootCommon::tmp_store["changed_single_sect"]:$[]);
	}
	else if (op == `delete && confirmSectionDeletePopup (current))
	{
	    sects = remove (sects, index);
	    BootCommon::tmp_store["sections"] = sects;
	    if (size (sects) <= BootCommon::tmp_store["globals", "default"]:0)
		BootCommon::tmp_store["globals", "default"] = 0;
	    sectionsRedrawTable (sects);
	}
        if (contains (tosave, op) && op != `edit && op != `add)
        {
            BootCommon::markOptionChanged (`global, "__sections");
            BootCommon::markOptionChanged (`global, "__default_section");
        }
        if (op == `back)
        {
            BootCommon::changed_settings
                = eval (BootCommon::tmp_store["changed_all_sects"]:$[]);
            y2milestone ("Restoring changed to %1", BootCommon::changed_settings);
        }
	UI::SetFocus (`id (`sects));
    }

// password widge

    /**
      * Get map of widget
      * @return map of widget
      */
    global define map getPasswdWidget () ``{
	map ret = BootCommon::getPasswdWidget ();
	ret["handle"] = ``(BootGRUB::handlePasswdWidget ());
	return ret;
    }

    /**
      * Handle function of widget
      * @param op any operation to handle
      * @param tosave list of operations, which lead to closing & saving widget
      * @return any changed op (if needed)
      */
    global define any handlePasswdWidget (any op, list tosave) ``{
	if (! contains (tosave, op))
	    return BootCommon::handlePasswdWidget (op, tosave);


        boolean usepass = UI::QueryWidget (`id (`usepas), `Value);
        y2milestone ("Usepass: %1", usepass);
        if (usepass)
        {
	    if (UI::QueryWidget (`id (`pw1), `Value) != "**********")
	    {
	        string ps = UI::QueryWidget (`id (`pw1), `Value);
	        ps = sformat ("--md5 %1", cryptmd5 (ps));
	        BootCommon::tmp_store["active_section", "password"] = ps;
	    }
	}
        else
        {
            BootCommon::tmp_store["active_section"]
                = remove (BootCommon::tmp_store["active_section"]:$[],
		    "password");
        }
	return op;
    }



// grub-specific dialogs

    /**
      * Get map of widget
      * @return map of widget
      */
    global define map getOrderPopup () ``{
	return $[
	    "widget" : `HBox (
                `VBox (
                    `ReplacePoint (`id (`disks_rp),
                        `SelectionBox (`id (`disks),
                            `opt (`notify, `immediate),
			    // selectionn box label
                            _("D&isks"), [])
                    ),
		    `HBox (
			`HStretch (),
			`PushButton (`id (`add), `opt (`key_F3), AddButtonLabel ()),
			`PushButton (`id (`delete), `opt(`key_F5), DeleteButtonLabel ()),
			`HStretch ()
		    )
                ),
                `HSquash (
                    `VBox (
                        `VStretch (),
                        `PushButton (`id (`up), `opt (`hstretch), _("&Up")),
                        `PushButton (`id (`down), `opt (`hstretch), _("&Down")),
                        `VStretch ()
                    )
                )
	    ),
	    "restore" : ``(BootGRUB::restoreOrderPopup ()),
	    "handle" : ``(BootGRUB::handleOrderPopup ()),
	    "summary" : ``(BootGRUB::orderSummary ()),
		// label / table cell
	    "label" : _("Disk Order"),
	    "deletable" : false,
	    "help" : getDiskOrderHelp (),
	];
    }

    /**
      * get current order of disks from device map
      * @return a list of disks as string
      */
    global define list(string) getDisksOrder () ``{
        list(list(string)) dl = filter (list(string) i, device_map,
            ``(substring (i[0]:"", 0, 3) == "(hd"));
        dl = sort (list(string) a, list(string) b, dl, ``(a[0]:"" < b[0]:""));
        return maplist (list(string) i, dl, ``{return i[1]:"";});

    }

    /**
      * Summary function for option
      * @return string summary text
      */
    global define string orderSummary () ``{
//	if (disks_order == nil)
	    disks_order = getDisksOrder ();
	return mergestring (disks_order, ", ");
    }

    /**
      * Restore function of widget
      */
    global define void restoreOrderPopup () ``{
//        if (disks_order == nil)
            disks_order = getDisksOrder ();

	UI::ReplaceWidget (`id (`disks_rp), `SelectionBox(`id (`disks),
                    `opt (`notify, `immediate),
                    _("D&isks"), disks_order));
	UI::ChangeWidget (`id (`disks), `CurrentItem, disks_order[0]:"");
	handleOrderPopup (nil, []);
    }

    /**
      * Handle function of widget
      * @param op any operation to handle
      * @param tosave list of operations, which lead to closing & saving widget
      * @return any changed op (if needed)
      */
    global define any handleOrderPopup (any op, list tosave) ``{
	string active = UI::QueryWidget (`id (`disks), `CurrentItem);
	integer pos = 0;
	while (pos < size (disks_order) && disks_order[pos]:"" != active)
	    pos = pos + 1;
	UI::ChangeWidget (`id (`up), `Enabled, pos > 0);
	UI::ChangeWidget (`id (`down), `Enabled, pos < size (disks_order) - 1);
	if (! contains (tosave, op))
	{
	    if (op == `up)
	    {
		disks_order = BootCommon::swapItems (disks_order, pos, pos - 1);
		UI::ReplaceWidget (`id (`disks_rp), `SelectionBox(`id (`disks),
		    `opt (`notify, `immediate),
		    _("D&isks"), disks_order));
		UI::ChangeWidget (`id (`disks), `CurrentItem, active);
	    }
	    else if (op == `down)
	    {
		disks_order = BootCommon::swapItems (disks_order, pos, pos + 1);
		UI::ReplaceWidget (`id (`disks_rp), `SelectionBox(`id (`disks),
		    `opt (`notify, `immediate),
		    _("D&isks"), disks_order));
		UI::ChangeWidget (`id (`disks), `CurrentItem, active);
	    }
	    else if (op == `add)
	    {
		term popup = `VBox (`VSpacing (1),
		    // textentry header
		    `TextEntry (`id (`devname), _("&Device")),
		    `VSpacing (1),
		    `HBox (`HStretch (),
			`PushButton (`id (`ok), `opt (`key_F10, `default), OKButtonLabel ()),
			`HStretch (),
			`PushButton (`id (`cancel), `opt (`key_F8), CancelButtonLabel ()),
			`HStretch ()
		    ),
		    `VSpacing (1)
		);
		UI::OpenDialog (popup);
		symbol pushed = UI::UserInput ();
		string new_dev = UI::QueryWidget (`id (`devname), `Value);
		UI::CloseDialog ();
		if (pushed == `ok)
		{
		    disks_order = add (disks_order, new_dev);
		    UI::ReplaceWidget (`id (`disks_rp), `SelectionBox(`id (`disks),
	                `opt (`notify, `immediate),
	                _("D&isks"), disks_order));
		// FIXME TODO
		}
	    }
	    else if (op == `delete)
	    {
		disks_order = filter (`i, disks_order, ``(i != active));
		UI::ReplaceWidget (`id (`disks_rp), `SelectionBox(`id (`disks),
                    `opt (`notify, `immediate),
                    _("D&isks"), disks_order));
		UI::ChangeWidget (`id (`delete), `Enabled, size (disks_order) > 0);
		UI::ChangeWidget (`id (`disks),`CurrentItem, disks_order[0]:"");
	    }

	}
	else
	{

            list(list(string)) dl = filter (list(string) i, device_map,
                ``(substring (i[0]:"", 0, 3) == "(hd"));
            dl=sort (list(string) a, list(string) b, dl, ``(a[0]:"" < b[0]:""));

	    map olddiskmap = $[];
	    foreach (list(string) d, dl, ``{
		olddiskmap[d[1]:""] = d[0]:"";
	    });
	    map remap = $[];
	    integer pos = 0;
	    list new_map = filter (list(string) i, device_map,
		``(substring (i[0]:"", 0, 3) != "(hd"));
	    foreach (`d, disks_order, ``{
		string gd = sformat ("(hd%1)", pos);
		if (gd != olddiskmap[d]:"")
		{
		    remap[olddiskmap[d]:""] = gd;
		}
		new_map = add (new_map, [gd, d]);
		pos = pos + 1;
	    });
	    map glob = BootCommon::tmp_store["globals"]:$[];
	    glob = BootGRUB::remapDisks (glob, remap);
	    BootCommon::tmp_store["globals"] = glob;
	    list sects = BootCommon::tmp_store["sections"]:[];
	    sects = maplist (`s, sects, ``{
		return BootGRUB::remapDisks (s, remap);
	    });
	    BootCommon::tmp_store["sections"] = sects;
	    BootCommon::tmp_store["active_section"] = BootGRUB::remapDisks (
		BootCommon::tmp_store["active_section"]:$[], remap);
	    BootGRUB::grub_conf
		= BootGRUB::remapDisks (BootGRUB::grub_conf, remap);
	    BootGRUB::device_map = new_map;
	    BootCommon::mbrDisk = disks_order[0]:BootCommon::mbrDisk;
	    BootCommon::loader_device = BootCommon::GetBootloaderDevice ();
	    disks_order = nil;
	}
	UI::SetFocus (`id (`disks));
	return op;
    }

    /**
      * Get map of widget
      * @return map of widget
      */
    global define map getSectionsTableEntry () ``{
	map ret = BootCommon::getSectionsTableEntry ();
	ret["summary"] = ``(BootGRUB::getSectionsSummary ());
	return ret;
    }

    /**
      * Summary function for option
      * @return string summary text
      */
    global define string getSectionsSummary () ``{
        integer default = BootCommon::globals["default"]:0;
        list sects = [];
	integer counter = 0;
        foreach (`s, BootCommon::sections, ``{
            string title = s["title"]:"";
            string def = counter == default ? _(" (default)") : "";
	    counter = counter + 1;
            sects = add (sects, sformat ("%1%2", title, def));
        });
        return mergestring (sects, ", ");
    }


    /**
      * Get map of widget
      * @return map of widget
      */
    global define map getDefaultSectionTableEntry () ``{
	map ret = BootCommon::getDefaultSectionTableEntry ();
	ret["summary"] = ``(BootGRUB::getDefaultSectionSummary ());
	return ret;
    }

    /**
      * Summary function for option
      * @return string summary text
      */
    global define string getDefaultSectionSummary () ``{
        return BootCommon::sections[
	    BootCommon::globals["default"]:0, "title"]:"";
    }


    /**
      * Get map of widget
      * @return map of widget
      */
    global define map getSectionTypeWidget () ``{
	map ret = BootCommon::getSectionTypeWidget ();
	ret["handle"] = ``(BootGRUB::sectionTypeSave ());
	return ret;
    }


    /**
      * Handle function of widget
      * @param op any operation to handle
      * @param tosave list of operations, which lead to closing & saving widget
      * @return any changed op (if needed)
      */
    global define any sectionTypeSave (any op, list tosave) ``{
        string ntype = UI::QueryWidget (`id (`section_type), `Value);
	y2milestone ("New type: %1", ntype);
        string otype = BootCommon::tmp_store["active_section","kernel"]:"" == ""
            ? "other"
            : "image";
        if (otype == ntype)
            return;
        string label = BootCommon::tmp_store["active_section", "title"]:"";
        if (ntype == "other")
        {
            map tmp = BootCommon::tmp_store["active_section"]:$[];
	    string root = select (splitDevPath (
		tmp["kernel"]:""), 0,"");
	    root = tmp["root"]:root;
	    if (root == nil)
		root = "";
            BootCommon::tmp_store["active_section"] = $[
		"root": root,
		"chainloader" : "+1",
		"__order__" : ["root", "chainloader"],
	    ];
        }
        else
        {
            map tmp = BootCommon::tmp_store["active_section"]:$[];
            BootCommon::tmp_store["active_section"] = $[
		"root" : tmp["root"]:"",
		"kernel" : sformat ("/vmlinuz root=%1",
		    grubDev2unixDev (tmp["root"]:"")),
		"__order__" : ["root", "kernel"],
            ];
        }
        BootCommon::tmp_store["active_section", "title"] = label;
	BootCommon::tmp_store["section_type"] = ntype;
	y2milestone ("FS: %1", BootCommon::tmp_store["active_section"]:$[]);
	return op;
    }


    /**
      * Get map of widget
      * @return map of widget
      */
    global define map getTimeoutWidget () ``{
        return $[
            "restore" : ``(BootGRUB::timeoutRestore ()),
            "handle" : ``(BootGRUB::timeoutSave ()),
            "summary" : ``(BootGRUB::timeoutSummary ()),
        ];
    }

    /**
      * Restore function of widget
      */
    global define void timeoutRestore () ``{
        integer timeout = BootCommon::tmp_store["active_section", "timeout"]:0;
        UI::ChangeWidget (`id (`value), `Value, timeout);
    }

    /**
      * Handle function of widget
      * @param op any operation to handle
      * @param tosave list of operations, which lead to closing & saving widget
      * @return any changed op (if needed)
      */
    global define any timeoutSave (any op, list tosave) ``{
        integer timeout = UI::QueryWidget (`id (`value), `Value);
        BootCommon::tmp_store["active_section", "timeout"] = timeout;
	return op;
    }

    /**
      * Summary function for option
      * @return string summary text
      */
    global define string timeoutSummary () ``{
        integer timeout = BootCommon::tmp_store["active_section", "timeout"]:0;
	// table cell, means eg. 5 s (like 5 seconds)
        return sformat (_("%1 s"), timeout);
    }

    /**
      * Get map of widget
      * @return map of widget
      */
    global define map getTitleWidget () ``{
	map ret = BootCommon::getLabelWidget ();
	ret["validate"] = ``(BootGRUB::titleValidate ());
	return ret;
    }

    /**
      * Validate function of widget
      * @return true if ok
      */
    global define boolean titleValidate () ``{
        list(string) existing = [];
        foreach (`s, BootCommon::tmp_store["sections"]:[], ``{
            existing = add (existing, s["title"]:"");
        });
	y2milestone ("Active is %1", BootCommon::tmp_store["active_section_name"]:"");
        existing = filter (string l, existing,
            ``(l != BootCommon::tmp_store["active_section_name"]:""));
        existing = add (existing, "");
        string new = UI::QueryWidget (`id (`value), `Value);

        if (contains (existing, new))
        {
            usedNameErrorPopup ();
            return false;
        }
        return true;
    }

    /**
      * Get map of widget
      * @return map of widget
      */
    global define map getGfxMenuWidget () ``{
	return $[
	    "handle" : ``(BootGRUB::gfxMenuHandle ()),
	    "delete" : ``(BootCommon::deleteMessage ()),
	];
    }

    /**
      * Handle function of widget
      * @param op any operation to handle
      * @param tosave list of operations, which lead to closing & saving widget
      */
    global define void gfxMenuHandle (any op, list tosave) ``{
	if (! contains (tosave, op))
	    return;
	BootCommon::tmp_store["active_section", "gfxmenu"]
	    = UI::QueryWidget (`id (`value), `Value);
	BootCommon::tmp_store["active_section", "__intern__"] =
	   add (BootCommon::tmp_store["active_section", "__intern__"]:$[],
		"changed", true);
    }

    /**
      * Get map of widget
      * @return map of widget
      */
    global define map getSingleSectionWidget () ``{
	map ret = BootCommon::getSingleSectionWidget ();
        ret["widget"] = `HBox (ret["widget"]:`VSpacing (0),
            `VBox (
                `VStretch (),
                `PushButton (`id (`up), _("&Up")),
                `PushButton (`id (`down), _("&Down")),
                `VStretch ()
            ),
            `HSpacing (1)
        );
	return ret;
    }

    /**
      * Get map of widget
      * @return map of widget
      */
    global define map getGlobalSectionWidget () ``{
	list items = [
		// menubutton item
            `item (`id (`propose), _("&Propose New Configuration")),
		// menubutton item
            `item (`id (`scratch), _("&Start from Scratch")),
	];
	if (Mode::normal || Mode::config)
	    items = add (items,
		// menubutton item
		`item (`id (`reread), _("&Reread Configuration from Disk")));
	items = add (items, `item (`id (`propose_deep),
		// menubutton item
		_("Propose and &Merge with Existing GRUB Menus")));
	map ret = BootCommon::getGlobalSectionWidget ();
	ret["widget"] = (`HBox (`HSpacing (2), `VBox (
                    `Table (`id (`settings), `opt (`immediate, `notify, `keepSorting),
			// table header
                        `header (_("Ch."),
			// table header
			_("Option"),
			// table header
			_("Value")), []),
                    `HBox (
                        `PushButton (`id (`add), `opt (`key_F3), AddButtonLabel ()),
                        `PushButton (`id (`edit), `opt (`key_F4), EditButtonLabel ()),
                        `PushButton (`id (`delete), `opt (`key_F5), DeleteButtonLabel ()),
                        `HStretch (),
			// menubutton
			`MenuButton (`id (`restore), _("Res&et"), items)
                    )
                ), `HSpacing (2)));
	term widget = ret["widget"]:nil;
	term buttons = `HBox (
	    `PushButton (`id (`add), `opt (`key_F3), AddButtonLabel ()),
	    `PushButton (`id (`edit), `opt (`key_F4), EditButtonLabel ()),
	    `PushButton (`id (`delete), `opt (`key_F5), DeleteButtonLabel ()),
	    `HStretch ()
	);
	return ret;
    }
}
