/**
 * File:
 *      include/bootloader/grub/widgets.ycp
 *
 * Module:
 *      Bootloader installation and configuration
 *
 * Summary:
 *      Widgets specific for GRUB bootloader
 *
 * Authors:
 *      Jiri Srain <jsrain@suse.cz>
 *
 * $Id$
 *
 */


{

    import "BootCommon";
    include "ui/common_messages.ycp";
    include "bootloader/routines/popups.ycp";
    include "bootloader/grub/helps.ycp";

    textdomain "bootloader";

    /**
      * Get map of dialogs and widgets
      * @return map of dialogs and widgets
      */
    global define map GetWidgets () ``{
        return $[
	    "sections" : ``(BootGRUB::getSectionsWidget ()),
	    "singlesection" : ``(BootGRUB::getSingleSectionWidget ()),
	    "globalsection" : ``(BootGRUB::getGlobalSectionWidget ()),
	    "tableentries" :$[
		"__location": ``(BootGRUB::getTargetWidget ()),
		"title" : ``(BootCommon::getLabelWidget ()),
		"gfxmenu" : ``(BootGRUB::getGfxMenuWidget ()),
		"__diskorder" : ``(BootGRUB::getOrderPopup ()),
	    ],
        ];
    }

    /**
      * Get map of Target widget
      * @return map of Target widget
      */
    global define map getTargetWidget () ``{
	map ret = BootCommon::getTargetWidget ();
	ret["handle"] = ``(BootGRUB::targetWrite ());
	return ret;
    }

    /**
      * Ask how to chang section floppy <-> hard disk when changing bootloader
      * location between disk and floppy
      * @param to string new bootloader location ("floppy" or "hard disk")
      * @return boolean true if user wants to change the section
      */
    global define boolean changeSection (string to) ``{
	string message = "";
	if (to == "floppy")
		// yes-no popup
	    message = _("You chose to install the boot loader to the floppy.
The menu of the boot loader contains an entry to boot from the floppy.
Replace it with an entry to boot from the hard disk?");
	else
		// yes-no popup
	    message = _("You chose to install the boot loader to the hard disk.
The menu of the boot loader contains an entry to boot from the hard disk.
Replace it with an entry  to boot from the floppy?");
	return UI::YesNoPopup (message);
    }

    /**
      * Handle function of widget
      * @param op any operation to handle
      * @param tosave list of operations, which lead to closing & saving widget
      * @return any changed op (if needed)
      */
    global define any targetWrite (any op, list tosave) ``{
	any ret = BootCommon::targetWrite (op, tosave);
	if (contains (tosave, op))
	{
	    list sections = BootCommon::current_sections;
	    if (issubstring (BootCommon::loader_device, "/dev/fd")||
		BootCommon::location == "floppy")
	    {
		sections = maplist (`s, sections, ``{
		    if (s["title"]:"" == "floppy" && changeSection ("floppy"))
		    {
			s = $[
			    "__order__" : ["title", "root", "chainloader"],
			    "title" : "hard disk",
			    "root" : "(hd0)",
			    "chainloader" : "+1",
	                    "__intern__" : $[
		                "changed" : false,
		                "auto" : true,
		                "devs" : [],
		            ],
			];
		    }
		    return s;
		});
	    }
	    else
	    {
		sections = maplist (`s, sections, ``{
		    if (s["title"]:"" == "hard disk"
			&& changeSection ("disk"))
		    {
			s = $[
			    "__order__" : ["title", "root", "chainloader"],
			    "title" : "floppy",
			    "root" : "(fd0)",
			    "chainloader" : "+1",
                            "__intern__" : $[
                                "changed" : false,
                                "auto" : true,
                                "devs" : [],
                            ],
			];
		    }
		    return s;
		});
	    }
	    BootCommon::current_sections = sections;
	}
	return ret;
    }


    /**
      * Update list of optoins to show in table
      * @param options map of options including order
      * @return list of option to show
      */
    global define list UpdateOptionsList (map options) ``{
	any type = BootCommon::getSectionType (BootCommon::current_section);
	list _options = [];
	list prependlist = [];
	if (type == `global)
	{
	    prependlist = ["__loader_type", "__sep2", "__location",
		"__diskorder", "__default_section", "__sections", "activate",
		"__repl_mbr", "__save_method", "__sep1"];
            options = filter (`o, `v, options,
		``(o != "boot" && o != "default"));

            list done = [];
            map cont = $[];
            list order = options["__order__"]:[];
            foreach (`o, order, ``{
                if (haskey (options, o))
                {
                    done = add (done, o);
                    cont = add (cont, o, "");
                }
            });
            foreach (`k, `v, options, ``{
                if (! haskey (cont, k))
                {
                    done = add (done, k);
                    cont = add (cont, k, "");
                }
            });
            _options = done;
	}
	else
	{
	    prependlist = ["title", "__section_type", "__sep1"];
	    list done = [];
	    map cont = $[];
	    list order = options["__order__"]:[];
	    foreach (`o, order, ``{
		if (haskey (options, o))
		{
		    done = add (done, o);
		    cont = add (cont, o, "");
		}
	    });
	    foreach (`k, `v, options, ``{
		if (! haskey (cont, k))
		{
		    done = add (done, k);
		    cont = add (cont, k, "");
		}
	    });
	    _options = done;
	}

	_options = filter (`o, _options, ``(! contains (prependlist, o)));
	if (Mode::initial)
	{
	    prependlist = filter (`p, prependlist, ``(p != "__save_method"));
	}
	_options = merge (prependlist, _options);
	return _options;
    }

    /**
      * Get map of widget
      * @return map of widget
      */
    global define map getSectionsWidget () ``{
	map ret = BootCommon::getSectionsWidget ();
	ret["restore"] = ``(BootGRUB::sectionsRead ());
	ret["handle"] = ``(BootGRUB::sectionsHandle ());
	return ret;
    }

    /**
      * Redraw table of sections
      * @param sects list of sections
      */
    global define void sectionsRedrawTable (list sects) ``{
	integer order = -1;
	list sec = maplist (map s, sects, ``{
	    order = order + 1;
	    string other_dev = s["root"]:s["rootnoverify"]:"";
	    string kernel_img = s["kernel"]:"";
	    kernel_img = select (filter (`p, splitstring (kernel_img, " "),
		``(p != "")
	    ), 0, "");
	    string root = BootCommon::getKernelParamFromLine
		(s["kernel"]:"", "root");
	    if (root != "" && root != "false")
		root = sformat (", root=%1", root);
	    else
		root = "";
	    if (substring (kernel_img, 0, 1) != "(")
		kernel_img = other_dev + kernel_img;
	    return `item (`id (s["title"]:""),
		BootCommon::current_globals["default"]:0 == order
		    ? UI::Glyph (`CheckMark) : "",
		s["title"]:"",
		// table cell
		s["kernel"]:"" == "" ? _("other")
			// table cell
		    : _("image"),
		s["kernel"]:"" != ""
		? sformat ("%1   (%2%3)",
		    kernel_img,
		    BootGRUB::grubDev2unixDev (
			select (BootGRUB::splitDevPath (kernel_img), 0, "")
		    ),
		    root
		)
		: sformat ("%1   (%2)", other_dev,
		    BootGRUB::grubDev2unixDev (other_dev))
	    );

	});
	UI::ChangeWidget (`id (`sects), `Items, sec);
    }

    /**
      * Assign default section
      * @param title string title of section to become default
      */
    global define void sectionsAssignDefault (string title) ``{
	integer index = 0;
	integer counter = 0;
	foreach (`s, BootCommon::current_sections, ``{
	    if (s["title"]:"" == title)
		index = counter;
	    counter = counter + 1;
	});
	BootCommon::current_globals["default"] = index;
    }

    /**
      * Read function of a widget
      */
    global define void sectionsRead () ``{
	sectionsRedrawTable (BootCommon::current_sections);
	UI::SetFocus (`id (`sects));
    }

    /**
      * Handle function of widget
      * @param op any operation to handle
      * @param tosave list of operations, which lead to closing & saving widget
      * @return any changed op (if needed)
      */
    global define any sectionsHandle (any op, list tosave) ``{
        string current = UI::QueryWidget (`id (`sects), `CurrentItem);
        integer counter = 0;
        integer index = 0;
	integer default = BootCommon::current_globals["default"]:0;
	string default_title //= _sect["title"]:"";
	    = BootCommon::current_sections[default, "title"]:"";
        foreach (`s, BootCommon::current_sections, ``{
            if (s["title"]:"" == current)
                index = counter;
            counter = counter + 1;
        });
        list sects = BootCommon::current_sections;
        if (op == `up)
        {
            if (index > 0)
            {
                sects = BootCommon::swapItems(sects, index, index - 1);
                index = index - 1;
                BootCommon::current_sections = sects;
		sectionsAssignDefault (default_title);
                sectionsRedrawTable (sects);
                UI::ChangeWidget (`id (`sects), `CurrentItem,
                    sects[index, "title"]:0);
		BootCommon::sections_changed = true;
            }
        }
        else if (op == `down)
        {
            if (index < (size(sects) - 1))
            {
                sects = BootCommon::swapItems(sects, index, index + 1);
                index = index + 1;
                BootCommon::current_sections = sects;
		sectionsAssignDefault (default_title);
                sectionsRedrawTable (sects);
                UI::ChangeWidget (`id (`sects), `CurrentItem,
                    sects[index, "title"]:0);
		BootCommon::sections_changed = true;
            }
        }
	else if (op == `default)
	{
	    BootCommon::current_globals["default"] = index;
	    sectionsRedrawTable (sects);
	    UI::ChangeWidget (`id (`sects), `CurrentItem,
		sects[index, "title"]:0);
	    BootCommon::sections_changed = true;
	}
	else if (op == `add)
	{
            BootCommon::current_section = BootCommon::convertSection
		(nil, "image", nil);
            BootCommon::current_section_name = "";
	    BootCommon::one_section_changed = true;
	}
	else if (op == `edit)
	{
            y2milestone ("Editing title %1, index %2", current, index);
            BootCommon::current_section = eval (sects[index]:$[]);
            BootCommon::current_section_name
                = sects[index, "title"]:"";

            BootCommon::changed_settings_single_sect
                = eval (BootCommon::changed_settings[sects[index, "title"]:""]:$[]);
            y2milestone ("Changed settings: %1", BootCommon::changed_settings_single_sect);
	    BootCommon::one_section_changed = false;
	}
	else if (op == `delete && confirmSectionDeletePopup (current))
	{
	    sects = remove (sects, index);
	    BootCommon::current_sections = sects;
	    if (size (sects) <= BootCommon::current_globals["default"]:0)
		BootCommon::current_globals["default"] = 0;
	    sectionsRedrawTable (sects);
	    BootCommon::sections_changed = true;
	}
        if (contains (tosave, op) && op != `edit && op != `add)
        {
            if (BootCommon::sections_changed)
            {
                BootCommon::markOptionChanged (`global, "__sections");
                BootCommon::markOptionChanged (`global, "__default_section");
            }
        }
        if (op == `back)
        {
            BootCommon::changed_settings
                = eval (BootCommon::changed_settings_all_sections);
            y2milestone ("Restoring changed to %1", BootCommon::changed_settings);
        }
	UI::SetFocus (`id (`sects));
    }

// grub-specific dialogs

    /**
      * Get map of widget
      * @return map of widget
      */
    global define map getOrderPopup () ``{
	return $[
	    "widget" : `HBox (
                `VBox (
                    `ReplacePoint (`id (`disks_rp),
                        `SelectionBox (`id (`disks),
                            `opt (`notify, `immediate),
			    // selectionn box label
                            _("D&isks"), [])
                    ),
		    `HBox (
			`HStretch (),
			`PushButton (`id (`add), `opt (`key_F3), AddButtonLabel ()),
			`PushButton (`id (`delete), `opt(`key_F5), DeleteButtonLabel ()),
			`HStretch ()
		    )
                ),
                `HSquash (
                    `VBox (
                        `VStretch (),
                        `PushButton (`id (`up), `opt (`hstretch), _("&Up")),
                        `PushButton (`id (`down), `opt (`hstretch), _("&Down")),
                        `VStretch ()
                    )
                )
	    ),
	    "restore" : ``(BootGRUB::restoreOrderPopup ()),
	    "handle" : ``(BootGRUB::handleOrderPopup ()),
	    "summary" : ``(BootGRUB::orderSummary ()),
		// label / table cell
	    "label" : _("Disk Order"),
	    "deletable" : false,
	    "help" : getDiskOrderHelp (),
	];
    }

    /**
      * get current order of disks from device map
      * @return a list of disks as string
      */
    global define list(string) getDisksOrder () ``{
        list(list(string)) dl = filter (list(string) i, device_map,
            ``(substring (i[0]:"", 0, 3) == "(hd"));
        dl = sort (list(string) a, list(string) b, dl, ``(a[0]:"" < b[0]:""));
        return maplist (list(string) i, dl, ``{return i[1]:"";});

    }

    /**
      * Summary function for option
      * @return string summary text
      */
    global define string orderSummary () ``{
//	if (disks_order == nil)
	    disks_order = getDisksOrder ();
	return mergestring (disks_order, ", ");
    }

    /**
      * Restore function of widget
      */
    global define void restoreOrderPopup () ``{
//        if (disks_order == nil)
            disks_order = getDisksOrder ();

	UI::ReplaceWidget (`id (`disks_rp), `SelectionBox(`id (`disks),
                    `opt (`notify, `immediate),
                    _("D&isks"), disks_order));
	UI::ChangeWidget (`id (`disks), `CurrentItem, disks_order[0]:"");
	UI::SetFocus (`id (`disks));
	handleOrderPopup (nil, []);
    }

    /**
      * Handle function of widget
      * @param op any operation to handle
      * @param tosave list of operations, which lead to closing & saving widget
      * @return any changed op (if needed)
      */
    global define any handleOrderPopup (any op, list tosave) ``{
	string active = UI::QueryWidget (`id (`disks), `CurrentItem);
	integer pos = 0;
	while (pos < size (disks_order) && disks_order[pos]:"" != active)
	    pos = pos + 1;
	UI::ChangeWidget (`id (`up), `Enabled, pos > 0);
	UI::ChangeWidget (`id (`down), `Enabled, pos < size (disks_order) - 1);
	if (! contains (tosave, op))
	{
	    if (op == `up)
	    {
		disks_order = BootCommon::swapItems (disks_order, pos, pos - 1);
		UI::ReplaceWidget (`id (`disks_rp), `SelectionBox(`id (`disks),
		    `opt (`notify, `immediate),
		    _("D&isks"), disks_order));
		UI::ChangeWidget (`id (`disks), `CurrentItem, active);
	    }
	    else if (op == `down)
	    {
		disks_order = BootCommon::swapItems (disks_order, pos, pos + 1);
		UI::ReplaceWidget (`id (`disks_rp), `SelectionBox(`id (`disks),
		    `opt (`notify, `immediate),
		    _("D&isks"), disks_order));
		UI::ChangeWidget (`id (`disks), `CurrentItem, active);
	    }
	    else if (op == `add)
	    {
		term popup = `VBox (`VSpacing (1),
		    // textentry header
		    `TextEntry (`id (`devname), _("&Device")),
		    `VSpacing (1),
		    `HBox (`HStretch (),
			`PushButton (`id (`ok), `opt (`key_F10, `default), OKButtonLabel ()),
			`HStretch (),
			`PushButton (`id (`cancel), `opt (`key_F8), CancelButtonLabel ()),
			`HStretch ()
		    ),
		    `VSpacing (1)
		);
		UI::OpenDialog (popup);
		symbol pushed = UI::UserInput ();
		string new_dev = UI::QueryWidget (`id (`devname), `Value);
		UI::CloseDialog ();
		if (pushed == `ok)
		{
		    disks_order = add (disks_order, new_dev);
		    UI::ReplaceWidget (`id (`disks_rp),
			`SelectionBox(`id (`disks),
			    `opt (`notify, `immediate),
			    _("D&isks"), disks_order));
		}
	    }
	    else if (op == `delete)
	    {
		disks_order = filter (`i, disks_order, ``(i != active));
		UI::ReplaceWidget (`id (`disks_rp), `SelectionBox(`id (`disks),
                    `opt (`notify, `immediate),
                    _("D&isks"), disks_order));
		UI::ChangeWidget (`id (`delete), `Enabled, size (disks_order) > 0);
		UI::ChangeWidget (`id (`disks),`CurrentItem, disks_order[0]:"");
	    }

	}
	else
	{

            list(list(string)) dl = filter (list(string) i, device_map,
                ``(substring (i[0]:"", 0, 3) == "(hd"));
            dl=sort (list(string) a, list(string) b, dl, ``(a[0]:"" < b[0]:""));

	    map olddiskmap = $[];
	    foreach (list(string) d, dl, ``{
		olddiskmap[d[1]:""] = d[0]:"";
	    });
	    map remap = $[];
	    integer pos = 0;
	    list new_map = filter (list(string) i, device_map,
		``(substring (i[0]:"", 0, 3) != "(hd"));
	    foreach (`d, disks_order, ``{
		string gd = sformat ("(hd%1)", pos);
		if (gd != olddiskmap[d]:"")
		{
		    remap[olddiskmap[d]:""] = gd;
		}
		new_map = add (new_map, [gd, d]);
		pos = pos + 1;
	    });
	    map glob = BootCommon::current_globals;
	    glob = BootGRUB::remapDisks (glob, remap);
	    BootCommon::current_globals = glob;
	    list sects = BootCommon::current_sections;
	    sects = maplist (`s, sects, ``{
		return BootGRUB::remapDisks (s, remap);
	    });
	    BootCommon::current_sections = sects;
	    BootCommon::current_section = BootGRUB::remapDisks (
		BootCommon::current_section, remap);
	    BootGRUB::grub_conf
		= BootGRUB::remapDisks (BootGRUB::grub_conf, remap);
	    BootGRUB::device_map = new_map;
	    BootCommon::mbrDisk = disks_order[0]:BootCommon::mbrDisk;
	    BootCommon::loader_device = BootCommon::GetBootloaderDevice ();
	    disks_order = nil;
	}
	UI::SetFocus (`id (`disks));
	return op;
    }

    /**
      * Get map of widget
      * @return map of widget
      */
    global define map getGfxMenuWidget () ``{
	return $[
	    "handle" : ``(BootGRUB::gfxMenuHandle ()),
	    "delete" : ``(BootCommon::deleteMessage ()),
	];
    }

    /**
      * Handle function of widget
      * @param op any operation to handle
      * @param tosave list of operations, which lead to closing & saving widget
      */
    global define void gfxMenuHandle (any op, list tosave) ``{
	if (! contains (tosave, op))
	    return;
	BootCommon::current_section["gfxmenu"]
	    = UI::QueryWidget (`id (`value), `Value);
	BootCommon::current_section["__intern__"] =
	   add (BootCommon::current_section["__intern__"]:$[], "changed", true);
    }

    /**
      * Get map of widget
      * @return map of widget
      */
    global define map getSingleSectionWidget () ``{
	map ret = BootCommon::getSingleSectionWidget ();
        ret["widget"] = `HBox (ret["widget"]:`VSpacing (0),
            `VBox (
                `VStretch (),
                `PushButton (`id (`up), _("&Up")),
                `PushButton (`id (`down), _("&Down")),
                `VStretch ()
            ),
            `HSpacing (1)
        );
	return ret;
    }

    /**
      * Get map of widget
      * @return map of widget
      */
    global define map getGlobalSectionWidget () ``{
	list items = [
		// menubutton item
            `item (`id (`propose), _("&Propose New Configuration")),
		// menubutton item
            `item (`id (`scratch), _("&Start from Scratch")),
	];
	if (Mode::normal || Mode::config || Mode::repair)
	    items = add (items,
		// menubutton item
		`item (`id (`reread), _("&Reread Configuration from Disk")));
	items = add (items, `item (`id (`propose_deep),
		// menubutton item
		_("Propose and &Merge with Existing GRUB Menus")));
	map ret = BootCommon::getGlobalSectionWidget ();
	ret["widget"] = (`HBox (`HSpacing (2), `VBox (
                    `Table (`id (`settings), `opt (`immediate, `notify, `keepSorting),
			// table header
                        `header (_("Ch."),
			// table header
			_("Option"),
			// table header
			_("Value")), []),
                    `HBox (
                        `PushButton (`id (`add), `opt (`key_F3), AddButtonLabel ()),
                        `PushButton (`id (`edit), `opt (`key_F4), EditButtonLabel ()),
                        `PushButton (`id (`delete), `opt (`key_F5), DeleteButtonLabel ()),
                        `HStretch (),
			// menubutton
			`MenuButton (`id (`restore), _("Res&et"), items)
                    )
                ), `HSpacing (2)));
	term widget = ret["widget"]:nil;
	term buttons = `HBox (
	    `PushButton (`id (`add), `opt (`key_F3), AddButtonLabel ()),
	    `PushButton (`id (`edit), `opt (`key_F4), EditButtonLabel ()),
	    `PushButton (`id (`delete), `opt (`key_F5), DeleteButtonLabel ()),
	    `HStretch ()
	);
	return ret;
    }
}
