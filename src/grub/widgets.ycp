/**
 * File:
 *      include/bootloader/grub/widgets.ycp
 *
 * Module:
 *      Bootloader installation and configuration
 *
 * Summary:
 *      Widgets specific for GRUB bootloader
 *
 * Authors:
 *      Jiri Srain <jsrain@suse.cz>
 *
 * $Id$
 *
 */


{

    import "BootCommon";
    import "Label";
    include "bootloader/routines/popups.ycp";
    include "bootloader/grub/helps.ycp";
    include "bootloader/routines/routines.ycp";

    textdomain "bootloader";

    import "BootGRUB";
    import "Popup";
    import "Mode";
    import "TablePopup";

    /**
      * Get map of dialogs and widgets
      * @return map of dialogs and widgets
      */
    global define map GetWidgetMaps () ``{
        return $[
	    "sections" : BootGRUB::getSectionsWidget (),
	    "singlesection" : BootGRUB::getSingleSectionWidget (),
	    "globalsection" : BootGRUB::getGlobalSectionWidget (),
        ];
    }

    /**
      * Get map of dialogs and widgets
      * @return map of dialogs and widgets
      */
    global define map GetOptionMaps () ``{
        return $[
	    "__location": BootGRUB::getTargetWidget (),
	    "title" : BootCommon::getLabelWidget (),
	    "gfxmenu" : BootGRUB::getGfxMenuWidget (),
	    "__diskorder" : BootGRUB::getOrderPopup (),
	    "__add_orig_mbr" : BootGRUB::getAddOrigMbrWidget (),
	];
    }

    /**
      * Get map of Target widget
      * @return map of Target widget
      */
    global define map getTargetWidget () ``{
	map ret = BootCommon::getTargetOption ();
	ret["popup", "store"] = ``(BootGRUB::targetStore ());
	return ret;
    }

    /**
      * Ask how to chang section floppy <-> hard disk when changing bootloader
      * location between disk and floppy
      * @param to string new bootloader location ("floppy" or "hard disk")
      * @return boolean true if user wants to change the section
      */
    global define boolean changeSection (string to) ``{
	string message = "";
	if (to == "floppy")
		// yes-no popup
	    message = _("You chose to install the boot loader to the floppy.
The menu of the boot loader contains an entry to boot from the floppy.
Replace it with an entry to boot from the hard disk?");
	else
		// yes-no popup
	    message = _("You chose to install the boot loader to the hard disk.
The menu of the boot loader contains an entry to boot from the hard disk.
Replace it with an entry  to boot from the floppy?");
	return Popup::YesNo (message);
    }

    /**
      * Store function of a popup
      * @param opt_id any option id
      * @param opt_key any option key
      */
    global define void targetStore (any opt_id, any opt_key) ``{
	BootCommon::targetWrite (op, save);
	list sections = BootCommon::current_sections;
	if (issubstring (BootCommon::loader_device, "/dev/fd")||
	    BootCommon::installingToFloppy ())
	{
	    sections = maplist (`s, sections, ``{
		if ((getCreationType (s) == "floppy"
			|| lookup_value (s, "root", "") == "(fd0)")
		    && changeSection ("floppy"))
		{
		    s = [
			$[ "key" : "title", "value" : translateSectionTitle ("hard disk")],
			$[ "key" : "root", "value" : "(hd0)"],
			$[ "key" : "chainloader", "value"  : "+1"],
	                $[ "key" : "__intern__", "value" : $[
		            "changed" : false,
		            "auto" : true,
		            "devs" : [],
			    "type" : "hard_disk",
		        ]],
		    ];
		}
		return s;
	    });
	}
	else
	{
	    sections = maplist (`s, sections, ``{
		if ((getCreationType (s) == "hard_disk"
			    || lookup_value (s, "root", "") == "(hd0)")
			&& changeSection ("disk"))
		{
		    s = [
			$[ "key" : "title", "value" : translateSectionTitle ("floppy")],
			$[ "key" : "root", "value" : "(fd0)"],
			$[ "key" : "chainloader", "value" : "+1"],
                        $[ "key" : "__intern__", "value" : $[
                            "changed" : false,
                            "auto" : true,
                            "devs" : [],
			    "type" : "floppy",
                        ]],
		    ];
		}
		return s;
	    });
	}
	BootCommon::current_sections = sections;
    }

    /**
      * Get map of widget
      * @return map of widget
      */
    global define map getGlobalSectionWidget () ``{
	return TablePopup::CreateTableDescr (
	    $[
		"add_delete" : true,
		"up_down_buttons" : false,
		"changed_column" : true,
		"unique_keys" : true,
	    ],
	    $[
		"init" : ``(BootCommon::globalSectionInit ()),
		"handle" : ``(BootCommon::globalSectionHandle ()),
		"store" : ``(BootCommon::globalSectionStore ()),
		"options": BootCommon::cwm_options,
		"id2key": ``(BootCommon::id2key ()),
		"ids": ``(BootGRUB::getTableContents ()),
                "help": BootCommon::getGlobalSectionHelp (),
                "fallback" : $[
                    "init": ``(BootCommon::commonPopupInit ()),
                    "store": ``(BootCommon::commonPopupStore ()),
                    "summary": ``(BootCommon::commonTableEntrySummary ()),
                    "changed" : ``(BootCommon::commonTableChanged ()),
                ],
		"option_move" : ``(BootCommon::moveTableItem ()),
                "option_delete": ``(BootCommon::commonTableEntryDelete ()),
                "add_items":  lookup (GetOptions (), `global, []),
	    ]
	);
    }

    /**
      * Create a list of options for the table
      * @param descr map description of the table
      * @return list of option ids as it should be displayed
      */
    global define list getTableContents (map descr) ``{
	list prependlist = [];
	list forbidden_keys = [];
	any type = BootCommon::getSectionType (BootCommon::current_section);
	if (type == `global)
	{
	    prependlist = ["__loader_type", "__sep2", "__location",
		"__diskorder", "default", "__sections", "__activate",
		"__repl_mbr", "__backup_mbr", "__add_orig_mbr",
		"__save_method", "__sep1"];
	    forbidden_keys = ["default"];
	}
	else
	{
	    prependlist = ["title", "__section_type", "__sep1"];
	}
	return BootCommon::createSectionItemsList (
	    prependlist, forbidden_keys, false);
    }

    /**
      * Get map of widget
      * @return map of widget
      */
    global define map getSectionsWidget () ``{
	map ret = BootCommon::getSectionsWidget ();
	ret["init"] = ``(BootGRUB::sectionsInit ());
	ret["handle"] = ``(BootGRUB::sectionsHandle ());
	return ret;
    }

    /**
      * Redraw table of sections
      * @param sects list of sections
      */
    global define void sectionsRedrawTable (list sects) ``{
	integer order = -1;
	list sec = maplist (map s, sects, ``{
	    order = order + 1;
	    string other_dev
		= lookup_value (s, "root",
		    lookup_value (s,
			"rootnoverify", ""));
	    string kernel_img
		= lookup_value (s, "kernel", "");
	    kernel_img = select (filter (`p, splitstring (kernel_img, " "),
		``(p != "")
	    ), 0, "");
	    string root = BootCommon::getKernelParamFromLine
		(lookup_value (s, "kernel", ""),
		    "root");
	    if (root != "" && root != "false")
		root = sformat (", root=%1", root);
	    else
		root = "";
	    if (substring (kernel_img, 0, 1) != "(")
		kernel_img = other_dev + kernel_img;
	    return `item (`id (lookup_value (s,
		    "title", "")),
		lookup_value (
			BootCommon::current_globals, "default", 0)
		== order
		    ? UI::Glyph (`CheckMark) : "",
		lookup_value (s, "title", ""),
		lookup_value (s, "kernel", nil)
			// table cell
		    == nil ? _("other")
			// table cell
		    : _("image"),
		lookup_value (s, "kernel", "")
		    != ""
		? sformat ("%1   (%2%3)",
		    kernel_img,
		    BootGRUB::grubDev2unixDev (
			select (BootGRUB::splitDevPath (kernel_img), 0, "")
		    ),
		    root
		)
		: sformat ("%1   (%2)", other_dev,
		    BootGRUB::grubDev2unixDev (other_dev))
	    );

	});
	UI::ChangeWidget (`id (`sects), `Items, sec);
    }

    /**
      * Assign default section
      * @param title string title of section to become default
      */
    global define void sectionsAssignDefault (string title) ``{
	integer index = 0;
	integer counter = 0;
	foreach (`s, BootCommon::current_sections, ``{
	    if (lookup_value (s, "title", "")
		== title)
	    {
		index = counter;
	    }
	    counter = counter + 1;
	});
	BootCommon::addValueToBootloaderSection (
	    `current_globals, "default", index);
    }

    /**
      * Init function of widget
      * @param widget_id any id of the widget
      */
    global define void sectionsInit (any widget_id) ``{
	sectionsRedrawTable (BootCommon::current_sections);
	UI::SetFocus (`id (`sects));
    }

    /**
      * Handle function of a widget
      * @param widget_id any widget key
      * @param event map event description of event that occured
      * @return symbol to return to wizard sequencer, or nil
      */
    global define symbol sectionsHandle (any widget_id, map event) ``{
	any op = event["ID"]:nil;
	if (event["ID"]:nil == `sects
	    && event["EventReason"]:"" == "Activated"
	    && event["EventType"]:"" == "WidgetEvent")
	{
	    op = `edit;
	}
        string current = UI::QueryWidget (`id (`sects), `CurrentItem);
        integer counter = 0;
        integer index = 0;
	integer default = lookup_value (
	    BootCommon::current_globals, "default", 0);
	string default_title
	    = lookup_value (
		BootCommon::current_sections[default]:[], "title", "");
        foreach (`s, BootCommon::current_sections, ``{
            if (lookup_value (s, "title", "")
		== current)
	    {
                index = counter;
	    }
            counter = counter + 1;
        });
        list sects = BootCommon::current_sections;
        if (op == `up)
        {
            if (index > 0)
            {
                sects = BootCommon::swapItems(sects, index, index - 1);
                index = index - 1;
                BootCommon::current_sections = sects;
		sectionsAssignDefault (default_title);
                sectionsRedrawTable (sects);
                UI::ChangeWidget (`id (`sects), `CurrentItem,
                    lookup_value (
			sects[index]:[], "title", 0));
		BootCommon::sections_changed = true;
            }
        }
        else if (op == `down)
        {
            if (index < (size(sects) - 1))
            {
                sects = BootCommon::swapItems(sects, index, index + 1);
                index = index + 1;
                BootCommon::current_sections = sects;
		sectionsAssignDefault (default_title);
                sectionsRedrawTable (sects);
                UI::ChangeWidget (`id (`sects), `CurrentItem,
                    lookup_value (sects[index]:[],
			"title", 0));
		BootCommon::sections_changed = true;
            }
        }
	else if (op == `default)
	{
	    BootCommon::addValueToBootloaderSection (
		`current_globals, "default", index);
	    sectionsRedrawTable (sects);
	    UI::ChangeWidget (`id (`sects), `CurrentItem,
		lookup_value (sects[index]:[],
		"title", 0));
	    BootCommon::sections_changed = true;
	}
	else if (op == `add)
	{
	    list selected = sects[index]:[];
	    string name = lookup_value (selected,
		BootCommon::getSectionTitle (), "");
	    if (askClone (name))
	    {
		selected = modifySection (
		    eval (selected),
		    BootCommon::getSectionTitle (),
		    BootCommon::getFreeSectionLabel ());
		BootCommon::current_section = selected;
	    }
	    else
	    {
		BootCommon::current_section = BootCommon::convertSection
		    (nil, "image", nil);
	    }
            BootCommon::current_section_name = "";
	    BootCommon::one_section_changed = true;
	    return `add;
	}
	else if (op == `edit)
	{
            y2milestone ("Editing title %1, index %2", current, index);
            BootCommon::current_section = eval (sects[index]:[]);
            BootCommon::current_section_name
                = lookup_value (sects[index]:[], "title", "");
	    BootCommon::one_section_changed = false;
	    return `edit;
	}
	else if (op == `delete && confirmSectionDeletePopup (current))
	{
	    sects = remove (sects, index);
	    BootCommon::current_sections = sects;
	    if (size (sects) <= lookup_value (
		BootCommon::current_globals, "default", 0))
	    {
		BootCommon::addValueToBootloaderSection (`current_globals,
		    "default", 0);
	    }
	    sectionsRedrawTable (sects);
	    BootCommon::sections_changed = true;
	}
	UI::SetFocus (`id (`sects));
	return nil;
    }

// grub-specific dialogs

    /**
      * Get map of widget
      * @return map of widget
      */
    global define map getOrderPopup () ``{
	return $[
	    "table" : $[
		"summary" : ``(BootGRUB::orderSummary ()),
		// label / table cell
		"label" : _("Disk Order"),
		"optional" : false,
		"help" : getDiskOrderHelp (),
		"unique_key" : true,
	    ],
	    "popup" : $[
		"widget" : `custom,
		"custom_widget" : `HBox (`VBox (
                    `ReplacePoint (`id (`disks_rp),
                        `SelectionBox (`id (`disks),
                            `opt (`notify, `immediate),
			    // selectionn box label
                            _("D&isks"), [])
                    ),
		    `HBox (
			`HStretch (),
			`PushButton (`id (`add), `opt (`key_F3), Label::AddButton ()),
			`PushButton (`id (`delete), `opt(`key_F5), Label::DeleteButton ()),
			`HStretch ()
		    )
                ),
                `HSquash (
                    `VBox (
                        `VStretch (),
                        `PushButton (`id (`up), `opt (`hstretch), _("&Up")),
                        `PushButton (`id (`down), `opt (`hstretch), _("&Down")),
                        `VStretch ()
                    )
                )),
		"init" : ``(BootGRUB::initOrderPopup ()),
		"handle" : ``(BootGRUB::handleOrderPopup ()),
		"store" : ``(BootGRUB::storeOrderPopup ()),
	    ],
	];
    }

    /**
      * get current order of disks from device map
      * @return a list of disks as string
      */
    global define list(string) getDisksOrder () ``{
        list(list(string)) dl = filter (list(string) i, device_map,
            ``(substring (i[0]:"", 0, 3) == "(hd"));
        dl = sort (list(string) a, list(string) b, dl, ``(a[0]:"" < b[0]:""));
        return maplist (list(string) i, dl, ``{return i[1]:"";});

    }

    /**
      * Summary function of a table entry
      * @param opt_id any option id
      * @param opt_key any option key
      * @return string summary to the table
      */
    global define string orderSummary (any opt_id, any opt_key) ``{
	disks_order = getDisksOrder ();
	return mergestring (disks_order, ", ");
    }

    /**
      * Init function of a popup
      * @param opt_id any option id
      * @param opt_key any option key
      */
    global define void initOrderPopup (any opt_id, any opt_key) ``{
        disks_order = getDisksOrder ();
	UI::ReplaceWidget (`id (`disks_rp), `SelectionBox(`id (`disks),
                    `opt (`notify, `immediate),
                    _("D&isks"), disks_order));
	UI::ChangeWidget (`id (`disks), `CurrentItem, disks_order[0]:"");
	UI::SetFocus (`id (`disks));
	handleOrderPopup (nil, nil, $[]);
    }

    /**
      * Handle function of widget
      * @param opt_id any option id
      * @param opt_key any option key
      * @param event map event that occured
      */
    global define void handleOrderPopup (any opt_id, any opt_key, map event) ``{
	any op = event["ID"]:nil;
	string active = UI::QueryWidget (`id (`disks), `CurrentItem);
	integer pos = 0;
	while (pos < size (disks_order) && disks_order[pos]:"" != active)
	    pos = pos + 1;
	UI::ChangeWidget (`id (`up), `Enabled, pos > 0);
	UI::ChangeWidget (`id (`down), `Enabled, pos < size (disks_order) - 1);
	    if (op == `up)
	    {
		disks_order = BootCommon::swapItems (disks_order, pos, pos - 1);
		UI::ReplaceWidget (`id (`disks_rp), `SelectionBox(`id (`disks),
		    `opt (`notify, `immediate),
		    _("D&isks"), disks_order));
		UI::ChangeWidget (`id (`disks), `CurrentItem, active);
	    }
	    else if (op == `down)
	    {
		disks_order = BootCommon::swapItems (disks_order, pos, pos + 1);
		UI::ReplaceWidget (`id (`disks_rp), `SelectionBox(`id (`disks),
		    `opt (`notify, `immediate),
		    _("D&isks"), disks_order));
		UI::ChangeWidget (`id (`disks), `CurrentItem, active);
	    }
	    else if (op == `add)
	    {
		term popup = `VBox (`VSpacing (1),
		    // textentry header
		    `TextEntry (`id (`devname), _("&Device")),
		    `VSpacing (1),
		    `HBox (`HStretch (),
			`PushButton (`id (`ok), `opt (`key_F10, `default), Label::OKButton ()),
			`HStretch (),
			`PushButton (`id (`cancel), `opt (`key_F8), Label::CancelButton ()),
			`HStretch ()
		    ),
		    `VSpacing (1)
		);
		UI::OpenDialog (popup);
		symbol pushed = UI::UserInput ();
		string new_dev = UI::QueryWidget (`id (`devname), `Value);
		UI::CloseDialog ();
		if (pushed == `ok)
		{
		    disks_order = add (disks_order, new_dev);
		    UI::ReplaceWidget (`id (`disks_rp),
			`SelectionBox(`id (`disks),
			    `opt (`notify, `immediate),
			    _("D&isks"), disks_order));
		}
	    }
	    else if (op == `delete)
	    {
		disks_order = filter (`i, disks_order, ``(i != active));
		UI::ReplaceWidget (`id (`disks_rp), `SelectionBox(`id (`disks),
                    `opt (`notify, `immediate),
                    _("D&isks"), disks_order));
		UI::ChangeWidget (`id (`delete), `Enabled, size (disks_order) > 0);
		UI::ChangeWidget (`id (`disks),`CurrentItem, disks_order[0]:"");
	    }

	UI::SetFocus (`id (`disks));
    }

    /**
      * Store function of a popup
      * @param opt_id any option id
      * @param opt_key any option key
      */
    global define void storeOrderPopup (any opt_id, any opt_key) ``{
            list(list(string)) dl = filter (list(string) i, device_map,
                ``(substring (i[0]:"", 0, 3) == "(hd"));
            dl=sort (list(string) a, list(string) b, dl, ``(a[0]:"" < b[0]:""));

	    map olddiskmap = $[];
	    foreach (list(string) d, dl, ``{
		olddiskmap[d[1]:""] = d[0]:"";
	    });
	    map remap = $[];
	    integer pos = 0;
	    list new_map = filter (list(string) i, device_map,
		``(substring (i[0]:"", 0, 3) != "(hd"));
	    foreach (`d, disks_order, ``{
		string gd = sformat ("(hd%1)", pos);
		if (gd != olddiskmap[d]:"")
		{
		    remap[olddiskmap[d]:""] = gd;
		}
		new_map = add (new_map, [gd, d]);
		pos = pos + 1;
	    });
	    remap = filter (string k, string v, remap, ``(k != "" && v != ""));
	    BootCommon::current_globals
		= BootGRUB::remapDisks (BootCommon::current_globals, remap);
	    BootCommon::sections = maplist (`s, BootCommon::sections, ``{
		return BootGRUB::remapDisks (s, remap);
	    });
	    BootCommon::current_section = BootGRUB::remapDisks (
		BootCommon::current_section, remap);
	    list gcl = maplist (`k, `v, BootGRUB::grub_conf, ``(
		$[ "key" : k, "value" : v]));
	    gcl = BootGRUB::remapDisks (gcl, remap);
	    BootGRUB::grub_conf = listmap (`e, gcl, ``(
		[e["key"]:"", e["value"]:""]));
	    BootGRUB::device_map = new_map;
	    BootCommon::mbrDisk = disks_order[0]:BootCommon::mbrDisk;
	    BootCommon::loader_device = BootCommon::GetBootloaderDevice ();
	    disks_order = nil;
	    BootCommon::markGeneralOptionChanged (opt_key);
	    BootCommon::location_changed = true;
	    BootCommon::redraw_table = true;
    }

    /**
      * Get map of widget
      * @return map of widget
      */
    global define map getGfxMenuWidget () ``{
	return $[
	    "table" : $[
		"delete" : ``(BootCommon::deleteMessage ()),
		"unique_key" : true,
	    ],
	    "popup" : $[
		"store" : ``(BootGRUB::gfxMenuStore ()),

	    ],
	];
    }

    /**
      * Store function of a popup
      * @param opt_id any option id
      * @param opt_key any option key
      */
    global define void gfxMenuStore (any opt_id, any opt_key) ``{
	BootCommon::current_section = setValueByIndex (
	    BootCommon::current_section, -1,
	    BootCommon::current_option_name,
	    UI::QueryWidget (`id (`value), `Value));

	map intern = lookup_value (BootCommon::current_section,
	    "__intern__", $[]);
	intern["changed"] = true;
	BootCommon::addValueToBootloaderSection (
	    `current_section, "__intern__", intern);
	y2milestone ("Final current section: %1", BootCommon::current_section);
    }

    /**
      * Get map of widget
      * @return map of widget
      */
    global define map getSingleSectionWidget () ``{
	return TablePopup::CreateTableDescr (
	    $[
		"add_delete" : true,
		"up_down_buttons" : true,
		"changed_column" : true,
		"unique_keys" : true,
	    ],
	    $[
		"store" : ``(BootCommon::singleSectionStore ()),
		"options": BootCommon::cwm_options,
		"id2key": ``(BootCommon::id2key ()),
		"ids": ``(BootGRUB::getTableContents ()),
		"help": BootCommon::getSingleSectionHelp (),
		"fallback" : $[
		    "init": ``(BootCommon::commonPopupInit ()),
		    "store": ``(BootCommon::commonPopupStore ()),
		    "summary": ``(BootCommon::commonTableEntrySummary ()),
		    "changed" : ``(BootCommon::commonTableChanged ()),
		],
		"handle" : ``(BootCommon::singleSectionHandle ()),
		"option_move" : ``(BootCommon::moveTableItem ()),
		"option_delete": ``(BootCommon::commonTableEntryDelete ()),
	    ]
	);
    }

    /**
      * Get map of widget
      * @return map of widget
      */
    global define map getAddOrigMbrWidget () ``{
	return $[
	    "table" : $[
		// table item / label
		"label" : _("Add Saved MBR to Boot Loader Menu"),
		"summary" : ``(BootGRUB::addOrigMbrSummary ()),
		"optional" : false,
		"ordering" : false,
		"unique_key" : true,
	    ],
	    "popup" : $[
		"init" : ``(BootGRUB::addOrigMbrInit ()),
		"store" : ``(BootGRUB::addOrigMbrStore ()),
		"widget" : `checkbox,

	    ],
	];
    }

    /**
      * Init function of a popup
      * @param opt_id any option id
      * @param opt_key any option key
      */
    global define void addOrigMbrInit (any opt_id, any opt_key) ``{
        UI::ChangeWidget (`id (`value), `Value, insert_saved_mbr);
        UI::SetFocus (`id (`value));
    }

    /**
      * Store function of a popup
      * @param opt_id any option id
      * @param opt_key any option key
      */
    global define void addOrigMbrStore (any opt_id, any opt_key) ``{
        insert_saved_mbr = UI::QueryWidget (`id (`value), `Value);
	if (insert_saved_mbr)
	{
	    boolean found = false;
	    foreach (`s, BootCommon::sections, ``{
		if (lookup (lookup_value (s, "__intern__", $[]), "original_mbr", false))
		{
		    found = true;
		    y2error ("Found %1", s);
		}
	    });
	    if (! found)
	    {
		BootCommon::current_sections = add (
		    BootCommon::current_sections,
		    createLinuxSection ("original MBR"));
	    }
	}
	else
	{
	    BootCommon::current_sections = filter (`s,
		BootCommon::current_sections, ``(
		! lookup (lookup_value (s, "__intern__", $[]), "original_mbr", false)));
	}
	markGeneralOptionChanged (opt_key);
    }

    /**
      * Summary function of a table entry
      * @param opt_id any option id
      * @param opt_key any option key
      * @return string summary to the table
      */
    global define string addOrigMbrSummary (any opt_id, any opt_key) ``{
        if (insert_saved_mbr)
            // table item / label
            return _("Yes");
        else
            // table item / label
            return _("No");
    }

}
