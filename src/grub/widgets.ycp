/**
 * File:
 *      include/bootloader/grub/widgets.ycp
 *
 * Module:
 *      Bootloader installation and configuration
 *
 * Summary:
 *      Widgets specific for GRUB bootloader
 *
 * Authors:
 *      Jiri Srain <jsrain@suse.cz>
 *
 * $Id$
 *
 */


{

    import "BootCommon";
    import "Label";
    include "bootloader/routines/popups.ycp";
    include "bootloader/grub/helps.ycp";
    include "bootloader/routines/routines.ycp";

    textdomain "bootloader";

    import "BootGRUB";
    import "Popup";
    import "Mode";

    /**
      * Get map of dialogs and widgets
      * @return map of dialogs and widgets
      */
    global define map GetWidgets () ``{
        return $[
	    "sections" : ``(BootGRUB::getSectionsWidget ()),
	    "singlesection" : ``(BootGRUB::getSingleSectionWidget ()),
	    "tableentries" :$[
		"__location": ``(BootGRUB::getTargetWidget ()),
		"title" : ``(BootCommon::getLabelWidget ()),
		"gfxmenu" : ``(BootGRUB::getGfxMenuWidget ()),
		"__diskorder" : ``(BootGRUB::getOrderPopup ()),
		"__add_orig_mbr" : ``(BootGRUB::getAddOrigMbrWidget ()),
	    ],
        ];
    }

    /**
      * Get map of Target widget
      * @return map of Target widget
      */
    global define map getTargetWidget () ``{
	map ret = BootCommon::getTargetWidget ();
	ret["handle"] = ``(BootGRUB::targetWrite ());
	return ret;
    }

    /**
      * Ask how to chang section floppy <-> hard disk when changing bootloader
      * location between disk and floppy
      * @param to string new bootloader location ("floppy" or "hard disk")
      * @return boolean true if user wants to change the section
      */
    global define boolean changeSection (string to) ``{
	string message = "";
	if (to == "floppy")
		// yes-no popup
	    message = _("You chose to install the boot loader to the floppy.
The menu of the boot loader contains an entry to boot from the floppy.
Replace it with an entry to boot from the hard disk?");
	else
		// yes-no popup
	    message = _("You chose to install the boot loader to the hard disk.
The menu of the boot loader contains an entry to boot from the hard disk.
Replace it with an entry  to boot from the floppy?");
	return Popup::YesNo (message);
    }

    /**
      * Handle function of widget
      * @param op any operation to handle
      * @param save boolean true if op should lead to closing & saving widget
      * @return any changed op (if needed)
      */
    global define any targetWrite (any op, boolean save) ``{
	any ret = BootCommon::targetWrite (op, save);
	if (save)
	{
	    list sections = BootCommon::current_sections;
	    if (issubstring (BootCommon::loader_device, "/dev/fd")||
		BootCommon::installingToFloppy ())
	    {
		sections = maplist (`s, sections, ``{
		    if ((getCreationType (s) == "floppy"
			    || lookup_value (s, "root", "") == "(fd0)")
			&& changeSection ("floppy"))
		    {
			s = [
			    $[ "key" : "title", "value" : translateSectionTitle ("hard disk")],
			    $[ "key" : "root", "value" : "(hd0)"],
			    $[ "key" : "chainloader", "value"  : "+1"],
	                    $[ "key" : "__intern__", "value" : $[
		                "changed" : false,
		                "auto" : true,
		                "devs" : [],
				"type" : "hard_disk",
		            ]],
			];
		    }
		    return s;
		});
	    }
	    else
	    {
		sections = maplist (`s, sections, ``{
		    if ((getCreationType (s) == "hard_disk"
			    || lookup_value (s, "root", "") == "(fd0)")
			&& changeSection ("disk"))
		    {
			s = [
			    $[ "key" : "title", "value" : translateSectionTitle ("floppy")],
			    $[ "key" : "root", "value" : "(fd0)"],
			    $[ "key" : "chainloader", "value" : "+1"],
                            $[ "key" : "__intern__", "value" : $[
                                "changed" : false,
                                "auto" : true,
                                "devs" : [],
				"type" : "floppy",
                            ]],
			];
		    }
		    return s;
		});
	    }
	    BootCommon::current_sections = sections;
	}
	return ret;
    }


    /**
      * Update list of optoins to show in table
      * @param _options list of options including order
      * @return list of option to show
      */
    global define list UpdateOptionsList (list _options) ``{
        list prependlist = [];
        list orig_opts = _options;
	any type = BootCommon::getSectionType (BootCommon::current_section);
	if (type == `global)
	{
	    prependlist = ["__loader_type", "__sep2", "__location",
		"__diskorder", "__default_section", "__sections", "__activate",
		"__repl_mbr", "__backup_mbr", "__add_orig_mbr",
		"__save_method", "__sep1"];
            _options = filter (`o, _options,
		``(o["key"]:"" != "boot" && o["key"]:"" != "default"));
	}
	else
	{
	    prependlist = ["title", "__section_type", "__sep1"];
	}

	_options = filter (`o, _options, ``(! contains (
	    prependlist, o["key"]:"")));
	if (Mode::initial)
	{
	    prependlist = filter (`p, prependlist, ``(p != "__save_method"));
	}
	if ((! BootCommon::backup_mbr) && 0 >= SCR::Read (.target.size,
	    "/boot/backup/mbr"))
	{
	    prependlist = filter (`p, prependlist, ``(p != "__add_orig_mbr"));
	}
        prependlist = maplist (`p, prependlist, ``{
            map m = getValueMap (orig_opts, p);
            if (m == $[])
            {
                m = $[ "key" : p];
            }
            return m;
        });
        list options = merge (prependlist, _options);
        return options;
    }

    /**
      * Get map of widget
      * @return map of widget
      */
    global define map getSectionsWidget () ``{
	map ret = BootCommon::getSectionsWidget ();
	ret["restore"] = ``(BootGRUB::sectionsRead ());
	ret["handle"] = ``(BootGRUB::sectionsHandle ());
	return ret;
    }

    /**
      * Redraw table of sections
      * @param sects list of sections
      */
    global define void sectionsRedrawTable (list sects) ``{
	integer order = -1;
	list sec = maplist (map s, sects, ``{
	    order = order + 1;
	    string other_dev
		= lookup_value (s, "root",
		    lookup_value (s,
			"rootnoverify", ""));
	    string kernel_img
		= lookup_value (s, "kernel", "");
	    kernel_img = select (filter (`p, splitstring (kernel_img, " "),
		``(p != "")
	    ), 0, "");
	    string root = BootCommon::getKernelParamFromLine
		(lookup_value (s, "kernel", ""),
		    "root");
	    if (root != "" && root != "false")
		root = sformat (", root=%1", root);
	    else
		root = "";
	    if (substring (kernel_img, 0, 1) != "(")
		kernel_img = other_dev + kernel_img;
	    return `item (`id (lookup_value (s,
		    "title", "")),
		lookup_value (
			BootCommon::current_globals, "default", 0)
		== order
		    ? UI::Glyph (`CheckMark) : "",
		lookup_value (s, "title", ""),
		// table cell
		lookup_value (s, "kernel", nil)
		    == "" ? _("other")
			// table cell
		    : _("image"),
		lookup_value (s, "kernel", "")
		    != ""
		? sformat ("%1   (%2%3)",
		    kernel_img,
		    BootGRUB::grubDev2unixDev (
			select (BootGRUB::splitDevPath (kernel_img), 0, "")
		    ),
		    root
		)
		: sformat ("%1   (%2)", other_dev,
		    BootGRUB::grubDev2unixDev (other_dev))
	    );

	});
	UI::ChangeWidget (`id (`sects), `Items, sec);
    }

    /**
      * Assign default section
      * @param title string title of section to become default
      */
    global define void sectionsAssignDefault (string title) ``{
	integer index = 0;
	integer counter = 0;
	foreach (`s, BootCommon::current_sections, ``{
	    if (lookup_value (s, "title", "")
		== title)
	    {
		index = counter;
	    }
	    counter = counter + 1;
	});
	BootCommon::addValueToBootloaderSection (
	    `current_globals, "default", index);
    }

    /**
      * Read function of a widget
      */
    global define void sectionsRead () ``{
	sectionsRedrawTable (BootCommon::current_sections);
	UI::SetFocus (`id (`sects));
    }

    /**
      * Handle function of widget
      * @param op any operation to handle
      * @param save boolean true if op should lead to closing & saving widget
      * @return any changed op (if needed)
      */
    global define any sectionsHandle (any op, boolean save) ``{
        string current = UI::QueryWidget (`id (`sects), `CurrentItem);
        integer counter = 0;
        integer index = 0;
	integer default = lookup_value (
	    BootCommon::current_globals, "default", 0);
	string default_title
	    = lookup_value (
		BootCommon::current_sections[default]:[], "title", "");
        foreach (`s, BootCommon::current_sections, ``{
            if (lookup_value (s, "title", "")
		== current)
	    {
                index = counter;
	    }
            counter = counter + 1;
        });
        list sects = BootCommon::current_sections;
        if (op == `up)
        {
            if (index > 0)
            {
                sects = BootCommon::swapItems(sects, index, index - 1);
                index = index - 1;
                BootCommon::current_sections = sects;
		sectionsAssignDefault (default_title);
                sectionsRedrawTable (sects);
                UI::ChangeWidget (`id (`sects), `CurrentItem,
                    lookup_value (
			sects[index]:[], "title", 0));
		BootCommon::sections_changed = true;
            }
        }
        else if (op == `down)
        {
            if (index < (size(sects) - 1))
            {
                sects = BootCommon::swapItems(sects, index, index + 1);
                index = index + 1;
                BootCommon::current_sections = sects;
		sectionsAssignDefault (default_title);
                sectionsRedrawTable (sects);
                UI::ChangeWidget (`id (`sects), `CurrentItem,
                    lookup_value (sects[index]:[],
			"title", 0));
		BootCommon::sections_changed = true;
            }
        }
	else if (op == `default)
	{
	    BootCommon::addValueToBootloaderSection (
		`current_globals, "default", index);
	    sectionsRedrawTable (sects);
	    UI::ChangeWidget (`id (`sects), `CurrentItem,
		lookup_value (sects[index]:[],
		"title", 0));
	    BootCommon::sections_changed = true;
	}
	else if (op == `add)
	{
	    list selected = sects[index]:[];
	    string name = lookup_value (selected,
		BootCommon::getSectionTitle (), "");
	    if (askClone (name))
	    {
		selected = modifySection (
		    eval (selected),
		    BootCommon::getSectionTitle (),
		    BootCommon::getFreeSectionLabel ());
		BootCommon::current_section = selected;
	    }
	    else
	    {
		BootCommon::current_section = BootCommon::convertSection
		    (nil, "image", nil);
	    }
            BootCommon::current_section_name = "";
	    BootCommon::one_section_changed = true;
	}
	else if (op == `edit)
	{
            y2milestone ("Editing title %1, index %2", current, index);
            BootCommon::current_section = eval (sects[index]:[]);
            BootCommon::current_section_name
                = lookup_value (sects[index]:[], "title", "");

	    BootCommon::one_section_changed = false;
	}
	else if (op == `delete && confirmSectionDeletePopup (current))
	{
	    sects = remove (sects, index);
	    BootCommon::current_sections = sects;
	    if (size (sects) <= lookup_value (
		BootCommon::current_globals, "default", 0))
	    {
		BootCommon::addValueToBootloaderSection (`current_globals,
		    "default", 0);
	    }
	    sectionsRedrawTable (sects);
	    BootCommon::sections_changed = true;
	}
        if (save && op != `edit && op != `add)
        {
            if (BootCommon::sections_changed)
            {
		BootCommon::changed = true;
                BootCommon::markOptionChanged (`current_globals, "__sections");
                BootCommon::markOptionChanged (`current_globals, "__default_section");
            }
        }
        if (op == `back)
        {
        }
	UI::SetFocus (`id (`sects));
	return nil;
    }

// grub-specific dialogs

    /**
      * Get map of widget
      * @return map of widget
      */
    global define map getOrderPopup () ``{
	return $[
	    "widget" : `HBox (
                `VBox (
                    `ReplacePoint (`id (`disks_rp),
                        `SelectionBox (`id (`disks),
                            `opt (`notify, `immediate),
			    // selectionn box label
                            _("D&isks"), [])
                    ),
		    `HBox (
			`HStretch (),
			`PushButton (`id (`add), `opt (`key_F3), Label::AddButton ()),
			`PushButton (`id (`delete), `opt(`key_F5), Label::DeleteButton ()),
			`HStretch ()
		    )
                ),
                `HSquash (
                    `VBox (
                        `VStretch (),
                        `PushButton (`id (`up), `opt (`hstretch), _("&Up")),
                        `PushButton (`id (`down), `opt (`hstretch), _("&Down")),
                        `VStretch ()
                    )
                )
	    ),
	    "restore" : ``(BootGRUB::restoreOrderPopup ()),
	    "handle" : ``(BootGRUB::handleOrderPopup ()),
	    "summary" : ``(BootGRUB::orderSummary ()),
		// label / table cell
	    "label" : _("Disk Order"),
	    "deletable" : false,
	    "help" : getDiskOrderHelp (),
	    "key_only_once" : true,
	];
    }

    /**
      * get current order of disks from device map
      * @return a list of disks as string
      */
    global define list(string) getDisksOrder () ``{
        list(list(string)) dl = filter (list(string) i, device_map,
            ``(substring (i[0]:"", 0, 3) == "(hd"));
        dl = sort (list(string) a, list(string) b, dl, ``(a[0]:"" < b[0]:""));
        return maplist (list(string) i, dl, ``{return i[1]:"";});

    }

    /**
      * Summary function for option
      * @return string summary text
      */
    global define string orderSummary () ``{
	disks_order = getDisksOrder ();
	return mergestring (disks_order, ", ");
    }

    /**
      * Restore function of widget
      */
    global define void restoreOrderPopup () ``{
        disks_order = getDisksOrder ();
	UI::ReplaceWidget (`id (`disks_rp), `SelectionBox(`id (`disks),
                    `opt (`notify, `immediate),
                    _("D&isks"), disks_order));
	UI::ChangeWidget (`id (`disks), `CurrentItem, disks_order[0]:"");
	UI::SetFocus (`id (`disks));
	handleOrderPopup (nil, false);
    }

    /**
      * Handle function of widget
      * @param op any operation to handle
      * @param save boolean true if op should lead to closing & saving widget
      * @return any changed op (if needed)
      */
    global define any handleOrderPopup (any op, boolean save) ``{
	string active = UI::QueryWidget (`id (`disks), `CurrentItem);
	integer pos = 0;
	while (pos < size (disks_order) && disks_order[pos]:"" != active)
	    pos = pos + 1;
	UI::ChangeWidget (`id (`up), `Enabled, pos > 0);
	UI::ChangeWidget (`id (`down), `Enabled, pos < size (disks_order) - 1);
	if (! save)
	{
	    if (op == `up)
	    {
		disks_order = BootCommon::swapItems (disks_order, pos, pos - 1);
		UI::ReplaceWidget (`id (`disks_rp), `SelectionBox(`id (`disks),
		    `opt (`notify, `immediate),
		    _("D&isks"), disks_order));
		UI::ChangeWidget (`id (`disks), `CurrentItem, active);
	    }
	    else if (op == `down)
	    {
		disks_order = BootCommon::swapItems (disks_order, pos, pos + 1);
		UI::ReplaceWidget (`id (`disks_rp), `SelectionBox(`id (`disks),
		    `opt (`notify, `immediate),
		    _("D&isks"), disks_order));
		UI::ChangeWidget (`id (`disks), `CurrentItem, active);
	    }
	    else if (op == `add)
	    {
		term popup = `VBox (`VSpacing (1),
		    // textentry header
		    `TextEntry (`id (`devname), _("&Device")),
		    `VSpacing (1),
		    `HBox (`HStretch (),
			`PushButton (`id (`ok), `opt (`key_F10, `default), Label::OKButton ()),
			`HStretch (),
			`PushButton (`id (`cancel), `opt (`key_F8), Label::CancelButton ()),
			`HStretch ()
		    ),
		    `VSpacing (1)
		);
		UI::OpenDialog (popup);
		symbol pushed = UI::UserInput ();
		string new_dev = UI::QueryWidget (`id (`devname), `Value);
		UI::CloseDialog ();
		if (pushed == `ok)
		{
		    disks_order = add (disks_order, new_dev);
		    UI::ReplaceWidget (`id (`disks_rp),
			`SelectionBox(`id (`disks),
			    `opt (`notify, `immediate),
			    _("D&isks"), disks_order));
		}
	    }
	    else if (op == `delete)
	    {
		disks_order = filter (`i, disks_order, ``(i != active));
		UI::ReplaceWidget (`id (`disks_rp), `SelectionBox(`id (`disks),
                    `opt (`notify, `immediate),
                    _("D&isks"), disks_order));
		UI::ChangeWidget (`id (`delete), `Enabled, size (disks_order) > 0);
		UI::ChangeWidget (`id (`disks),`CurrentItem, disks_order[0]:"");
	    }

	}
	else
	{

            list(list(string)) dl = filter (list(string) i, device_map,
                ``(substring (i[0]:"", 0, 3) == "(hd"));
            dl=sort (list(string) a, list(string) b, dl, ``(a[0]:"" < b[0]:""));

	    map olddiskmap = $[];
	    foreach (list(string) d, dl, ``{
		olddiskmap[d[1]:""] = d[0]:"";
	    });
	    map remap = $[];
	    integer pos = 0;
	    list new_map = filter (list(string) i, device_map,
		``(substring (i[0]:"", 0, 3) != "(hd"));
	    foreach (`d, disks_order, ``{
		string gd = sformat ("(hd%1)", pos);
		if (gd != olddiskmap[d]:"")
		{
		    remap[olddiskmap[d]:""] = gd;
		}
		new_map = add (new_map, [gd, d]);
		pos = pos + 1;
	    });
	    list glob = BootCommon::current_globals;
	    glob = BootGRUB::remapDisks (glob, remap);
	    BootCommon::current_globals = glob;
	    list sects = BootCommon::current_sections;
	    sects = maplist (`s, sects, ``{
		return BootGRUB::remapDisks (s, remap);
	    });
	    BootCommon::current_sections = sects;
	    BootCommon::current_section = BootGRUB::remapDisks (
		BootCommon::current_section, remap);
	    list gcl = maplist (`k, `v, BootGRUB::grub_conf, ``(
		$[ "key" : k, "value" : v]));
	    gcl = BootGRUB::remapDisks (gcl, remap);
	    BootGRUB::grub_conf = listmap (`e, gcl, ``(
		[e["key"]:"", e["value"]:""]));
	    BootGRUB::device_map = new_map;
	    BootCommon::mbrDisk = disks_order[0]:BootCommon::mbrDisk;
	    BootCommon::loader_device = BootCommon::GetBootloaderDevice ();
	    disks_order = nil;
	}
	UI::SetFocus (`id (`disks));
	return nil;
    }

    /**
      * Get map of widget
      * @return map of widget
      */
    global define map getGfxMenuWidget () ``{
	return $[
	    "handle" : ``(BootGRUB::gfxMenuHandle ()),
	    "delete" : ``(BootCommon::deleteMessage ()),
	    "key_only_once" : true,
	];
    }

    /**
      * Handle function of widget
      * @param op any operation to handle
      * @param save boolean true if op should lead to closing & saving widget
      * @return any changed op (if needed)
      */
    global define any gfxMenuHandle (any op, boolean save) ``{
	if (! save)
	    return nil;
	BootCommon::current_section = setValueByIndex (
	    BootCommon::current_section, -1,
	    BootCommon::current_option_name,
	    UI::QueryWidget (`id (`value), `Value));

	map intern = lookup_value (BootCommon::current_section,
	    "__intern__", $[]);
	intern["changed"] = true;
	BootCommon::addValueToBootloaderSection (
	    `current_section, "__intern__", intern);
	y2error ("Final current section: %1", BootCommon::current_section);
	return nil;
    }

    /**
      * Get map of widget
      * @return map of widget
      */
    global define map getSingleSectionWidget () ``{
	map ret = BootCommon::getSingleSectionWidget ();
        ret["widget"] = `HBox (ret["widget"]:`VSpacing (0),
            `VBox (
                `VStretch (),
                `PushButton (`id (`up), _("&Up")),
                `PushButton (`id (`down), _("&Down")),
                `VStretch ()
            ),
            `HSpacing (1)
        );
	return ret;
    }

    /**
      * Get map of widget
      * @return map of widget
      */
    global define map getAddOrigMbrWidget () ``{
	return $[
	    "restore" : ``(BootGRUB::addOrigMbrRestore ()),
	    "handle" : ``(BootGRUB::addOrigMbrSave ()),
	    "type" : "b",
	    "help" : "",//TODO BootGRUB::addOrigMbrHelp (),
	    "exits" : [],
	    // table item / label
	    "label" : _("Add saved MBR to bootloader menu"),
	    "summary" : ``(BootGRUB::addOrigMbrSummary ()),
	    "deletable" : false,
	    "ordering" : false,
	    "key_only_once" : true,
	];
    }

    /**
      * Restore function of widget
      */
    global define void addOrigMbrRestore () ``{
        UI::ChangeWidget (`id (`value), `Value, insert_saved_mbr);
        UI::SetFocus (`id (`value));
    }

    /**
      * Handle function of widget
      * @param op any operation to handle
      * @param save boolean true if op should lead to closing & saving widget
      * @return any changed op (if needed)
      */
    global define any addOrigMbrSave (any op, boolean save) ``{
        if (! save)
            return nil;
        insert_saved_mbr = UI::QueryWidget (`id (`value), `Value);
	if (insert_saved_mbr)
	{
	    boolean found = false;
	    foreach (`s, BootCommon::sections, ``{
		if (lookup (lookup_value (s, "__intern__", $[]), "original_mbr", false))
		{
		    found = true;
		    y2error ("Found %1", s);
		}
	    });
	    if (! found)
	    {
		BootCommon::current_sections = add (
		    BootCommon::current_sections,
		    createLinuxSection ("original MBR"));
	    }
	}
	else
	{
	    BootCommon::current_sections = filter (`s,
		BootCommon::current_sections, ``(
		! lookup (lookup_value (s, "__intern__", $[]), "original_mbr", false)));
	}
        return nil;
    }

    /**
      * Summary function for option
      * @return string summary text
      */
    global define string addOrigMbrSummary () ``{
        if (insert_saved_mbr)
            // table item / label
            return _("Yes");
        else
            // table item / label
            return _("No");
    }

}
