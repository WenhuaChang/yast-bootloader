/**
 * File:
 *      include/bootloader/routines/widgets_ppc.ycp
 *
 * Module:
 *      Bootloader installation and configuration
 *
 * Summary:
 *      Widgets for being used by bootloader for PowerPC
 *
 * Authors:
 *      Jiri Srain <jsrain@suse.cz>
 *      Joachim Plack <jplack@suse.de>
 *
 * $Id$
 *
 */


{

textdomain "bootloader";

include "bootloader/routines/popups.ycp";

import "StorageDevices";

/**
 * Init function of widget
 * @param widget string id of the widget
 */
void InitBootMenu (string widget) {
    boolean timeout_active = haskey (BootCommon::globals, "timeout");
    UI::ChangeWidget (`id (`timeout_act), `Value, timeout_active);
    UI::ChangeWidget (`id (`timeout), `Enabled, timeout_active);
    integer timeout = tointeger (BootCommon::globals["timeout"]:"0");
    UI::ChangeWidget (`id (`timeout), `Value, timeout);
}

/**
 * Store function of a widget
 * @param widget string widget key
 * @param event map event that caused the operation
 */
void StoreBootMenu (string widget, map event) {
    integer timeout = (integer)UI::QueryWidget (`id (`timeout), `Value);
    boolean timeout_act = (boolean)UI::QueryWidget (`id (`timeout_act), `Value);
    if (timeout_act)
	BootCommon::globals["timeout"] = sformat ("%1", timeout);
    else if (haskey (BootCommon::globals, "timeout"))
	BootCommon::globals = remove (BootCommon::globals, "timeout");
}

/**
 * Handle function of a widget
 * @param key any widget key
 * @param event map event description of event that occured
 * @return symbol always nil
 */
symbol HandleBootMenu (string key, map event) {
    boolean active = (boolean)UI::QueryWidget (`id (`timeout_act), `Value);
    UI::ChangeWidget (`id (`timeout), `Enabled, active);
    return nil;
}

/**
 * Build a map describing a widget
 * @return a map describing a widget
 */
map<string,any> BootMenuWidget () {
    return $[
	"widget" : `custom,
	// frame
	"custom_widget" : `Frame (_("Boot Menu PPC"), `HBox (
	    `HSpacing (2), `VBox (
		`VSpacing (0.4),
		// check box
		`Left (`CheckBox (`id (`timeout_act), `opt (`notify),
		    // check box
		    _("&Continue Booting after a Time-Out"))),
		// integer field
		`IntField (`id (`timeout), _("Boot &Menu Time-Out"), 0, 60, 0),
		`VSpacing (0.4)
	    ), `HSpacing (2)
	)),
	"init" : InitBootMenu,
	"store" : StoreBootMenu,
	"handle" : HandleBootMenu,
	"handle_events" : [ `timeout_act ],
	"help" : ppcBootMenuHelp (),
    ];
}

/**
 * Init function of widget
 * @param widget string id of the widget
 */
void InitPasswdWidget (string widget) {
    string passwd = BootCommon::globals["password"]:"";
    if (passwd == nil || passwd == "")
    {
	UI::ChangeWidget (`id (`use_pas), `Value, false);
	UI::ChangeWidget (`id (`pw1), `Enabled, false);
	UI::ChangeWidget (`id (`pw1), `Value, "");
	UI::ChangeWidget (`id (`pw2), `Enabled, false);
	UI::ChangeWidget (`id (`pw2), `Value, "");
    }
    else
    {
	UI::ChangeWidget (`id (`use_pas), `Value, true);
	UI::ChangeWidget (`id (`pw1), `Enabled, true);
	UI::ChangeWidget (`id (`pw1), `Value, "**********");
	UI::ChangeWidget (`id (`pw2), `Enabled, true);
	UI::ChangeWidget (`id (`pw2), `Value, "**********");
    }
    UI::SetFocus (`id (`use_pas));
}

/**
 * Handle function of a widget
 * @param widget string id of the widget
 * @param event map event description of event that occured
 * @return symbol always nil
 */
symbol HandlePasswdWidget (string widget, map event) {
    if (event["ID"]:nil == `use_pas)
    {
	boolean enabled = (boolean)UI::QueryWidget (`id (`use_pas), `Value);
	UI::ChangeWidget (`id (`pw1), `Enabled, enabled);
	UI::ChangeWidget (`id (`pw2), `Enabled, enabled);
    }
    return nil;
}

/**
 * Store function of a popup
 * @param key any widget key
 * @param event map event that caused the operation
 */
void StorePasswdWidget (string key, map event) {
    string password = nil;
    boolean usepass = (boolean)UI::QueryWidget (`id (`use_pas), `Value);
    y2milestone ("Usepass: %1", usepass);
    if (usepass)
    {
	if (UI::QueryWidget (`id (`pw1), `Value) != "**********")
	{
	    password = (string)UI::QueryWidget (`id (`pw1), `Value);
	    if (haskey (BootCommon::current_bootloader_attribs,
		"update_passwd"))
	    {
		string(string) f = (string(string))
		    BootCommon::current_bootloader_attribs[
			"update_passwd"]:nil;
		password = f (password);
	    }
	    BootCommon::globals["password"] = password;
	}
    }
    else if (haskey (BootCommon::globals, "password"))
    {
	BootCommon::globals = remove (BootCommon::globals, "password");
    }
    return nil;
}


/**
 * Validate function of a popup
 * @param key any widget key
 * @param event map event that caused validation
 * @return boolean true if widget settings ok
 */
boolean ValidatePasswdWidget (string key, map event) {
    if (! (boolean)UI::QueryWidget (`id (`use_pas), `Value))
	return true;
    if (UI::QueryWidget (`id (`pw1), `Value) == "")
    {
	emptyPasswdErrorPopup ();
	UI::SetFocus (`id (`pw1));
	return false;
    }
    if (UI::QueryWidget (`id (`pw1), `Value)
	== UI::QueryWidget (`id (`pw2), `Value)
    )
	return true;
    passwdMissmatchPopup ();
    UI::SetFocus (`id (`pw1));
    return false;
}



/**
 * Build a map describing a widget
 * @return a map describing a widget
 */
map<string,any> PasswordWidget () {
    return $[
	"widget" : `custom,
	// frame
	"custom_widget" : `Frame (_("Password Protection"), `VBox (
	    `VSpacing (0.4),
	    `HBox (
		`HSpacing (2), `VBox (
		    `Left (`CheckBox (`id (`use_pas), `opt (`notify),
			// check box
			_("Prot&ect Boot Loader with Password"))),
		    `HBox (
			// text entry
			`Password (`id (`pw1), _("&Password")),
			// text entry
			`Password (`id (`pw2), _("Re&type Password"))
		    )
		), `HSpacing (2)
	    ),
	    `VSpacing (0.4)
	)),
	"init" : InitPasswdWidget,
	"handle" : HandlePasswdWidget,
	"store" : StorePasswdWidget,
	"validate_type" : `function,
	"validate_function" : ValidatePasswdWidget,
	"help" : ppcPasswdHelp (),
    ];
}


// loader target widget

/**
 * Get the target widget to be displayed
 * @return term widget to be displayed
 */
term TargetWidget () {
    term targetlist = `VBox ();

    list<string> boot_devices = BootCommon::getPartitionList(`boot);
    boolean allow_boot = contains (boot_devices,
	BootCommon::BootPartitionDevice);
    boolean allow_root = contains (boot_devices,
	BootCommon::RootPartitionDevice);
    boolean all_mbr = size (BootCommon::Md2Partitions (
	BootCommon::BootPartitionDevice)) > 1;

    
    if (! Arch::ppc ())
    {
        targetlist = add(targetlist,`VBox (
	`VSpacing (0.4),
	`Left (`RadioButton (`id ("mbr"), `opt (`notify),
		BootCommon::mbrDisk == ""
		    // radio button
		    ? _("&Master Boot Record")
		    // radiobutton, %1 is device (eg. /dev/hda)
		    : sformat(_("&Master Boot Record of %1"),
			BootCommon::mbrDisk),
                (BootCommon::selected_location == "mbr")
	))
        ));
    }

    if (allow_boot)
    {
	    targetlist = add (targetlist, `VSpacing (0.4));
            targetlist = add (targetlist, `Left (
		`RadioButton (`id ("boot"), `opt (`notify),
		// radiobutton, %1 is device (eg. /dev/hda1)
                sformat(_("Boot &Sector of Boot Partition %1"),
                     BootCommon::BootPartitionDevice),
                (BootCommon::selected_location == "boot")
            )));
    };
    if (allow_root
	&& BootCommon::BootPartitionDevice != BootCommon::RootPartitionDevice)
    {
	    targetlist = add (targetlist, `VSpacing (0.4));
	    targetlist = add (targetlist, `Left (
		`RadioButton (`id ("root"), `opt (`notify),
		// radiobutton, %1 is device (eg. /dev/hda1)
                sformat(_("Boot Sector of Roo&t Partition %1"),
                    BootCommon::RootPartitionDevice),
                (BootCommon::selected_location == "root")
            )));
    };

    if (StorageDevices::FloppyPresent && ! Arch::ppc())
    {
            targetlist = add (targetlist, `VSpacing (1));
            targetlist = add (targetlist, `Left (`RadioButton (`id ("floppy"),
		 `opt (`notify),
		// radiobutton, %1 is device name, typically /dev/fd0
                sformat (_("&Floppy Disk %1"), StorageDevices::FloppyDevice),
                (BootCommon::selected_location == "floppy")
            )));
    }
    if (Arch::ppc())
    {
	// TODO: add list of PReP partitions here ...
    }

    targetlist = add (targetlist, `HBox (
            `VBox (`Label (""), `RadioButton (`id ("custom"), `opt (`notify),
		// radiobutton
		_("Ot&her"),
                (BootCommon::selected_location == "custom"))),
            `HSpacing (2),
            `VBox (
                `ComboBox (`id (`loc), `opt (`editable, `hstretch, `notify), "",
		    boot_devices),
                `HSpacing (15)
            ),
            `HStretch ()
    ));

    targetlist = add (targetlist, `VSpacing (0.4));

    // frame
    term widget = `Frame (_("Boot Loader Location"),
	`RadioButtonGroup (`id (`location),
	    targetlist
	)
    );
    return widget;
}

/**
 * Init function of a widget
 * @param widget string widget key
 */
void TargetInit (string widget) {
    if (BootCommon::BootPartitionDevice == BootCommon::RootPartitionDevice
	&& BootCommon::selected_location == "root")
    {
	BootCommon::selected_location = "boot";
    }
    if (BootCommon::loader_device != "mbr_md")
    UI::ChangeWidget (`id (`loc), `Value, BootCommon::loader_device == "mbr_md"
	? BootCommon::getPartitionList(`boot)[0]:""
	: BootCommon::loader_device);
    UI::ChangeWidget (`id (`location), `CurrentButton,
	BootCommon::selected_location);
    UI::SetFocus (`id (`loc));
}

/**
 * Store function of a widget
 * @param widget string widget key
 * @param event map event that caused the operation
 */
void TargetStore (string widget, map event) {
    BootCommon::selected_location = (string)
	UI::QueryWidget (`id (`location), `CurrentButton);
    BootCommon::loader_device = (string)UI::QueryWidget (`id (`loc), `Value);
    BootCommon::loader_device = BootCommon::GetBootloaderDevice ();
    BootCommon::location_changed = true;
    BootCommon::changed = true;
}

/**
 * Validate function of a widget
 * @param widget string widget key
 * @param event map event that caused validation
 * @return boolean true if validation succeeded
 */
boolean TargetValidate (string widget, map event){
    string rb = (string)UI::QueryWidget (`id (`location), `CurrentButton);
    if (rb == nil)
    {
	setLocationErrorPopup ();
	UI::SetFocus (`id (`location));
	return false;
    }
    if (rb == "custom" && UI::QueryWidget (`id (`loc), `Value) == "")
    {
	setLocationErrorPopup ();
	UI::SetFocus (`id (`loc));
	return false;
    }
    if (rb == "custom")
    {
	boolean ok = true;
	string ld = (string)UI::QueryWidget (`id (`loc), `Value);
	map<string,map> tm = Storage::GetTargetMap ();
	foreach (string disk_dev, map disk, tm, {
	    list<map<string,any> > partitions
		= (list<map<string,any> >) disk["partitions"]:[];
	    foreach (map<string,any> p, partitions, {
		if (! p["delete"]:false)
		{
		    symbol fs = (symbol)(p["used_fs"]:p["detected_fs"]:nil);
		    // FIXME this checking is performed on 3 places
		    if (p["device"]:"" == ld && fs == `xfs)
		    {
			// yes-no popup
			if (! Popup::YesNo (_("The partition selected for boot loader installation
does not have enough free space in its boot sector
to hold the boot loader because of the file system
it contains. Using this partition for the boot loader
may lead to corruption of data on the partition.

Continue?")))
			{
			    UI::SetFocus (`id (`loc));
			    ok = false;
			}
		    }
		}
	    });
	});
	if (! ok)
	    return false;
    }
    return true;
}

/**
 * Cache for ppcWidgets function
 */
map<string,map<string,any> > _ppc_widgets = nil;

/**
 * Get widgets specific for ppc
 * @return a map describing all ppc-specific widgets
 */
map<string,map<string,any> > ppcWidgets () {
    if (_ppc_widgets == nil)
    {
	_ppc_widgets = $[
	    "boot_menu" : BootMenuWidget (),
	    "password" : PasswordWidget (),
	    "loader_location" : $[
		"widget" : `func,
		"widget_func" : TargetWidget,
		"init" : TargetInit,
		"store" : TargetStore,
		"help" : " ",
		"validate_type" : `function,
		"validate_function" : TargetValidate,
	    ],
	];
    }
    return _ppc_widgets;
}


} // include end
