/**
 * File:
 *      bootloader/ppc/iSeries.ycp
 *
 * Module:
 *      Bootloader installation and configuration
 *
 * Summary:
 *      include containing specific functions for iSeries configuration
 *      and installation
 *
 * Authors:
 *      Jiri Srain <jsrain@suse.cz>
 *
 * $Id$
 *
 */

{
    textdomain "bootloader";

    import "Kernel";
    import "Storage";
    import "Arch";
    import "Installation";
    import "Mode";

    import "BootCommon";
    import "BootPPC";

    include "bootloader/ppc/widgets.ycp";
    include "bootloader/ppc/misc.ycp";
    include "bootloader/routines/popups.ycp";



// general functions

    /**
      * Propose bootloader settings
      * @param initial boolean true if doing initial proposal
      */
    global define void iSeriesPropose (boolean initial) ``{
	if (BootCommon::was_proposed)
	{
	    return;
	}

        y2milestone("BootPPC::Proposal: BootCommon::loader_device %1", BootCommon::loader_device);

	iseries_write_slot_a = true;
	iseries_write_slot_b = true;
	iseries_write_prepboot = true;
	iseries_write_streamfile = true;
	if ( ! (size (prep_boot_partitions) > 0 ||
	    (prep_boot_partition != "" && prep_boot_partition != "/dev/null")))
	{
	    iseries_write_prepboot = false;
	}

	iSeriesAssignDevice ();
    }

    /**
      * Read the board-type-specific settings
      * @return boolean true on success
      */
    global define boolean iSeriesRead () ``{
// FIXME I should be able to live witout sysconfig
/*	iseries_write_slot_b = ! (SCR::Read (
	    .sysconfig.bootloader.ISERIES_WRITE_SLOT_B) == "no");
	iseries_write_slot_a = ! (SCR::Read (
	    .sysconfig.bootloader.ISERIES_WRITE_SLOT_A) == "no");
	if (nil != SCR::Read (.sysconfig.bootloader.ISERIES_STREAMFILE))
	{
	    iseries_streamfile = SCR::Read (
		.sysconfig.bootloader.ISERIES_STREAMFILE);
	}
	iseries_write_streamfile = ! (SCR::Read (
	    .sysconfig.bootloader.ISERIES_WRITE_STREAMFILE) == "no");
	if (nil != SCR::Read (.sysconfig.bootloader.PREP_BOOT_PARTITION))
	{
	    prep_boot_partition = SCR::Read (
		.sysconfig.bootloader.PREP_BOOT_PARTITION);
	}
	iseries_write_prepboot =  ! (SCR::Read (
	    .sysconfig.bootloader.ISERIES_WRITE_PREPBOOT) == "no");*/
    }

    /**
      * Save the board-type-specific settings
      * @return boolean true on success
      */
    global define boolean iSeriesSave () ``{
// FIXME I should be able to live witout sysconfig
/*	SCR::Write (.sysconfig.bootloader.ISERIES_WRITE_SLOT_B,
	    iseries_write_slot_b ? "yes" : "no");
	SCR::Write (.sysconfig.bootloader.ISERIES_WRITE_SLOT_A,
	    iseries_write_slot_a ? "yes" : "no");
	SCR::Write (.sysconfig.bootloader.ISERIES_WRITE_STREAMFILE,
	    iseries_write_streamfile ? "yes" : "no");
	SCR::Write (.sysconfig.bootloader.ISERIES_WRITE_PREPBOOT,
	    iseries_write_prepboot ? "yes" : "no");
	SCR::Write (.sysconfig.bootloader.ISERIES_STREAMFILE,
	    iseries_streamfile);
	SCR::Write (.sysconfig.bootloader.PREP_BOOT_PARTITION,
	    prep_boot_partition);
	SCR::Write (.sysconfig.bootloader, nil);*/
    }

    /**
      * retuen the board-type-specific part of summary
      * @return a list of summary strings
      */
    global define list iSeriesSummary () ``{
	list ret = [];
	if ( iseries_write_streamfile )
	{
	    ret = add (ret, sformat (
		// summary part, %1 is filename
		_("A stream file will be written to %1. Copy this file to OS400 side and boot with *STMF."),
		iseries_streamfile));
	}

	if ( iseries_write_prepboot )
	{
	    ret = add (ret, sformat(
		// summary part, %1 is filename
		_("The kernel will be written to %1. Use *NWSSTG on OS400 side."),
		BootCommon::loader_device));
	}

	if ( iseries_write_slot_b )
	{
	    // summary part
	    ret = add (ret, _("The kernel will be written to slot B."));
	}

	if ( iseries_write_slot_a )
	{
	    // summary part
	    ret = add (ret, ("A rescue kernel will be written to slot A."));
	}

	if ( iseries_write_slot_a || iseries_write_slot_b )
	{
	    // summarry part
	    ret = add (ret, _("This will take a while..."));
	}
	if ( BootCommon::activate == false )
	{
	    // summary part
	    ret = [
		_("No boot configuration. Configure booting manually.")
	    ];
	}
	if (! (iseries_write_prepboot || iseries_write_slot_b
	    || iseries_write_slot_a || iseries_write_streamfile))
	{
	    // summary part
	    ret = [ _("No boot option selected.") ];
	}
	y2milestone("prep_boot_partitions %1", prep_boot_partitions);
	return ret;
    }

    /**
      * Install the board-type-specific part of bootloader
      * @param requires_initrd boolean true if initrd is required
      * @return boolean true on success
      */
    global define boolean iSeriesWrite (boolean requires_initrd) ``{
	if (! BootCommon::activate)
	    return true;
	string iseries_bootbinary = "/boot/vmlinux64";
	if (requires_initrd)
	{
	    iseries_bootbinary = "/tmp/vmlinux64.initrd"; // FIXME security problem
	    SCR::Execute (.target.bash, "/bin/addRamDisk64 /boot/initrd $(rpm -ql kernel-iseries64 | grep ^/lib/modules/.\\\*/System.map$)  $(rpm -ql kernel-iseries64 | grep ^/lib/modules/.\\\*/vmlinux$) " + iseries_bootbinary + " >> /var/log/YaST2/y2loglilo_iseries_bootbinary 2>&1 " );
	}
	if ( iseries_write_slot_a )
	{
	    y2milestone("start writing rescue kernel to slot A ...");
	    SCR::Execute (.target.bash, "time dd if=`rpm -ql kernel-iseries64 | grep ^/boot | grep install | head -n1` of=/proc/iSeries/mf/A/vmlinux bs=4096 >>/var/log/YaST2/y2loglilo_iseries_slot_a 2>&1 ");
	    SCR::Execute (.target.bash, "dd if=/dev/zero of=/proc/iSeries/mf/A/cmdline bs=255 count=1");
	    SCR::Execute (.target.bash, "echo 'start_shell manual=1' > /proc/iSeries/mf/A/cmdline");
	    y2milestone("done writing rescue kernel to slot A.");
	}
	if ( iseries_write_slot_b )
	{
	    if ( boot_device == "B" )
	    {
		y2milestone("lilo will write the kernel to slot B. B is now activated");
		SCR::Execute (.target.bash, "echo B > /proc/iSeries/mf/side");
	    }
	    else
	    {
		y2milestone("start writing boot kernel to slot B ...");
		SCR::Execute (.target.bash, "time dd if=" + iseries_bootbinary + " of=/proc/iSeries/mf/B/vmlinux bs=4096 >>/var/log/YaST2/y2loglilo_iseries_slot_b 2>&1 ");
		SCR::Execute (.target.bash, "echo '" + root_device + " " + Kernel::cmdLine + "' > /proc/iSeries/mf/B/cmdline");
		SCR::Execute (.target.bash, "echo B > /proc/iSeries/mf/side");
		y2milestone("done writing boot kernel to slot B.");
	    }
	}
	if ( iseries_write_streamfile )
	{
	    y2milestone("create *STMF file %1 from %2", iseries_streamfile, iseries_bootbinary);
	    SCR::Execute (.target.bash, "cd / ; cp -av " + iseries_bootbinary + " " + iseries_streamfile);
	}
	if ( iseries_write_prepboot && size (prep_boot_partitions) > 0 )
	{
	    y2milestone("*NWSSTG: write %1 to %2", iseries_bootbinary, prep_boot_partitions[boot_partition]:"/dev/null");
	    SCR::Execute (.target.bash, "test -b " +
	    prep_boot_partitions[boot_partition]:"/dev/null" +
		" && dd if=" + iseries_bootbinary + " bs=4096 of=" +
		prep_boot_partitions[boot_partition]:"/dev/null"
	    );
	}
    }

    /**
      * Initialize attributes of the board type
      */
    global define void iSeriesInit () ``{
	y2milestone ("Initializing iSeries attributes");
	prep_only_active = true;
	prep_only_hdx = true;
	prep_only_primary = true;
	prep_same_disk_as_root = false;
	table_items = [ "__iseries_location" ];
    }

    /**
      * Assign the Boot::loader_device variable
      */
    global define void iSeriesAssignDevice () ``{
	// the last entry wins
	BootCommon::loader_device = "";
	if (iseries_write_streamfile)
	{
	    BootCommon::loader_device = iseries_streamfile;
	}

	if (iseries_write_prepboot)
	{
	    BootCommon::loader_device = prep_boot_partition;
	}

	if ( iseries_write_slot_b )
	{
	    BootCommon::loader_device = "B";
	}
	if ( !  ( iseries_write_prepboot ||
	    iseries_write_slot_b   ||
	    iseries_write_slot_a   ||
	    iseries_write_streamfile ) )
	{
	    BootCommon::activate = false;
	}
	else
	{
	    BootCommon::activate = true;
	}

    }


} // EOF
