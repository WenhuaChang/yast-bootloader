/**
 * File:
 *      include/bootloader/routines/routines.ycp
 *
 * Module:
 *      Bootloader installation and configuration
 *
 * Summary:
 *      Several routines not using any variable of any module
 *
 * Authors:
 *      Jiri Srain <jsrain@suse.cz>
 *
 * $Id$
 *
 */



{

    textdomain "bootloader";

    import "BootCommon";

    /**
      * Get value of some key in bootloader section
      * @param section list representating bootloader section
      * @param key string key of requested parameter
      * @param default any default value to be returned if key not present
      * @return any found key
      */
    global define any lookup_value (list section, string key,
	any default)
    ``{
	any ret = default;
	foreach (map m, section, ``{
	    if (m["key"]:"" == key)
		ret = m["value"]:default;
	});
	return ret;
    }

    /**
      * Get map describing value from section
      * @param section list representating bootloader section
      * @param key string key of requested parameter
      * @return map of option, empty map if not found
      */
    global define map getValueMap (list section, string key) ``{
	map ret = $[];
        foreach (map m, section, ``{
            if (m["key"]:"" == key)
                ret = m;
        });
        return ret;
    }

    /**
      * Append key with appropriate value to the end of the section
      * @param section list section list
      * @param key string key name
      * @param value any value to specified key
      * @return list modified section
      */
    global define list appendValue (list section, string key, any value) ``{
	map m = $[ "key" : key, "value" : value, "changed" : true];
	return add (section, m);
    }

    /**
      * Lookup at value of entry with specified index in the section
      * @param section list section list
      * @param index integer index of entry in section
      * @param default any to be returned if specified entry not present
      * @return any value of specified entry of PPD file
      */
    global define any lookupValueByIndex (list section, integer index,
	any default)
    ``{
	return section[index, "value"]:default;
    }

    /**
      * Replace first occurence of option with specified value,
      *   remove other occurences, add if no occurence present
      * @param section list of section to be changed
      * @param key string key of requested parameter
      * @param value any value to be set, nil for removing key
      * @return list modified section
      */
    global define list modifySection (list section, string key, any value) ``{
	boolean found = false;
        section = filter (map cc,
            maplist (map c, section, ``{
                if (c["key"]:"" == key)
                {
		    found = true;
                    if (value == nil)
                        return nil;
                    else
                    {
                        c["value"] = value;
			c["changed"] = true;
			value = nil;
                        return c;
                    }
                }
                return c;
            }), ``(cc != nil && cc["value"]:"" != nil)
        );
	if (! found && value != nil)
	{
	    section = add (section, $[ "key" : key, "value" : value,
		"changed" : true]);
	}
	return section;
    }

    /**
      * Set value to the section
      * @param section list representing bootloader section
      * @param index index of the value, -1 = unknown, -2 = new option
      * @param key string option key
      * @param value any option value
      * @return list updated bootloader section
      */
    global define list setValueByIndex (list section, integer index, string key,
	any value)
    ``{
	if (index < 0)
	{
	    if (index == -1)
	    {
		return modifySection (section, key, value);
	    }
	    else if (index == -2)
	    {
		return appendValue (section, key, value);
	    }
	    y2error ("Incorrect index");
	    return section;
	}
	else
	{
	    section[index, "value"] = value;
	    section[index, "changed"] = true;
	    return section;
	}
    }

    /**
      * Create translated name of a section
      * @param orig string original section name
      * @return translated section name
      */
    global define string translateSectionTitle (string orig) ``{
        map trans = $[
	    // entry of bootloader menu - only a-z, A-Z, 0-9, _ and blank space
	    // are allowed, otherwise translartion won't be used
	    // try to keep short, may be shortened due to bootloader limitations
            "linux" : _("Linux"),
	    // entry of bootloader menu - only a-z, A-Z, 0-9, _ and blank space
	    // are allowed, otherwise translartion won't be used
	    // try to keep short, may be shortened due to bootloader limitations
            "failsafe" : _("Failsafe"),
	    // entry of bootloader menu - only a-z, A-Z, 0-9, _ and blank space
	    // are allowed, otherwise translartion won't be used
	    // try to keep short, may be shortened due to bootloader limitations
            "floppy" : _("Floppy"),
	    // entry of bootloader menu - only a-z, A-Z, 0-9, _ and blank space
	    // are allowed, otherwise translartion won't be used
	    // try to keep short, may be shortened due to bootloader limitations
            "hard disk" : _("Hard Disk"),
	    // entry of bootloader menu - only a-z, A-Z, 0-9, _ and blank space
	    // are allowed, otherwise translartion won't be used
	    // try to keep short, may be shortened due to bootloader limitations
            "memtest86" : _("Memory Test"),
	    // entry of bootloader menu - only a-z, A-Z, 0-9, _ and blank space
	    // are allowed, otherwise translartion won't be used
	    // try to keep short, may be shortened due to bootloader limitations
            "original MBR" : _("MBR before Installation"),
        ];
        map not_trans = $[
            "linux" : "Linux",
            "failsafe" : "Failsafe",
            "floppy" : "Floppy",
            "hard disk" : "Hard Disk",
            "memtest86" : "Memory Test",
            "original MBR" : "MBR before Installation",
            "windows" : "Windows",
        ];
	string translated = trans[orig]:"\n"; // not allowed character
		// not_translated version will be used
	string filtered = filterchars (translated, "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890 _");
	if (size (filtered) != size (translated))
	{
	    y2warning ("Incorrect translation %1 -> %2", orig, translated);
	    return not_trans[orig]:orig;
	}
	if (BootCommon::getLoaderType (false) != "grub")
	{
	    filtered = mergestring (splitstring (filtered, " "), "_");
	    if (size (filtered) > 15)
		filtered = substring (filtered, 0, 15);
	}
	return filtered;
    }

    /**
      * Get creator type of the section
      * @param section map section description structure
      * @return string section type
      */
    global define string getCreationType (list section) ``{
	map intern = (map) lookup_value (section, "__intern__", $[]);
	return intern["type"]:"";
    }


}
