/**
 * File:
 *      include/bootloader/routines/options.ycp
 *
 * Module:
 *      Bootloader installation and configuration
 *
 * Summary:
 *      Table options and popups for being used by several bootloaders
 *
 * Authors:
 *      Jiri Srain <jsrain@suse.cz>
 *
 * $Id$
 *
 */


{

    textdomain "bootloader";

    import "Label";
    import "BootCommon";
    import "Mode";
    import "Storage";
    import "StorageDevices";
    include "bootloader/routines/popups.ycp";

    global define map GetOptionMaps () ``{
	return union (generateOptionMaps (), $[
	    "__location"	: BootCommon::getTargetOption (),
	    "__loader_type"	: BootCommon::getLoaderSelectionWidget (),
	    "__sections"	: BootCommon::getSectionsTableEntry (),
	    "default"		: BootCommon::getDefaultSectionTableEntry (),
	    "__section_type"	: BootCommon::getSectionTypeWidget (),
	    "__save_method"	: BootCommon::getSaveMethod (),
	    "__backup_mbr"	: BootCommon::getBackupMbrWidget (),
	    "label"		: BootCommon::getLabelWidget (),
	    "alias"		: BootCommon::getAliasWidget (),
	    "timeout"		: BootCommon::getTimeoutWidget (),
	    "password"		: BootCommon::getPasswdWidget (),
	    "__repl_mbr"	: BootCommon::getReplMbrWidget (),
	    "__activate"	: BootCommon::getActivateWidget (),
	    "message"		: BootCommon::getMessageWidget (),
	]);
    }

    global define map generateOptionMaps () ``{
	map types = BootCommon::opttypes ();
	map type2widget = $[
	    "b" : `checkbox,
	    "i" : `intfield,
	];
	map created_widgets = mapmap (`k, `v, types, ``{
	    symbol w = type2widget[v]:`textentry;
	    return [k, $["popup" : $["widget" : w]]];
	});
	return created_widgets;
    }


// Bootloader target widget

    /**
      * Get map of Target widget
      * @return map of Target widget
      */
    global define map getTargetOption () ``{
	return $[
	    "table" : $[
		// table cell / label
		"label" : _("Boot Loader Location"),
		"summary" : ``(BootCommon::targetSummary ()),
		"optional" : false,
		"ordering" : false,
		"key_only_once" : true,
	    ],
	    "popup" : $[
		"widget" : `func,
		"widget_func" : ``(BootCommon::getTargetWidget ()),
		"init" : ``(BootCommon::targetInit ()),
		"store" : ``(BootCommon::targetStore ()),
//		"help" : getLocationsHelp (),
		"validate_type" : `function,
		"validate_function" : ``(BootCommon::targetValidate ()),
	    ],
	];
    }

    global define term getTargetWidget () ``{
        term targetlist = `VBox (
            `VSpacing (0.4),
            `Left (`RadioButton (`id ("mbr"), `opt (`notify),
		// radiobutton, %1 is device (eg. /dev/hda)
                sformat(_("&Master boot record of %1"), mbrDisk),
                (location == "mbr")
            )),
            `VSpacing (0.4),
            `Left (`RadioButton (`id ("boot"), `opt (`notify),
		// radiobutton, %1 is device (eg. /dev/hda1)
                sformat(_("Boot &Sector of Boot Partition %1"),
                     BootCommon::getDeviceOfRaid (BootPartitionDevice)),
                (location == "boot")
            ))
	);
	if (BootPartitionDevice != RootPartitionDevice)
	{
	    targetlist = add (targetlist, `VSpacing (0.4));
	    targetlist = add (targetlist, `Left (
		`RadioButton (`id ("root"), `opt (`notify),
		// radiobutton, %1 is device (eg. /dev/hda1)
                sformat(_("Boot Sector of Roo&t Partition %1"),
                    BootCommon::getDeviceOfRaid (RootPartitionDevice)),
                (location == "root")
            )));
        };

        if (StorageDevices::FloppyPresent)
        {
            targetlist = add (targetlist, `VSpacing (1));
            targetlist = add (targetlist, `Left (`RadioButton (`id ("floppy"),
		 `opt (`notify),
		// radiobutton, %1 is device name, typically /dev/fd0
                sformat (_("&Floppy Disk %1"), StorageDevices::FloppyDevice),
                (location == "floppy")
            )));
        }

        targetlist = add (targetlist, `HBox (
            `VBox (`Label (""), `RadioButton (`id ("custom"), `opt (`notify),
		// radiobutton
		_("Ot&her"),
                (location == "custom"))),
            `HSpacing (2),
            `VBox (
                `ComboBox (`id (`loc), `opt (`editable, `hstretch, `notify), "",
                    getPartitionList(`boot)),
                `HSpacing (15)
            ),
            `HStretch ()
        ));

        targetlist = add (targetlist, `VSpacing (0.4));

	// frame
        term widget = `Frame (_("Boot Loader Location"),
            `RadioButtonGroup (`id (`location),
                targetlist
            )
        );
	return widget;
    }

    /**
      * Restore settings of Target widget
      */
    global define void targetInit (any opt_id, any opt_key) ``{
	if (BootPartitionDevice == RootPartitionDevice
	    && location == "root")
	{
	    location = "boot";
	}
	UI::ChangeWidget (`id (`loc), `Value, loader_device);
	UI::ChangeWidget (`id (`location), `CurrentButton, location);
	UI::SetFocus (`id (`loc));
    }

    /**
      * Handle function of widget
      * @param op any operation to handle
      * @param save boolean true if op should lead to closing & saving widget
      * @return any changed op (if needed)
      */
    global define any targetStore (any opt_id, any opt_key) ``{
	location = UI::QueryWidget (`id (`location), `CurrentButton);
	loader_device = UI::QueryWidget (`id (`loc), `Value);
	BootCommon::storeSettings ();
	loader_device = BootCommon::GetBootloaderDevice ();
	BootCommon::location_changed = true;
	return nil;
    }

    /**
      * Validate the target widget
      * @return true if everything is OK
      */
    global define boolean targetValidate (any opt_id, any opt_key, map event)``{
	string rb = UI::QueryWidget (`id (`location), `CurrentButton);
	if (rb == nil)
	{
	    setLocationErrorPopup ();
	    UI::SetFocus (`id (`location));
	    return false;
	}
	if (rb == "custom" && UI::QueryWidget (`id (`loc), `Value) == "")
	{
	    setLocationErrorPopup ();
	    UI::SetFocus (`is (`loc));
	    return false;
	}
	return true;
    }

    /**
      * Summary function for option
      * @return string summary text
      */
    global define string targetSummary (any opt_id, any opt_key) ``{
	map targetMap = Storage::GetTargetMap ();
	map boot_target = targetMap[loader_device]:$[];
	string target_name = "";
	if (boot_target == $[])
	    target_name = loader_device;
	else
	    target_name = boot_target["name"]:"disk";
	return target_name;
    }

//Bootloader type

    /**
      * Get map of widget
      * @return map of widget
      */
    global define map getLoaderSelectionWidget () ``{
        list loaders = maplist (`l, BootCommon::getBootloaders (), ``{
            return `item (`id (l), BootCommon::getLoaderName (l));
        });

	return $[
	    "table" : $[
		// table item / label
		"label" : _("Boot Loader Type"),
		"summary" : ``(BootCommon::loaderTypeSummary ()),
		"optional" : false,
		"ordering" : false,
		"key_only_once" : true,


	    ],
	    "popup" : $[
		"widget" : `custom,
		"custom_widget": (`ComboBox (`id (`loader_type), `opt (`notify),
			// combobox header
                        _("Boot &Loader Type"), loaders
                    )),
		"init" : ``(BootCommon::loaderTypeInit ()),
		"store" : BootCommon::loader_type_store,
	    ],
	];
    }

    /**
      * Restore function of widget
      */
    global define void loaderTypeInit (any opt_id, any opt_key) ``{
	UI::ChangeWidget (`id (`loader_type), `Value,
	    BootCommon::getLoaderType (false));
	UI::SetFocus (`id (`loader_type));
    }

    /**
      * Summary function for option
      * @return string summary text
      */
    global define string loaderTypeSummary (any opt_id, any opt_key) ``{
	return BootCommon::getLoaderName (BootCommon::getLoaderType (false));
    }

// backup affected disk areas widget

    /**
      * Get map of widget
      * @return map of widget
      */
    global define map getBackupMbrWidget () ``{
	return $[
	    "table" : $[
		// table item / label
		"label" : _("Back up Affected Disk Areas"),
		"summary" : ``(BootCommon::backupMbrSummary ()),
		"deletable" : false,
		"ordering" : false,
		"key_only_once" : true,
	    ],
	    "popup" : $[
		"init" : ``(BootCommon::backupMbrInit ()),
		"store" : ``(BootCommon::backupMbrStore ()),
		"widget" : `checkbox,
		// label displayed as help
		"help" : _("Affected disk areas are the MBR of the first disk
and the sector to which the boot loader is installed."),
		// checkbox label
		"widget_label" : _("&Back up Affected Disk Areas") + "XXXXX",
	    ],
	];
    }

    /**
      * Restore function of widget
      */
    global define void backupMbrInit (any opt_id, any opt_key) ``{
        UI::ChangeWidget (`id (opt_key), `Value, backup_mbr);
        UI::SetFocus (`id (opt_key));
    }

    /**
      * Handle function of widget
      * @param op any operation to handle
      * @param save boolean true if op should lead to closing & saving widget
      * @return any changed op (if needed)
      */
    global define symbol backupMbrStore (any opt_id, any opt_key) ``{
        backup_mbr = UI::QueryWidget (`id (opt_key), `Value);
	markGeneralOptionChanged ("__backup_mbr");
        return nil;
    }

    /**
      * Summary function for option
      * @return string summary text
      */
    global define string backupMbrSummary (any opt_id, any opt_key) ``{
        if (backup_mbr)
            // table item / label
            return _("Yes");
        else
            // table item / label
            return _("No");
    }

// activate bootloader partition widget

    /**
      * Get widget map
      * @return map of widget
      */
    global define map getActivateWidget () ``{
	return $[
	    "table" : $[
		// table item
		"label" : _("Activate Boot Loader Partition"),
		"summary" : ``(BootCommon::activateSummary ()),
		"deletable" : false,
		"ordering" : false,
		"key_only_once" : true,

	    ],
	    "popup" : $[
		"init" : ``(BootCommon::activateInit ()),
		"store" : ``(BootCommon::activateStore ()),
		"widget" : `checkbox,
	    ],
	];
    }

    /**
      * Restore function of widget
      */
    global define void activateInit (any opt_id, any opt_key) ``{
        UI::ChangeWidget (`id (opt_key), `Value, activate);
	UI::SetFocus (`id (opt_key));
    }

    /**
      * Handle function of widget
      * @param op any operation to handle
      * @param save boolean true if op should lead to closing & saving widget
      * @return any changed op (if needed)
      */
    global define any activateStore (any opt_id, any opt_key) ``{
        activate = UI::QueryWidget (`id (opt_key), `Value);
        if (activate)
            BootCommon::location_changed = true;
	activate_changed = true;
	markGeneralOptionChanged (opt_key);
	return nil;
    }

    /**
      * Summary function for option
      * @return string summary text
      */
    global define string activateSummary (any opt_id, any opt_key) ``{
        if (activate)
		// table item, %1 is a device name (eg. /dev/hda1)
		// FIXME partition %1 of %2 is better (in future)
            return sformat (_("Yes, Activate %1"),
		lookup (BootCommon::getPartitionToActivate (), "dev", ""));
        else
		// table item
            return _("No");
    }


// replace MBR with generic code widget

    /**
      * Get map of widget
      * @return map of widget
      */
    global define map getReplMbrWidget () ``{
	return $[
	    "table" : $[
		// table item / label
		"label" : _("Replace Code in MBR"),
		"summary" : ``(BootCommon::replMbrSummary ()),
		"deletable" : false,
		"ordering" : false,
		"key_only_once" : true,
	    ],
	    "popup" : $[
		"init" : ``(BootCommon::replMbrInit ()),
		"store" : ``(BootCommon::replMbrStore ()),
		"widget" : `checkbox,
	    ],
	];
    }

    /**
      * Restore function of widget
      */
    global define void replMbrInit (any opt_id, any opt_key) ``{
	UI::ChangeWidget (`id (opt_key), `Value, repl_mbr);
	UI::SetFocus (`id (opt_key));
    }

    /**
      * Handle function of widget
      * @param op any operation to handle
      * @param save boolean true if op should lead to closing & saving widget
      * @return any changed op (if needed)
      */
    global define any replMbrStore (any opt_id, any opt_key) ``{
	repl_mbr = UI::QueryWidget (`id (opt_key), `Value);
	if (repl_mbr)
	    BootCommon::location_changed = true;
	markGeneralOptionChanged (opt_key);
	return nil;
    }

    /**
      * Summary function for option
      * @return string summary text
      */
    global define string replMbrSummary (any opt_id, any opt_key) ``{
	if (repl_mbr)
		// table item / label
	    return sformat (_("Replace %1 with Generic Code"),
		BootCommon::mbrDisk);
	else
		// table item / label
	    return _("Leave Untouched");
    }

// save method widget

    /**
      * Get map of widget
      * @return map of widget
      */
    global define map getSaveMethod () ``{
	return $[
	    "table" : $[
		// table item / label
		"label" : _("Save Method"),
		"summary" : ``(BootCommon::saveMethodSummary ()),
		"deletable" : false,
		"ordering" : false,
		"key_only_once" : true,
	    ],
	    "popup" : $[
		"init" : ``(BootCommon::saveMethodInit ()),
		"store" : ``(BootCommon::saveMethodStore ()),
		"widget" : `checkbox,
		"help" : BootCommon::getSaveMethodHelp (),
		// table item / label
		"label" : _("Force &Saving Everything"),
	    ],
	];
    }

    /**
      * Restore function of widget
      */
    global define void saveMethodInit (any opt_id, any opt_key) ``{
        UI::ChangeWidget (`id (opt_key), `Value, save_all);
        UI::SetFocus (`id (opt_key));
    }

    /**
      * Handle function of widget
      * @param op any operation to handle
      * @param save boolean true if op should lead to closing & saving widget
      * @return any changed op (if needed)
      */
    global define any saveMethodStore (any opt_id, any opt_key) ``{
        save_all = UI::QueryWidget (`id (opt_key), `Value);
	markGeneralOptionChanged (opt_key);
        return nil;
    }

    /**
      * Summary function for option
      * @return string summary text
      */
    global define string saveMethodSummary (any opt_id, any opt_key) ``{
        if (save_all)
            // table item / label
            return _("Force Saving Everything");
        else
            // table item / label
            return _("Save Only Changed Files");
    }

// default sectiontable entry

    /**
      * Get map of widget
      * @return map of widget
      */
    global define map getDefaultSectionTableEntry () ``{
	return $[
	    "table" : $[
		// table item / label
		"label" : _("Default Section"),
		"summary" : ``(BootCommon:: defaultSectionSummary ()),
		"handle" : `sections,
		"deletable" : false,
		"ordering" : false,
		"key_only_once" : true,
	    ],
	];
    }

    /**
      * Summary function for option
      * @return string summary text
      */
    global define string defaultSectionSummary (any opt_id, any opt_key) ``{
	return getDefaultSection ();
    }

    /**
      * Get map of widget
      * @return map of widget
      */
    global define map getSectionsTableEntry () ``{
	return $[
	    "table" : $[
		// table item / label
		"label" : _("Available Sections"),
		"summary" : ``(BootCommon::getSectionsSummary ()),
		"handle" : `sections,
		"deletable" : false,
		"ordering" : false,
		"key_only_once" : true,
	    ],
	];
    }

    /**
      * Summary function for option
      * @return string summary text
      */
    global define string getSectionsSummary (any opt_id, any opt_key) ``{
	string default_name = BootCommon::getDefaultSection ();
	string sect_title = BootCommon::getSectionTitle ();
	list sects = maplist (`s, BootCommon::sections, ``{
            string title = lookup_value (s, sect_title, "");
	    boolean is_default = default_name == title;
	    // suffix after section name, keep short, to summary and table
            string def = is_default ? _(" (default)") : "";
	    return sformat ("%1%2", title, def);
        });
	return mergestring (sects, ", ");
    }

// section label/title/... widget

    /**
      * Get map of widget
      * @return map of widget
      */
    global define map getLabelWidget () ``{
	return $[
	    "table" : $[
		// table item / label
		"label" : _("Section Name"),
	        "deletable" : false,
		"ordering" : false,
		"key_only_once" : true,
	    ],
	    "option" : $[
		"widget" : `textentry,
		"validate" : ``(BootCommon::labelValidate ()),
	    ],
	];
    }

    /**
      * Validate function of widget
      * @return true if ok
      */
    global define boolean labelValidate () ``{
	list(string) existing = [];
	list(string) aliases = BootCommon::getAliasesKeys ();
	foreach (`s, BootCommon::current_sections, ``{
	    foreach (`e, s, ``{
		if (e["key"]:"" == BootCommon::getSectionTitle ()
		    || contains (aliases, e["key"]:""))
		{
		    existing = add (existing, e["value"]:"");
		}
	    });
	});
	existing = filter (string l, existing,
	    ``(l != BootCommon::current_section_name));
	existing = add (existing, "");
	string new = UI::QueryWidget (`id (`value), `Value);

	if (contains (existing, new))
	{
	    usedNameErrorPopup ();
	    return false;
	}
	return true;
    }

// alias widget

    /**
      * Get map of widget
      * @return map of widget
      */
    global define map getAliasWidget () ``{
	map ret = getLabelWidget ();
	ret["table", "deletable"] = true;
	ret["table", "ordering"] = true;
        return ret;
    }

// section type widget

    /**
      * Get map of widget
      * @return map of widget
      */
    global define map getSectionTypeWidget () ``{
        return $[
	    "table" : $[
		// table item / label
		"label" : _("Section Type"),
		"summary" : ``(BootCommon::sectionTypeSummary ()),
		"deletable" : false,
		"ordering" : false,
		"key_only_once" : true,
	    ],
	    "popup" : $[
		"widget" : `custom,
		"custom_widget":`ComboBox (`id (`section_type), `opt (`notify),
			// combobox header
                        _("Section &Type"), [
			    `item (`id ("image"), _("image")),
			    `item (`id ("other"), _("other"))]
                    ),
		"init" : ``(BootCommon::sectionTypeInit ()),
		"store" : ``(BootCommon::sectionTypeStore ()),
	    ],
        ];
    }

    /**
      * Restore function of widget
      */
    global define void sectionTypeInit (any opt_id, any opt_key) ``{
	string key = BootCommon::getKernelKey ();
        UI::ChangeWidget (`id (`section_type), `Value,
	    lookup_value (BootCommon::current_section, key, nil) == nil
		? "other"
		: "image");
	UI::SetFocus (`id (`section_type));
    }

    /**
      * Handle function of widget
      * @param op any operation to handle
      * @param save boolean true if op should lead to closing & saving widget
      * @return any changed op (if needed)
      */
    global define any sectionTypeStore (any opt_id, any opt_key) ``{
        string ntype = UI::QueryWidget (`id (`section_type), `Value);
	string otype = BootCommon::getSectionType (BootCommon::current_section);
	if (otype == ntype)
	    return nil;
	BootCommon::current_section = BootCommon::convertSection (
	    otype, ntype, BootCommon::current_section);
	one_section_changed = true;
	redraw_table = true;
	return nil;
    }

    /**
      * Summary function for option
      * @return string summary text
      */
    global define string sectionTypeSummary (any opt_id, any opt_key) ``{
	string key = BootCommon::getKernelKey ();
	return lookup_value (
		BootCommon::current_section, key, nil) == nil
	    ? _("other")
	    : _("image");
    }

// timeout widget

    /**
      * Get map of widget
      * @return map of widget
      */
    global define map getTimeoutWidget () ``{
	return $[
	    "table" : $[
		"summary" : ``(BootCommon::timeoutSummary ()),
		"key_only_once" : true,
	    ],
	    "popup" : $[
		"init" : ``(BootCommon::timeoutInit ()),
		"store" : ``(BootCommon::timeoutStore ()),
		"widget" : `intfield,
	    ],
	];
    }

    /**
      * Restore function of widget
      */
    global define void timeoutInit (any opt_id, any opt_key) ``{
	integer timeout = lookup_value (BootCommon::current_section,
	    "timeout", 0);
	UI::ChangeWidget (`id (opt_key), `Value,
	    timeout / BootCommon::getTimeoutMultiplier ());
	UI::SetFocus (`id (opt_key));
    }

    /**
      * Handle function of widget
      * @param op any operation to handle
      * @param save boolean true if op should lead to closing & saving widget
      * @return any changed op (if needed)
      */
    global define void timeoutSave (any opt_id, any opt_key) ``{
	integer timeout = UI::QueryWidget (`id (opt_key), `Value)
	    * BootCommon::getTimeoutMultiplier ();
	BootCommon::current_section = modifySection (
	    BootCommon::current_section, "timeout", timeout);
	one_section_changed = true;
    }

    /**
      * Summary function for option
      * @return string summary text
      */
    global define string timeoutSummary (any opt_id, any opt_key) ``{
	integer timeout = lookup_value (current_section, "timeout", 0);
	// table cell, %1 is a number, 's' means 'seconds'
	return sformat (_("%1 s"),
	    timeout / BootCommon::getTimeoutMultiplier ());
    }

// password widget

    /**
      * Get map of widget
      * @return map of widget
      */
    global define map getPasswdWidget () ``{
	return $[
	    "table" : $[
		"summary" : ``(BootCommon::getPasswdSummary ()),
		"key_only_once" : true,
	    ],
	    "popup" : $[
		"widget" : `custom,
		"custom_widget" : `VBox (
                    `Left (`CheckBox (`id (`usepas), `opt (`notify),
			// checkbox
                        _("&Enable Boot Loader Password Protection"))),
		    `HBox (
			// password textentry
			`HWeight (1, `Password (`id (`pw1), _("&Password"))),
			`HSpacing (2),
			// password textentry
			`HWeight (1, `Password (`id (`pw2), _("Re&type Password")))
		    ),
		    `VSpacing (0.4)
		),
		"init" : ``(BootCommon::initPasswdWidget ()),
		"handle" : ``(BootCommon::handlePasswdWidget ()),
		"store" : ``(BootCommon::storePasswdWidget ()),
		"validate_type" : `function,
		"validate_function" : ``(BootCommon::validatePasswdWidget ()),
		"help" : getPasswdHelp (),
	    ],
	];
    }

    /**
      * Restore function of widget
      */
    global define void initPasswdWidget (any opt_id, any opt_key) ``{
	string passwd = lookup_value (
	    current_globals, current_option_name, nil);
	if (passwd == nil)
	{
	    UI::ChangeWidget (`id (`usepas), `Value, false);
	    UI::ChangeWidget (`id (`pw1), `Enabled, false);
	    UI::ChangeWidget (`id (`pw1), `Value, "");
	    UI::ChangeWidget (`id (`pw2), `Enabled, false);
	    UI::ChangeWidget (`id (`pw2), `Value, "");
	}
	else
	{
	    UI::ChangeWidget (`id (`usepas), `Value, true);
	    UI::ChangeWidget (`id (`pw1), `Enabled, true);
	    UI::ChangeWidget (`id (`pw1), `Value, "**********");
	    UI::ChangeWidget (`id (`pw2), `Enabled, true);
	    UI::ChangeWidget (`id (`pw2), `Value, "**********");
	}
	UI::SetFocus (`id (`usepas));
    }

    /**
      * Handle function of widget
      * @param op any operation to handle
      * @param save boolean true if op should lead to closing & saving widget
      * @return any changed op (if needed)
      */
    global define any handlePasswdWidget (any opt_id, any opt_key, map event)``{
	if (event["ID"]:nil == `usepas)
	{
	    boolean enabled = UI::QueryWidget (`id (`usepas), `Value);
	    UI::ChangeWidget (`id (`pw1), `Enabled, enabled);
	    UI::ChangeWidget (`id (`pw2), `Enabled, enabled);
	}
    }

    global define void storePasswdWidget (any opt_id, any opt_key) ``{
	string password = nil;
	boolean usepass = UI::QueryWidget (`id (`usepas), `Value);
	y2milestone ("Usepass: %1", usepass);
	if (usepass)
	{
	    if (UI::QueryWidget (`id (`pw1), `Value) != "**********")
	    {
		password = UI::QueryWidget (`id (`pw1), `Value);
		if (haskey (BootCommon::current_bootloader_attribs,
		    "update_passwd"))
		{
		    eval (BootCommon::current_bootloader_attribs[
			"update_passwd"]:nil);
		}
	    }
	}
	current_section = modifySection (current_section, "password",
	    password);
	one_section_changed = true;
        return nil;
    }

    /**
      * Validate function of widget
      * @return true if widget settings ok
      */
    global define boolean validatePasswdWidget (any opt_id, any opt_key,
	map event)
    ``{
	if (! UI::QueryWidget (`id (`usepas), `Value))
	    return true;
	if (UI::QueryWidget (`id (`pw1), `Value) == "")
	{
	    emptyPasswdErrorPopup ();
	    UI::SetFocus (`id (`pw1));
	    return false;
	}
	if (UI::QueryWidget (`id (`pw1), `Value)
	    == UI::QueryWidget (`id (`pw2), `Value)
	)
	    return true;
	passwdMissmatchPopup ();
	UI::SetFocus (`id (`pw1));
	return false;
    }

    /**
      * Summary function for option
      * @return string summary text
      */
    global define string getPasswdSummary (any opt_id, any opt_key) ``{
	if (lookup_value (BootCommon::current_section, "password", nil) != nil)
	    // table cell
	    return _("Password will be needed");
	else
	    // table cell
	    return _("No password will be needed");
    }






}
