/**
 * File:
 *      include/bootloader/routines/misc-common.ycp
 *
 * Module:
 *      Bootloader installation and configuration
 *
 * Summary:
 *      Miscelaneous functions for bootloader configuration and installation
 *
 * Authors:
 *      Jiri Srain <jsrain@suse.cz>
 *
 * $Id$
 *
 * WARNING:
 *      To be included to BootCommon.ycp only, requires function
 *      getLoaderType to avoid include-import cycle
 *      Use import "BootCommon" instead.
 */



{

    textdomain "bootloader";
    import "Mode";


// bootloader attributes handling functions

    /**
      * Get the name of key containing section name of currently used bootloader
      * @return string section name key
      */
    global define string getSectionTitle () ``{
	return current_bootloader_attribs["section_title"]:"label";
    }

    /**
      * Get the name of key containing kernel in currently used bootloader
      * @return string section name key
      */
    global define string getKernelKey () ``{
	return current_bootloader_attribs["kernel_key"]:"image";
    }

    /**
      * Get packages needed by specified bootloader
      * maybe should be moved to bootloader specific modules
      * @param bootloader string name of bootloader
      * @return a list of required packages names
      */
    global define list(string) getBootloaderPackages (string bootloader) ``{
	return bootloader_attribs[bootloader, "required_packages"]:[];
    }

    /**
      * return printable name of bootloader
      * @param bootloader string bootloader type internal string
      * @return string printable bootloader name
      */
    global define string getLoaderName (string bootloader) ``{
	// fallback bootloader name, keep short
	return bootloader_attribs[bootloader, "loader_name"]:_("boot loader");
    }

    /**
      * Get the name of key containing default section identification
      * in currently used bootloader
      * @return string default section option key
      */
    global define string getDefaultKey () ``{
	return current_bootloader_attribs["default_key"]:"image";
    }

    /**
      * Get type of value containing default section identification
      * in currently used bootloader
      * @return symbol `label or `index (type of contents)
      */
    global define symbol getDefaultType () ``{
        return current_bootloader_attribs["default_type"]:`label;
    }

    /**
      * Get index of first section when index identificatipno is used
      * @return integer index of first section
      */
    global define integer getDefaultFirstIndex () ``{
        return current_bootloader_attribs["default_index_start"]:0;
    }

    /**
      * Get the value which multiplies timeout (in seconds) before writing
      * to bootloader configuration file (eg. 10 for lilo)
      * @return integer index of first section
      */
    global define integer getTimeoutMultiplier () ``{
	return current_bootloader_attribs["timeout_multiplier"]:1;
    }

    /**
      * Get list of keys which mean section alias
      * @return list of such keys
      */
    global define list(string) getAliasesKeys () ``{
        return current_bootloader_attribs["alias_keys"]:[];
    }

    /**
      * Get value of specified boolean bootloader attribute
      * @param attrib string attribute name
      * @return boolean value of attribute
      */
    global define boolean getBooleanAttrib (string attrib) ``{
	return current_bootloader_attribs[attrib]:false;
    }

    /**
      * Get value of specified bootloader attribute
      * @param attrib string attribute name
      * @return any value of attribute
      */
    global define any getAnyTypeAttrib (string attrib) ``{
        return current_bootloader_attribs[attrib]:false;
    }


    /**
      * Convert section orig from type otype to ntype
      * Some information gets lost. ntype must be different from otype
      * @param otype string original section type, "image" or "other"
      * @param ntype string new section type, "image" or "other"
      * @param orig map original section
      * @return map new (converted) section
      */
    global define map convertSection (string otype, string ntype, map orig) ``{
        term f = current_bootloader_attribs["convert_function"]:nil;
	if (f == nil)
	    return orig;
	f = add (f, otype);
	f = add (f, ntype);
	f = add (f, orig);
	return eval (f);
    }

    /**
      * Get map where to store kernel parameters
      * @return map describing where to store which kernel parameter
      */
    global define map getKernelParamKeys () ``{
        return current_bootloader_attribs["kernel_params"]:$[];
    }

    /**
      * Get type of specified section
      * Type depends on currently used bootloader
      * @param section map of the section
      * @return any section type
      */
    global define any getSectionType (map section) ``{
	if (is (current_section_name, symbol))
	    return current_section_name;
// TODO: ask bootloader-specific function if exists
	if (haskey (current_section, getKernelKey ()))
	    return "image";
	else
	    return "other";
    }


// other misc functions

    /**
      * Generates unused section label for new section
      * @return string label for new section
      */
    global define string getFreeSectionLabel () ``{
	integer index = 1;
	list(string) existing = [];
        foreach (`s, BootCommon::sections, ``{
            existing = add (existing, s[getSectionTitle ()]:"");
            foreach (`a, aliases, ``{
                existing = add (existing, s[a]:"");
            });
        });
	while (true)
	{
	    string title = sformat ("section %1", index);
	    if (! contains (existing, title))
		return title;
	    index = index + 1;
	}
    }

    /**
      * Get the list of installed floppy drives
      * @return list of floppy devices
      */
    global define list(string) getFloppyDevices () ``{
        if (floppy_devices == nil)
        {
            list(map) floppies = SCR::Read (.probe.floppy);
            floppies = filter (`f, floppies,
                ``(lookup (f, "model", "Floppy Disk") == "Floppy Disk"));
            floppy_devices = maplist (`f, floppies,
		``(lookup (f, "dev_name", "")));
            floppy_devices = filter (`f, floppy_devices, ``(f != ""));
        }
	return floppy_devices;
    }


    /**
      * Update the text of countdown widget
      * @param bootloader string printable name of used bootloader
      */
    global define void updateTimeoutPopupForFloppy (string bootloader) ``{
	if (Mode::normal)
	    return;

        string confirm_boot_msg = Misc::boot_msg;
        // data saved to floppy disk
        string msg = sformat (
            // popup, %1 is bootloader name
            _("The %1 boot sector has been written to the floppy disk."),
            bootloader);
        msg = msg + "\n";
	// always hard boot
        // If LILO was written on floppy disk and we need
        // to do a hard reboot (because a different kernel
        // was installed), tell the user to leave the floppy
        // inserted.
        msg = msg
            // popup - continuing
            + _("Leave the floppy disk in the drive.");

        if ( size (confirm_boot_msg) > 0 )
        {
            msg = msg + "\n" + confirm_boot_msg;
        }
        Misc::boot_msg = msg;
    }

    /**
      * List of all supported bootloaders
      */
    global list(string) bootloaders = ["lilo", "grub", "elilo", "milo", "silo",
	"aboot", "s390", "ppc", "mips"];

    /**
     * converts array of string to path
     * @param strs list of string
     * @return path whose components are taken from strs
     */
    global define path list2path(list strs) ``{
        path pth = .;
        foreach(`e, strs, ``{
            pth = add(pth, e);
        });
        return pth;
    }

    /**
     * returns list of partitions. looks at '/proc/partitions' and creates list
     * of partition for combobox or menu
     * @param type symbol
     *   `boot - for botloader installation
     *   `root - for kernel root
     *   `boot_other - for bootable partitions of other systems
     *   `all - all partitions
     *   `parts_old - all partitions, except those what will be created
     *      during isntallation
     *   `deleted - all partitions deleted in current proposal
     * @return list of strings
     */
    global define list getPartitionList(symbol type) ``{
	map devices = Storage::GetTargetMap();
	devices = filter (`k, `v, devices,
	    ``(! lookup (v, "is_lvm_vg", false)));
	if (type == `boot || type == `boot_other)
	{
	    devices = filter (`k, `v, devices,
		``(! issubstring (k, "/dev/md")));
	}
	list all_disks = maplist (`k, `v, devices, ``(k));
	list partitions = [];
	foreach (`k, `v, devices, ``{
	    partitions = merge (partitions, v["partitions"]:[]);
	});
	list(string) floppies = getFloppyDevices ();

        partitions = filter (`p, partitions, ``(is (p, map)));
	if (type == `deleted)
	    return maplist (`x, filter (`p, partitions, ``(p["delete"]:false)),
		``{return x["device"]:"";
	    });
        partitions = filter (`p, partitions, ``(! p["delete"]:false));
	list ret = all_disks;
	if (type == `boot_other || type == `root || type == `parts_old)
            ret = [];

	if (type == `boot_other)
	{
	    partitions = filter (`p, partitions,
		``(p["type"]:`primary == `primary));
	}
        else if (type == `boot)
        {
            partitions = filter (`p, partitions,
                ``(p["type"]:`primary == `primary
		    || p["type"]:`primary == `extended));
        }
        else if (type == `root)
        {
            partitions = filter (`p, partitions,
                    ``(p["type"]:`primary != `extended));
        }
	else if (type == `parts_old)
	{
	    partitions = filter (`p, partitions, ``(! p["create"]:false));
	}
        if (type != `all && type != `parts_old)
        {
            partitions = filter (`p, partitions,
                ``(lookup (p, "fstype", "") != "Linux swap"));
        }
	if (type == `boot)
	{
	    partitions = filter (`p, partitions,
                ``(p["fstype"]:"" == "Linux native"
                    || p["fstype"]:"" == "Extended"));
	}
        partitions = maplist (`p, partitions, ``(p["device"]:""));
	partitions = filter (`p, partitions, ``(p != ""));
        partitions = merge (partitions, floppies);
        ret = union (ret, partitions);
	ret = toset (ret);
	return ret;
    }

    /**
      * reads specified section and returns values as map
      *   $[option1:value1, option2:value2,...]]
      * @param bl string bootloader to read
      * @param type string "sections" / ""
      * @param section string
      * @return map map as described above
      */
    global define map sectOptions2Map(string bl, string type, string section)
    ``{
        path p = .;
        if (type == "")
        {
            p = list2path([bl]);
        }
        else
        {
            p = list2path([bl, "sections" , section]);
        }

        list optlist = SCR::Dir(p);

        if (type == "")
        {
            optlist = filter(`e, optlist, ``(e != "sections"));
        }

        any value = "";
        map retval = $["__order__" : optlist];

        // read global options and create map to be stored in settings

        list option = [];

        foreach(`e, optlist,
        ``{
            value = mod2ui(SCR::Read(add(p, e)));
            if (isSpecial(e))
                retval = add(retval, e, mergestring(SCR::Read(add(p, e)), ","));
            else if (lookup(opttypes(), e, "") == "b")
		retval = add(retval, e, tobool (value));
	    else if (lookup(opttypes(), e, "") == "i")
		retval = add(retval, e, tointeger (value));
	    else
                retval = add(retval, e, sformat("%1", value));
        });

        return retval;
    }

    /**
      * returns list difference A \ B (items that are in A and are not in B)
      * @param a list A
      * @param b list B
      * @return list see above
      */
    global define list difflist(list a, list b) ``{
	return filter(`e, a, ``(!contains(b, e)));
    }

    /**
      * return true if given option is special
      * @param opt option name
      * @return boolean special/not
      */
    global define boolean isSpecial(string opt) ``{
	return (lookup(opttypes(), opt, "") == "x");
    }

    /**
      * convert string values from agent representation to module representation
      * 1) if string is quoted, quotes are removed
      * 2) if string contains escaped quotes, they're unescaped
      * @param val value to transform
      * @return any transformed value
      */
    global define any mod2ui(any val) ``{
	if (is(val, string))
	{
	    string v = sformat("%1", val);
	    v = strip(v);
	    // remove leading and trailing quotes
	    if (substring(v, 0, 1) == "\""
		&& substring(v, size(v)-1, 1) == "\"")
	    {
		v = substring(v, 1, size(v)-2);
	    }

	    // unescape backslashes
	    v = replaceAll(v, "\\\\", "\\");

	    // unescape quotes
	    v = replaceAll(v, "\\\"", "\"");
	    return v;
	}
	return val;
    }

    /**
      * reverse of mod2ui
      * @param val value to transform
      * @return any transformed value
      */
    global define any ui2mod(any val) ``{
	if (is(val, string))
	{
	    string v = sformat("%1", val);
	    v = strip(v);
	    // if string contains backslashes, escape them
	    v = replaceAll(v, "\\", "\\\\");

	    // if string contains quotes, escape them
	    v = replaceAll(v, "\"", "\\\"");

	    // if string contains spaces or equal sign or is empty, quote it

	    if ((size(splitstring(v, " ")) >= 2 || size(v) == 0
		|| find(v, "=") >= 0)
	        &&(getLoaderType (false) != "grub"))
	    {
		v = "\"" + v + "\"";
	    }
	    return v;
	}
	return val;
    }

    /**
      * replaces all occurences of 'from' to 'to' in src
      * @param src input string
      * @param from string to be replaced
      * @param to string to be replaced by
      * @return string modified string
      */
    global define string replaceAll(string src, string from, string to) ``{
	if (from == "")
	{
	    return src;
	}

	list tokens = [];

	integer p = find(src, from);
	while(p >= 0)
	{
	    tokens = add(tokens, substring(src, 0, p));
	    src = substring(src, p + size(from), size(src) - (p+size(from)));
	    p = find(src, from);
	}
	tokens = add(tokens, src);
	return mergestring(tokens, to);
    }


    /**
      * returns true if char is blank (newline, tab or space)
      * @param s single char string
      * @return boolean blank/non blank
      */
    global define boolean isBlank(string s) ``{
	if (s == "\n" || s == "\t" || s == " ")
	{
	    return true;
	}
	return false;
    }

    /**
      * removes trailing and leading blank chars from string.
      *   eg: "  as df  " -> "as df"
      * @param str string source string
      * @return string stripped string
      */
    global define string strip(string str)``{
	//emtpy  string
	if (size(str) == 0) return "";

	integer bound = size(str);
	integer first = 0;
	integer last = size(str) - 1;
	// find first non-blank char
	while(first < bound && isBlank(substring(str, first, 1)))
	{
	    first = first + 1;
	}

	while(last >= 0 && isBlank(substring(str, last, 1)))
	{
	    last = last - 1;
	}
	if (last >= first)
	{
	    return substring(str, first, last - first + 1);
	}
	return "";
    }

    /**
      * returns modified list where items index1 and index2 are swapped.
      * if indices are out of bounds, unmodified list is returned.
      * @param input list
      * @param index1 index of the first element
      * @param index2 index og the second element
      * @return list modified list
      */
    global define list swapItems(list input, integer index1, integer index2) ``{
	if (index1 >= size(input) || index2 >= size(input)
	    || index1 < 0 || index2 < 0)
	{
	    return input;
	}
	list output = [];
	integer pos = -1;
	output = maplist(`e, input, ``{
	    pos = pos + 1;
	    if (pos == index1)
	    {
	        return select(input, index2, $[]);
	    }
	    else if (pos == index2)
	    {
	        return select(input, index1, $[]);
	    }
	    return e;
	});
	return output;
    }

    /**
      * translate filename path (eg. /boot/kernel) to list of device
      *  and relative path
      * @param fullpth string fileststem path (eg. /boot/vmlinuz)
      * @return list containing device and relative path,
      *  eg. ["/dev/hda1", "/vmlinuz"]
      */
    global define list splitPath (string fullpth) ``{
// UGHLY HACK because of testsuites
	map mountpoints = $[];
	if (Mode::test)
	    mountpoints = $["/" : ["/dev/hda2"], "/boot" : ["/dev/hda1"]];
	else
	    mountpoints = Storage::GetMountPoints();
	string dev = "";
	string mp = "";
	integer max = 0;
	foreach (`k, `v, mountpoints, ``{
	    if (issubstring (fullpth, k) && size (k) > max)
	    {
	        max = size (k);
	        dev = v[0]:"";
	        mp = k;
	    }
	});
	if (mp == "")
	    return [];

	string pth = substring (fullpth, size (mp));
	if (substring (pth, 0, 1) != "/")
	    pth = "/" + pth;
	return [dev, pth];
    }

    /**
      * translate list of device and relative path
      *  to filename path (eg. /boot/kernel)
      * @param devpth list of two strings, first for device name, second for
      *  relative path (eg. ["/dev/hda1", "/vmlinuz"])
      * @return string fileststem path (eg. /boot/vmlinuz)
      */
    global define string mergePath (list(string) devpth) ``{
// UGHLY HACK because of testsuites
        map mountpoints = $[];
	if (Mode::test)
	    mountpoints = $["/" : ["/dev/hda2"], "/boot" : ["/dev/hda1"]];
	else
            mountpoints = Storage::GetMountPoints();
	string ret = "/dev/null";
	if (substring (devpth[1]:"", 0, 1) != "/")
	    devpth[1] = "/" + devpth[1]:"";
        foreach (string k, `v, mountpoints, ``{
	    if (v[0]:"" == devpth[0]:"")
	    {
		if (substring (k, size (k) - 1, 1) == "/")
		    k = substring (k, 0, size (k) - 1);
		ret = k + devpth[1]:"";
	    }
	});
	return ret;
    }

    /**
      * Get bootloader device for specified location
      * @return string device name
      */
    global define string GetBootloaderDevice () ``{
        if (BootCommon::location == "mbr")
            return BootCommon::mbrDisk;
        if (BootCommon::location == "boot")
            return BootCommon::BootPartitionDevice;
        if (BootCommon::location == "root")
            return BootCommon::RootPartitionDevice;
        if (BootCommon::location == "floppy")
            return StorageDevices::FloppyDevice;
	if (BootCommon::location == "none")
	    return "/dev/null";
        return BootCommon::loader_device;
    }

    /**
      *
      * @return true if installing bootloader to floppy
      */
    global define boolean installingToFloppy () ``{
	if (BootCommon::location == "floppy")
	    return true;
	if (BootCommon::loader_device == StorageDevices::FloppyDevice)
	    return true;
	if (contains (getFloppyDevices (), BootCommon::loader_device))
	    return true;
	return false;
    }

    /**
      * Get the label of default section
      * @return string label default section label
      */
    global define string getDefaultSection () ``{
	if (getDefaultType () == `label)
	{
	    string default = globals[getDefaultKey ()]:"";
	    boolean exists = false;
	    foreach (`s, sections, ``{
		if (s[getSectionTitle ()]:"" == default)
		    exists = true;
	    });
	    if (exists)
		return default;
	    else
		return sections[0, getSectionTitle ()]:"";
	}
	else
	{
	    integer index = globals[getDefaultKey ()]:0
		- getDefaultFirstIndex ();
	    if (index < 0 || index >= size (sections))
		index = 0;
	    return sections[index, getSectionTitle ()]:"";
	}
    }

    /**
      * get kernel parameter from kernel command line
      * @param line string original line
      * @param key string parameter key
      * @return string value, "false" if not present,
      *   "true" if present key without value
      */
    global define string getKernelParamFromLine (string line, string key) ``{
	string res = "false";
	list params = splitstring (line, " ");
	params = filter (`p, params, ``(p != ""));
	foreach (`p, params, ``{
	    list l = filter (`e, splitstring (p, "="), ``(e != " " && e != ""));
	    if (select (l, 0, "") == key)
	        res = select (l, 1, "true");
	});
	return res;
    }

    /**
      * set kernel parameter to GRUB command line
      * @param line string original line
      * @param key string parameter key
      * @param value string value, "false" to remove key,
      *   "true" to add key without value
      * @return string new kernel command line
      */
    global define string setKernelParamToLine
	(string line, string key, string value)
    ``{
	list params = splitstring (line, " ");
	params = filter (`p, params, ``(p != ""));
	list rp = [];
	boolean done = false;
	foreach (`p, params, ``{
	    list l = filter (`e, splitstring (p, "="), ``(e != " " && e != ""));
	    if (select (l, 0, "") == key)
	    {
	        done = true;
	        if (value == "true")
	        {
	            rp = add (rp, key);
	        }
	        else if (value != "false")
	        {
	            rp = add (rp, sformat ("%1=%2", key, value));
	        }
	    }
	    else
	    {
	        rp = add (rp, p);
	    }
	});
	if (! done)
	{
	    if (value == "true")
	    {
	        rp = add (rp, key);
	    }
	    else if (value != "false")
	    {
	        rp = add (rp, sformat ("%1=%2", key, value));
	    }
	}
	line = mergestring (rp, " ");
	return line;
    }

    /**
      * Save settings stored in memory of module to Lilo agent
      * @return boolean true on success
      */
    global define boolean saveCfgFileToAgent () ``{
	y2debug ("Saving: glob: %1, sec: %2", globals, sections);
	string bl = getLoaderType (false);
	if (bl == "s390")
	    bl = "zipl";

        // first synchronize global settings

	map glob_backup = globals;
	list sect_backup = sections;
        list global_order = lookup (globals, "__order__", []);
        globals = filter (`k, `v, globals, ``(k != "__order__"));
	globals = filter (`k, `v, globals,
	    ``(k != "__intern__"));
        global_order = filter (`e, global_order, ``(haskey (globals, e)));
        list globs1 = SCR::Dir(list2path([bl]));
        list globs2 = maplist(`e, `f, globals, ``(e));
        list diff = difflist(globs1, globs2);
        diff = difflist(diff, ["sections"]);

        // remove options that has disappeared
        foreach(`e, diff, ``{SCR::Write(list2path([bl, e]), nil);});

        // write values
        if (global_order != [])
        {
            integer index = 0;
            foreach (`e, global_order, ``{
                if (isSpecial(e))
                {
                    SCR::Write(list2path([bl, e]),
                        splitstring(lookup (globals, e, ""), ","), index);
                }
                else
                {
                    SCR::Write(list2path([bl, e]),
                        ui2mod(lookup (globals, e, "")), index);
                }
                index = index + 1;
                globals = filter (`k, `v, globals, ``(k != e));
            });
        };
        foreach(`e, `f, globals, ``{
            if (isSpecial(e))
            {
                SCR::Write(list2path([bl, e]), splitstring(f, ","));
            }
            else
            {
                SCR::Write(list2path([bl, e]), ui2mod(f));
            }
        });

        // now remove all sections
        list sects = SCR::Dir(list2path([bl, "sections"]));
        foreach(`sect, sects, ``{
           SCR::Write(list2path([bl, "sections", sect]), nil);
        });
        string sname = "";
        // now write new sections
        foreach(`sect, sections,
        ``{
            sname = sect[getSectionTitle ()]:"";
            list sect_order = lookup  (sect, "__order__", []);
            sect = filter (`k, `v, sect, ``(k != "__order__"));
	    sect = filter (`k, `v, sect,
		``(k != "__intern__"));
            sect_order = filter (`e, sect_order, ``(haskey (sect, e)));
            SCR::Write(list2path([bl, "sections", ui2mod(sname),
                getSectionTitle ()]), ui2mod(sname));
            if (sect_order != [])
            {
                integer index = 0;
                foreach (`key, sect_order, ``{
                    if (isSpecial(key))
                    {
                        SCR::Write(
                            list2path([bl, "sections", ui2mod(sname), key]),
                            splitstring(lookup (sect, key, ""), ","), index);
                    }
                    else
                    {
                        SCR::Write(
                            list2path([bl, "sections", ui2mod(sname), key]),
                            ui2mod(lookup (sect, key, "")), index);
                    }
                    index = index + 1;
                    sect = filter (`k, `v, sect, ``(k != key));
                });
            }
            foreach(`key, `val, sect, ``{
                if (isSpecial(key))
                {
                    SCR::Write(
                        list2path([bl, "sections", ui2mod(sname), key]),
                        splitstring(val, ","));
                }
                else
                {
                    SCR::Write(
                        list2path([bl, "sections", ui2mod(sname), key]),
                        ui2mod(val));
                }
            });
        });

	globals = glob_backup;
	sections = sect_backup;
	return true;
    }

    /**
      * Load settings from Lilo agent to module variables
      * @return boolean true on success
      */
    global define boolean loadCfgFileFromAgent () ``{
        string bl = getLoaderType (false);
	if (bl == "s390")
	    bl = "zipl";

        list optlist = SCR::Dir(list2path([bl]));

        any value = "";
        string comment = "";

        BootCommon::globals = sectOptions2Map(bl, "", "");
	y2debug ("Parsed globals: %1", BootCommon::globals);

        // iterate for all sections and do the same as before

        list sects = [];
        map opts_tmp = $[];

        sects = SCR::Dir(list2path([bl, "sections"]));
        BootCommon::sections = [];

        foreach(`e, sects,
        ``{
            opts_tmp = sectOptions2Map(bl, "sections", e);
            BootCommon::sections = add(BootCommon::sections, opts_tmp);
        });
	y2debug ("Parsed sections: %1", sections);
	return true;
    }

    /**
      * returns map of options and their types
      * @return map option types
      */
    global define map opttypes() ``{
	string bl = getLoaderType (false);
	if (bl == "s390")
	    bl = "zipl";
	if (size (opt_types[bl]:$[]) > 0)
	    return opt_types[bl]:$[];
	map out = SCR::Read (list2path ([bl, "opttypes"]));
	opt_types[bl] = out;
/*	if (Arch::ia64)
	{
	    out = remove(out, "lba");
	    out = remove(out, "lba32");
	    out = remove(out, "linear");
	    out = add(out, "chooser", "s");
	    out = add(out, "noedd30", "b");
	}
*/
	return out;
    }

    /**
      * Mark option as changed by user
      * @param section any section identifier
      * @param optname any option name
      */
    global define void markOptionChanged (any section, any optname) ``{
	y2debug ("Marking option %1 of section %2 changed", optname, section);
	map current = BootCommon::changed_settings[section]:$[];
	current[optname] = true;
	BootCommon::changed_settings[section] = current;
	if (section == `global)
	{
	    BootCommon::changed = true;
	}
	else
	{
	    BootCommon::one_section_changed = true;
	}
    }

    /**
      * remove blanks from section name and replace them with _
      * when not using GRUB
      * @param original string
      * @return string fixed string
      */
    global define string removeBlanks (string original) ``{
	if (getLoaderType (false) == "grub")
	    return original;
	if (size (original) > 15)
	   original = substring (original, 0, 15);
	return replaceAll (original, " ", "_");
    }

    /**
      * The SelectionBox "----" divider hack
      * @param opts list of options for the current selection
      * @param prev previously selected item
      * @param current currently selected item
      * @return new item selection
      */
    global define any dividerHack(list opts, any prev, any current) ``{
	integer p = -1;
	find(`e, opts, ``{
	    p = p + 1;
	    return e == prev;
	});
	integer i = -1;
	find(`e, opts, ``{
	    i = i + 1;
	    return e == current;
	});
	// separator can be the last option in the list (#25305)
	// handle the same way as if previous was behind
	if (i + 1 >= size (opts))
	    p = i + 1;
	return select(opts, p < i ? i + 1 : i - 1, "");
    }

    /**
      * Filter list to only entries which are present as keys in map
      * @param order list (ordered) of settings
      * @param widgets map of present widgets
      * @return list filtered list
      */
    global define list filterOrder (list order, map widgets) ``{
	order = filter (`o, order, ``(
	    widgets[o, "ordering"]:true
	));
	return order;
    }

    /**
      * Get partition which should be activated if doing it during bl inst.
      * @return map $[ "dev" : string, "mbr": string, "num": any]
      *  containing device (eg. "/dev/hda4"), disk (eg. "/dev/hda") and
      *  partition number (eg. 4)
      */
    global define map getPartitionToActivate () ``{
	map p_dev = Storage::GetDiskPartition (BootCommon::loader_device);
	any num = p_dev["nr"]:0;
	string mbr_dev = p_dev["disk"]:"";
	// if bootloader in MBR, activate /boot partition
	// (partiall fix of #20637)
	if (! (num != 0 && num != ""))
	{
	    p_dev = Storage::GetDiskPartition (BootCommon::BootPartitionDevice);
	    num = p_dev["nr"]:0;
	    mbr_dev = p_dev["disk"]:"";
	}
	if (is (num, integer) && num != 0 && num != "")
	{
	    if (num > 4)
	    {
		y2milestone ("Bootloader partition type is logical");
		map tm = Storage::GetTargetMap ();
		list partitions = tm[mbr_dev, "partitions"]:$[];
		foreach (`p, partitions, ``{
		    if (p["type"]:nil == `extended)
		    {
			num = p["nr"]:num;
			y2milestone ("Using extended partition %1 instead",
			num);
		    }
		});
	    }
	}
	map ret = $[
	    "num" : num,
	    "mbr" : mbr_dev,
	    "dev" : Storage::GetDeviceName (mbr_dev, num),
	];
	return ret;
    }

    /**
      * Update contents of MBR (active partition and booting code)
      * @return boolean true on success
      */
    global define boolean updateMBR () ``{
	if (backup_mbr)
	{
	    saveMBR (BootCommon::mbrDisk);
	}
	boolean ret = true;
	if (activate)
	{
	    map activate = getPartitionToActivate ();
	    any num = activate["num"]:0;
	    string mbr_dev = activate["mbr"]:"";
	    if (num != 0 && mbr_dev != "")
	    {
		if ((! is (num, integer)) || num <= 4)
		{
		    y2milestone ("Activating partition %1 on %2", num, mbr_dev);
		    ret = ret && (0 == SCR::Execute (.target.bash,
			sformat ("/sbin/activate %2 %1", num, mbr_dev)));
		}
	    }
	}
	if (repl_mbr && BootCommon::location != "mbr")
	{
	    y2milestone ("Copying generic MBR code to MBR");
	    ret = ret && (0 == SCR::Execute (.target.bash, sformat (
		"/bin/dd bs=446 count=1 if=%1 of=%2",
		    "/usr/share/YaST2/data/mbr", BootCommon::mbrDisk)));
	}
	return ret;
    }

    /**
      * Get last change time of file
      * @param filename string name of file
      * @return string last change date as YYYY-MM-DD-HH-MM-SS
      */
    global define string getFileChangeDate (string filename) ``{
	map stat = SCR::Read (.target.stat, filename);
	integer ctime = stat["ctime"]:0;
	string command = sformat (
	  "date --date='1970-01-01 00:00:00 %1 seconds' +\"%%Y-%%m-%%d-%%H-%%M-%%S\"",
	  ctime);
	map out = SCR::Execute (.target.bash_output, command);
	string c_time = out["stdout"]:"";
	y2error ("File %1: last change %2", filename, c_time);
	return c_time;
    }

    /**
      * Save current MBR to /boot/backup/mbr, if some existing, rename it
      * @param device string name of device
      */
    global define void saveMBR (string device) ``{
	SCR::Execute (.target.bash,
	    "test -d /boot/backup || mkdir /boot/backup");
	if (SCR::Read (.target.size, "/boot/backup/mbr") > 0)
	{
	    list contents = SCR::Read (.target.dir, "boot/backup");
	    contents = filter (`c, contents, ``(regexpmatch (c,
		".*-.*-.*-.*-.*-.*-.*")));
	    contents = sort (contents);
	    integer index = 0;
	    integer siz = size (contents);
	    while (index + 10 < siz)
	    {
		SCR::Execute (.target.remove,
		    sformat ("/boot/backup/%1", contents[index]:""));
		index = index + 1;
	    }
	    string change_date = getFileChangeDate ("/boot/backup/mbr");
	    SCR::Execute (.target.bash, sformat (
		"/bin/mv /boot/backup/mbr /boot/backup/mbr-%1",
		getFileChangeDate ("/boot/backup/mbr")));
	}
	SCR::Execute (.target.bash, sformat (
	    "/bin/dd if=%1 of=/boot/backup/mbr bs=512 count=1",
	    mbrDisk));
    }

    /**
      * Rewrite current MBR with /boot/backup/mbr
      * @param device string device to rewrite MBR on
      * @return boolean true on success
      */
    global define boolean restoreMBR (string device) ``{
	if (SCR::Read (.target.size, "/boot/backup/mbr") <= 0)
	{
	    Report::Error ("Can't restore MBR. No saved MBR found");
	    return false;
	}
	integer ret = SCR::Execute (.target.bash, sformat (
	    "/bin/dd of=%1 if=/boot/backup/mbr bs=446 count=1",
	    device));
	return (ret == 0);
    }

    /**
      * Translate device name to major/minor number
      * @param device string
      * @return string major*256+minor hexadecimal without leading 0x
      */
    global define string dev2majmin (string device) ``{
        string ls = lookup (SCR::Execute (.target.bash_output, sformat (
            "ls -ln %1", device)), "stdout", "");
        list(string) parts = splitstring (ls, " ");
        parts = filter (`p, parts, ``(p != ""));
        string majs = parts[4]:"";
        majs = substring (majs, 0, size (majs) -1);
        string mins = parts[5]:"";
        integer maj = tointeger (majs);
        integer min = tointeger (mins);
	majs = tohexstring (maj);
	majs = substring (majs, 2);
	while (size (majs) < 2)
	    majs = "0" + majs;
	mins = tohexstring (min);
	mins = substring (mins, 2);
	while (size (mins) < 2)
	    mins = "0" +  mins;
	y2debug ("Translated %1 to %2:%3", device, majs, mins);
	string ret = sformat ("%1%2", majs, mins);
        return ret;
    }


    /**
      * Convert any to boolean
      * @param v any value
      * @return boolean retyped value
      */
    global define boolean tobool (any v) ``{
	if (v == true)
	    return true;
	else
	    return false;
    }

    /**
      * Update kernel parameters if some were added in Kernel module
      * @param orig original kernel parameters or kernel command line
      * @return kernel command line or parameters with added new parameters
      */
    global define string updateKernelParams (string orig) ``{
	list(string) new = splitstring (Kernel::cmdLine, " ");
	list(string) old = splitstring (orig, " ");
	list(string) added = BootCommon::difflist (new,
	     splitstring (BootCommon::kernelCmdLine, " "));
	added = BootCommon::difflist (added, old);
	old = merge (old, added);
	if (Mode::initial)
	{// move showopts apic to the end
	    boolean showopts = false;
	    boolean apic = false;
	    if (contains (old, "showopts"))
		showopts = true;
	    if (contains (old, "apic"))
		apic = true;
	    old = filter (`o, old, ``(o != "apic" && o != "showopts"));
	    if (showopts)
		old = add (old, "showopts");
	    if (apic)
		old = add (old, "apic");
	}
	return mergestring (old, " ");
    }

    /**
      * Check whether settings were changed and if yes, ask for exit
      * without saving
      * @return true if shall exit
      */
    global define boolean confirmAbort () ``{
	if ((! changed) || confirmAbortPopup ())
	    return true;
	else
	    return false;
    }

} //end of include
