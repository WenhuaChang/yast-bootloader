/**
 * File:
 *      include/bootloader/routines/ui.ycp
 *
 * Module:
 *      Bootloader installation and configuration
 *
 * Summary:
 *      User interface for bootloader installation/configuration
 *
 * Authors:
 *      Jiri Srain <jsrain@suse.cz>
 *
 * $Id$
 *
 */


{
    textdomain "bootloader";

    include "wizard/sequencer.ycp";
    include "ui/common_messages.ycp";

    include "bootloader/routines/wh.ycp";
    include "bootloader/routines/popups.ycp";
    include "bootloader/routines/convert.ycp";
    include "bootloader/routines/routines.ycp";

    import "BootCommon";
    import "Bootloader";

    /**
      * Displaye popup for option to edit choosing
      * @param ot any option type (`global, "image", "other",...
      *   may be bootloader dependent)
      * @return any option identifies, nil if canceled
      */
    global define any getOptionChoicePopup (any ot) ``{
	list optnames = lookup (Bootloader::blOptions (),
	    BootCommon::getSectionType (BootCommon::current_section), []);
	optnames = sort (optnames);
	term widget = `HBox (`HSpacing (1), `VBox (
	    `VSpacing (1),
	    `ComboBox (`id (`optname), `opt (`editable),
		// combobox header
		_("&Selected Option"), optnames),
	    `VSpacing (1),
	    `HBox (
		`HStretch (),
		`PushButton (`id (`ok), `opt (`key_F10, `default),
		    OKButtonLabel ()),
		`HSpacing (1),
		`PushButton (`id (`cancel), `opt (`key_F9), CancelButtonLabel ()),
		`HStretch ()
	    ),
	    `VSpacing (1)
	), `HSpacing (1));
	UI::OpenDialog (widget);
	UI::SetFocus (`id (`optname));
	any ret = nil;
	any option = nil;
	while (ret != `ok && ret != `cancel)
	{
	    ret = UI::UserInput ();
	    if (ret == `ok)
	    {
		option = UI::QueryWidget (`id (`optname), `Value);
	    }
	}
	UI::CloseDialog ();
	if (ret == `cancel)
	    return nil;
// FIXME make added option selected
//	selected_opt = option;
	return option;
    }

    /**
      * Gets the widget for editing specified bootloader option
      * @param optname any option name
      * @param ot any option type (`global, "image", "other",...
      *   may be bootloader dependent)
      * @return term widget
      */
    global define term getSpecificOptionWidget (any optname, any ot) ``{
	map widget_data = getPopupWidget (optname);
        term widget = widget_data["widget"]:nil;
	list sect = BootCommon::current_section;
        if (widget == nil)
        {
            string type = widget_data["type"]:lookup (
                BootCommon::opttypes (), optname, "s");
            if (type == "b")
		// checkbox
                widget = `CheckBox (`id (`value),
		    widget_data["widget_label"]:_("&Set"),
                    lookup_value (sect, optname, true));
            else if (type == "i")
		// intfield header
                widget = `IntField (`id (`value),
		    widget_data["widget_label"]:_("&Value"), 0, 999999,
		    lookup_value (sect, optname, 0));
            else
		// textentry header
                widget = `TextEntry (`id (`value),
		    widget_data["widget_label"]:_("&Value"),
		    lookup_value (sect, optname, ""));
        }
        return widget;
    }

    /**
      * Display and handle the popup for option
      * @param opttype any option type (`global, "image", "other",...
      *   may be bootloader dependent)
      * @param optname any option name
      * @return symbol `ok or `cancel
      */
    global define symbol singleOptionEditPopup (any opttype, any optname)``{
        if (optname == "")
        {
	    optname = getOptionChoicePopup (any opttype);
	    BootCommon::current_option_index = -2;
	    if (optname == nil)
		return;
        }

	BootCommon::current_option_name = optname;
	map widget_data = getPopupWidget (optname);

	y2debug ("Popup widget: %1", widget_data);
        string label = sformat ("%1", widget_data["label"]:optname);
        term header = `HBox (
	    // heading / label
	    `Heading (_("Current Option: ")),
	    `Label (label),
	    `HStretch ()
	);
        term widget = getSpecificOptionWidget (optname, opttype);
	string help = widget_data["help"]:"";
	if (help == nil)
	{
	    help = "";
	}
        term contents = `HBox (`HSpacing (1), `VBox (
	    `VSpacing (1),
            `Left (header),
	    `VSpacing (1),
	    help == "" ? `VSpacing (0)
		: `Left (`Label (help)),
            `VSpacing (help == "" ? 0 : 1),
            `Left (`ReplacePoint(`id (`value_rp), widget)),
	    `VSpacing (1),
            `HBox (
                `HStretch(),
		`PushButton (`id (`ok), `opt (`key_F10, `default),
		    OKButtonLabel ()),
		`HSpacing (1),
                `PushButton (`id (`cancel), `opt (`key_F9), CancelButtonLabel ()),
                `HStretch ()
            ),
	    `VSpacing (1)
        ), `HSpacing (1));
        UI::OpenDialog (contents);
	if (widget_data["restore"]:nil != nil)
	{
	    eval (widget_data["restore"]:nil);
	}
	else
	{
	    any old_value = UI::QueryWidget (`id (`value), `Value);
	    any value = nil;
	    if (BootCommon::current_option_index >= 0
		&& ! BootCommon::getBooleanAttrib ("key_only_once")
		&& ! widget_data["key_only_once"]:false)
	    {
		value = lookupValueByIndex (BootCommon::current_section,
		    BootCommon::current_option_index, old_value);
		UI::ChangeWidget (`id (`value), `Value, value);
	    }
	    else
	    {
		value = lookup_value (BootCommon::current_section,
		    optname, old_value);
		if (BootCommon::current_option_index >= 0)
		    BootCommon::current_option_index = -1;
	    }
	    UI::ChangeWidget (`id (`value), `Value, value);
	    UI::SetFocus (`id (`value));
	}
        any ret = nil;
        while (ret != `ok && ret != `cancel)
        {
            ret = UI::UserInput ();
	    if (ret != `ok)
	    {
		if (widget_data["handle"]:nil != nil)
		{
		    term toEval = widget_data["handle"]:nil;
		    toEval = add (add (toEval, ret), false);
		    eval (toEval);
		}
		else
		    UI::SetFocus (`id (`value));
	    }
	    if (ret == `ok)
	    {
		if (widget_data["validate"]:nil != nil
		    && ! eval (widget_data["validate"]:nil))
		{
		    ret = nil;
		}
		if (widget_data["handle"]:nil != nil)
		{
		    term toEval = widget_data["handle"]:nil;
		    toEval = add (add (toEval, `ok), true);
		    eval (toEval);
		}
		else
		{
		    any value = UI::QueryWidget (`id (`value), `Value);
		    // existing value, ordered
		    if (BootCommon::current_option_index >= 0
			&& ! BootCommon::getBooleanAttrib ("key_only_once")
			&& ! widget_data["key_only_once"]:false)
		    {
			BootCommon::current_section = setValueByIndex (
			    BootCommon::current_section,
			    BootCommon::current_option_index,
			    BootCommon::current_option_name, value);
		    }
		    // new value, ordered
		    else if (BootCommon::current_option_index == -2
	                && ! BootCommon::getBooleanAttrib ("key_only_once")
                        && ! widget_data["key_only_once"]:false)
		    {
			BootCommon::current_section = appendValue (
			    BootCommon::current_section, optname, value);
		    }
		    // unordered value - replace old if exists
		    else
		    {
			BootCommon::current_section = modifySection (
			    BootCommon::current_section, optname, value);
		    }
		}
		BootCommon::markOptionChanged ( `current_section, optname);
//		    BootCommon::current_section_name, optname);
	    }
        }
        UI::CloseDialog ();
	return ret;
    }

    global integer selected_opt = nil;
    global list current_dialog_options = [];

    /**
      * Read seettings to the table of section configuration
      */
    global define void singleSectionRead () ``{
        list orig = BootCommon::current_section;
	list items = [];

	integer counter = -1;
	list options = maplist (`o, orig, ``{
	    counter = counter + 1;
	    o["index"] = counter;
	});
	options = Bootloader::blUpdateOptionsList (orig);
	map intern = lookup_value (options, "__intern__", $[]);
	list changed_opts = intern["changed_opts"]:[];

	options = filter (`o, options,
	    ``(o["key"]:"" != "__intern__"));

	options = maplist (`o, options, ``{
	    if (contains (changed_opts, o["key"]:""))
		o["changed"] = true;
	    return o;
	});
	current_dialog_options = options;

	map opts = getPopupWidgets ();
	counter = 0;

	foreach (`o, options, ``{
	    map widget = opts[o["key"]:""]:$[];
	    string label = sformat ("%1", widget["label"]:o["key"]:"");
	    term toEval = widget["summary"]:nil;
	    string value = "";
	    if (toEval == nil)
		value = sformat ("%1", o["value"]:"");
	    else
		value = eval (toEval);
	    string chng = o["changed"]:false ? "*" : "";
	    items = add (items, `item (`id (counter), chng, label, value));
	    counter = counter + 1;
	});
	selected_opt = 0;
	UI::ChangeWidget (`id (`settings), `Items, items);
	singleSectionHandle (`settings, false);
	UI::ChangeWidget (`id (`add), `Enabled, Bootloader::blOptions() != nil);
    }

    /**
      * Handle function of widget
      * @param op any operation to handle
      * @param save boolean true if op should lead to closing & saving widget
      * @return any changed op (if needed)
      */
    global define any singleSectionHandle (any op, boolean save) ``{
	symbol ret = nil;
	integer prev = selected_opt;
	selected_opt = UI::QueryWidget (`id (`settings), `CurrentItem);
	string selected_key
	    = current_dialog_options[selected_opt, "key"]:"";
	BootCommon::current_option_index = current_dialog_options[
	    selected_opt, "index"]:-1;
	y2debug ("Key: %1, Index: %2", selected_key,
	    BootCommon::current_option_index);
	y2debug ("Current section: %1", BootCommon::current_section);
        if (op == `settings)
        {
            selected_opt = UI::QueryWidget (`id (`settings), `CurrentItem);
	    if (selected_key == "__sep1" || selected_key == "__sep2"
		|| selected_key == "__sep3")
	    {
		if (selected_opt + 1 >= size (current_dialog_options))
		    prev = selected_opt + 1;
		selected_opt = prev < selected_opt
		    ? selected_opt + 1
		    : selected_opt - 1;
		UI::ChangeWidget(`id(`settings), `CurrentItem, selected_opt);
	    }
	    map cur = getPopupWidget (selected_key);
	    UI::ChangeWidget (`id (`delete), `Enabled, cur["deletable"]:true);
        }
        else if (op == `edit)
        {
	    if (selected_key == "__default_section")
		selected_key = "__sections";
	    if (selected_key == "__sections")
	    {
		BootCommon::sections_changed = false;
		return `sections;
	    }
           if (selected_key == "__sep1" || selected_key == "__sep2"
		    || selected_key == "__sep3")
		return nil;
            ret = singleOptionEditPopup (
		BootCommon::getSectionType (BootCommon::current_section),
		selected_key);
        }
        else if (op == `add)
        {
            ret = singleOptionEditPopup (
		BootCommon::getSectionType (BootCommon::current_section), "");
        }
        else if (op == `delete && confirmOptionDeletePopup ())
        {
	    map cur = getPopupWidget (item);
	    term toEval = cur["delete"]:nil;
	    if (toEval != nil)
		eval (toEval);
	    BootCommon::current_section = remove (
		BootCommon::current_section, item);
	    BootCommon::one_section_changed = true;
	    ret = `ok;
        }
	// ORDERING BUTTONS
	else if (op == `up)
	{
	    BootCommon::current_section = BootCommon::filterOrder (
		BootCommon::current_section, getPopupWidgets ());
	    integer index = -1;
	    find (`o, BootCommon::current_section, ``{
		index = index + 1;
		return o["key"]:"" == selected_key;
	    });
	    BootCommon::current_section = BootCommon::swapItems (
		BootCommon::current_section, index, index - 1);
		// FIXME global sect if will be needed
	    BootCommon::one_section_changed = true;
	    ret = `ok;
	}
	else if (op == `down)
	{
	    BootCommon::current_section = BootCommon::filterOrder (
                BootCommon::current_section, getPopupWidgets ());
            integer index = -1;
            find (`o, BootCommon::current_section, ``{
                index = index + 1;
                return o["key"]:"" == selected_key;
            });
            BootCommon::current_section = BootCommon::swapItems (
		BootCommon::current_section, index, index + 1);
		// FIXME global sect if will be needed
	    BootCommon::one_section_changed = true;
	    ret = `ok;
	}

	if ((op == `add || op == `edit || op == `delete || op == `up
	    || op == `down) && ret == `ok)
	{
	    if (BootCommon::current_section_name == `global)
	    {
		BootCommon::current_globals = BootCommon::current_section;
		BootCommon::storeSettings ();
		readWidgets (getWidgets(["globalsection"]));
	    }
	    else
	    {
		readWidgets (getWidgets(["singlesection"]));
	    }
	    UI::ChangeWidget (`id (`settings), `CurrentItem, selected_opt);
	}
	if (save && BootCommon::current_section_name != `global)
	{
	    string ls = BootCommon::getSectionTitle ();
	    string old_name = BootCommon::current_section_name;
	    y2milestone ("Old name: %1", old_name);
	    map intern = lookup_value (BootCommon::current_section,
		"__intern__", $[]);
	    intern["changed"] = true;
	    BootCommon::current_section = modifySection (
		BootCommon::current_section, "__intern__", intern);
	    boolean found = false;
	    BootCommon::current_sections = maplist (`s,
		BootCommon::current_sections,
	    ``{
		if (lookup_value (s, ls, "") == old_name)
		{
		    found = true;
		    return BootCommon::current_section;
		}
		else
		    return s;
	    });
	    if (! found)
	    {
		BootCommon::current_sections = add (
		    BootCommon::current_sections,
		    BootCommon::current_section
		);
	    }
	    y2milestone ("Saving section");
	    if (BootCommon::one_section_changed)
		BootCommon::sections_changed = true;
	}
	if (`back == op)
	{
	}
	UI::SetFocus (`id (`settings));
	return nil;
    }

    /**
      * Handle function of widget
      * @param op any operation to handle
      * @param save boolean true if op should lead to closing & saving widget
      * @return any changed op (if needed)
      */
    global define any globalSectionHandle (any op, boolean save) ``{
	any ret = singleSectionHandle (op, save);
	if (op == `sections)
	{
	}
	if (op == `delete)
	    BootCommon::changed = true;
	return ret;
    }


    /**
      * Handle function of widget
      * @param op any operation to handle
      * @param save boolean true if op should lead to closing & saving widget
      * @return any changed op (if needed)
      */
    global define any resetButtonHandle (any op, boolean save) ``{
        if (op == `restore_mbr)
        {
            boolean doit = restoreMBRPopup (BootCommon::mbrDisk);
	    y2milestone ("Rewrite MBR with saved one: %1", doit);
	    if (doit)
	    {
		boolean ret = BootCommon::restoreMBR (BootCommon::mbrDisk);
		if (ret)
		    // message popup
		    UI::MessagePopup (_("MBR restored successfully"));
		else
		    // message popup
		    UI::MessagePopup (_("Failed to restore MBR"));
	    }
            return;
        }

	if (! contains ([`scratch, `reread, `propose_deep, `propose], op))
	{
	    return;
	}
	Bootloader::Reset ();
	if (op == `scratch)
	{
	}
	else if (op == `reread)
	{
	    Bootloader::Read ();
	}
	else if (op == `propose_deep)
	{
	    import "BootGRUB";
	    BootGRUB::deep_propose = true;
	    Bootloader::Propose ();
	}
	else if (op == `propose)
	{
	    if (Bootloader::getLoaderType () == "grub")
	    {
		import "BootGRUB";
		BootGRUB::deep_propose = false;
	    }
	    Bootloader::Propose ();
	}
        BootCommon::fetchSettings ();
        BootCommon::current_section = eval (BootCommon::current_globals);
        BootCommon::current_section_name = `global;

	readWidgets (getWidgets(["globalsection"]));
    }

    /**
      * Ask for bootlaoder switch method
      * @param from string current spooler
      * @param to string new spooler
      * @param type of switching,
      *   `proposal for switching proposed because of disks changed
      *   `user for switching upon user's request
      * @return symbol method
      */
    global define symbol askSwitch (string from, string to, symbol type) ``{
	// warning - popup
	string label = type == `user ? _("Warning!

You chose to change your boot loader. When converting 
the configuration, some settings may be lost.

The current configuration will be saved and you will be able
to restore it if you return to the current boot loader.

Select a course of action:
")
		// warning - popup
	    : sformat (_("Warning!

Your partitioning setup has changed. It is recommended
to use %1 with the current partitioning setup. 

When converting the configuration, some settings may be lost.
The current configuration will be saved and you will be able
to restore it if you return to the current boot loader.

Switch boot loader?"), BootCommon::getLoaderName (to));

	term contents = `VBox (
		// warning label
	    `Label (label),
	    `VSpacing (1),
	    `RadioButtonGroup (`id (`action), `VBox (
		canConvert (from, to)
		    ? `Left (`RadioButton (`id (`convert),
			// radiobutton
			_("Co&nvert Current Configuration")))
		    : `VSpacing (0),
		type == `proposal ? `VSpacing (0)
		: `Left (`RadioButton (`id (`scratch),
		    // radiobutton
		    _("&Start New Configuration from Scratch"))),
		`Left (`RadioButton (`id (`propose),
		    // radiobutton
		    _("&Propose New Configuration"))),
		Mode::normal
		    ? `Left (`RadioButton (`id (`read),
			// radiobutton
			_("&Read Configuration Saved on Disk")))
		    : `VSpacing (0),
		BootCommon::other_bl[to]:nil == nil || type == `proposal
		    ? `VSpacing (0)
		    : `Left (`RadioButton (`id (`prev),
			// radiobutton
			_("Res&tore Configuration Saved before Conversion")))
	    )),
	`VSpacing (1),
	`HBox (
	    `HStretch (),
	    `PushButton (`id (`ok), `opt (`key_F10), OKButtonLabel ()),
	    `HSpacing (1),
	    `PushButton (`id (`cancel), `opt (`key_F9), CancelButtonLabel ()),
	    `HStretch ()
	));
	UI::OpenDialog (contents);
	UI::ChangeWidget (`id (`convert), `Value, true);
	symbol ret = UI::UserInput ();
	symbol action = UI::QueryWidget (`id (`action), `CurrentButton);
	UI::CloseDialog ();
	if (ret != `ok)
	    return nil;
	return action;
    }

    /**
      * Handle function of widget
      * @param op any operation to handle
      * @param save boolean true if op should lead to closing & saving widget
      * @return any changed op (if needed)
      */
    global define any loaderTypeSave (any op, boolean save) ``{
	if (! save)
	    return;

	string old_bl = Bootloader::getLoaderType ();
	string new_bl = UI::QueryWidget (`id (`loader_type), `Value);
	if (old_bl == new_bl)
	    return;

	symbol action = askSwitch (old_bl, new_bl, `user);
	if (nil != action)
	{
	    y2milestone ("Switching bootloader");
	    BootCommon::other_bl[old_bl] = Bootloader::Export ();
	    BootCommon::setLoaderType (new_bl);

            if (action == `scratch)
		Bootloader::Reset ();
            else if (action == `read)
                Bootloader::Read ();
            else if (action == `propose)
	    {
		Bootloader::Reset ();
                Bootloader::Propose ();
	    }
            else if (action == `convert)
                convertSettings (old_bl, new_bl);
            else if (action == `prev)
                Bootloader::Import (BootCommon::other_bl[new_bl]:$[]);

	    BootCommon::fetchSettings ();
            BootCommon::current_section = eval (BootCommon::current_globals);
            BootCommon::current_section_name = `global;
	}
	BootCommon::location_changed = true;
	return nil;
    }


    /**
      * Generic function to create dialog and handle it's events
      * @param widgets list of widget maps
      * @param caption string dialog caption
      * @param contents term contents of dialog
      * @param help string help for the dialog
      * @param next_button string label of next button
      * @param exits list of symbols representing events to exit dialog
      * @param back whether should be Abort/Back buttons shown (true),
      *   or only Cancel button
      * @return symbol wizard sequencer symbol
      */
    global define symbol runDialog (list widgets, string caption,
	term contents, string help, string next_button, list exits,
	boolean back)
    ``{
	Wizard::SetContentsButtons (caption, contents, help,
	    BackButtonLabel (), next_button);
	if (back)
	{
	    Wizard::RestoreBackButton ();
	    Wizard::RestoreAbortButton ();
	}
	else
	{
	    Wizard::ReplaceBackButton(`VSpacing (0));
	    Wizard::ReplaceAbortButton (
		`PushButton (`id (`abort), CancelButtonLabel ()));
	}

	readWidgets (widgets);

	any ret = nil;
	while (! contains (exits, ret))
	{
	    ret = UI::UserInput ();
	    if (ret == `cancel)
		ret = `abort;
	    if (ret == `abort && ! BootCommon::confirmAbort ())
		ret = nil;
	    if (! validateWidgetsIfNeeded (widgets, ret))
		ret = nil;
	    ret = handleChange (widgets, ret);
	}
	return ret;
    }

    /**
      * Redraw the summary text
      */
    global define void redrawSummary () ``{
	UI::ChangeWidget (`id (`summary), `Value,
	    Bootloader::blSummary (
		BootCommon::verbose ? [`verbose, `links] : [`links]));
    }

    /**
      * Run dialog for sections managment
      * @return symbol wizard sequencer symbol
      */
    global define symbol runSectionsDialog () ``{
        list widgets = getWidgets (["sections"]);
        term contents = `HBox (`HSpacing (2), `VBox (
		`VSpacing (1),
                widgets[0, "widget"]:`VSpacing (0),
                `VSpacing (1)
                ), `HSpacing (2));
	// dialog caption
        string caption = _("Boot Loader Setup -- Sections Managment");
        string help = mergeHelps (widgets);
	list exits = getExitEvents (widgets);
	return runDialog (widgets, caption, contents, help, OKButtonLabel (),
	    exits, true);
    }

    /**
      * Run dialog for single section managment
      * @return symbol wizard sequencer symbol
      */
    global define symbol runSingleSectionDialog () ``{
	list widgets = getWidgets (["singlesection"]);
        term contents = `HBox (`HSpacing (2), `VBox (
                `VSpacing (1),
                widgets[0, "widget"]:`VSpacing (0),
		`VSpacing (1)
                ), `HSpacing (2));
	// dialog caption
        string caption = _("Boot Loader Setup -- Sections Managment");
        string help = mergeHelps (widgets);
        list exits = getExitEvents (widgets);
        return runDialog (widgets, caption, contents, help, OKButtonLabel (),
            exits, true);
    }

    /**
      * Run main summary dialog
      * @return symbol wizard sequencer symbol
      */
    global define symbol runSummaryDialog () ``{
	BootCommon::fetchSettings ();
	BootCommon::current_section
	    = eval (BootCommon::current_globals);
	BootCommon::current_section_name = `global;
        list widgets = getWidgets (["globalsection", "manual_edit_button",
	    "resetbutton"]);
        term contents = `HBox (`HSpacing (2), `VBox (
                `VSpacing (1),
                widgets[0, "widget"]:`VSpacing (0),
                `VSpacing (1),
                widgets[1, "widget"]:`VSpacing (0),
                `VSpacing (1)
                ), `HSpacing (2));
	// dialog caption
        string caption = _("Boot Loader Setup");
        string help = mergeHelps (widgets);
        list exits = getExitEvents (widgets);
	string next_button = (Mode::initial || Mode::config)
	    ? AcceptButtonLabel ()
	    : FinishButtonLabel ();

        return runDialog (widgets, caption, contents, help, next_button,
            exits, false);
    }

    /**
      * Run dialog
      * @return symbol for wizard sequencer
      */
    global define symbol runEditFilesDialog () ``{
        map files = Bootloader::blGetFiles ();
	string default = files["default"]:"";
	files = filter (`k, `v, files, ``(k != "default"));
        list filenames = [];
        foreach (`k, `v, files, ``{
            filenames = add (filenames, k);
        });
	term cb = nil;
	if (size (files) > 1)
	    cb = `ComboBox (`id (`filename), `opt (`notify, `hstretch),
		// combobox label
		_("&File Name"), filenames);
	else
	    // label. %1 is name of file (eg. /etc/lilo.conf
	    cb = `Left (`Label (sformat (_("File Name: %1"), filenames[0]:"")));

	term contents = `HBox (`HSpacing (2), `VBox (
            `VSpacing (2),
	    cb,
            `VSpacing (2),
            `MultiLineEdit (`id (`file), `opt (`hstretch, `vstretch),
		// multiline edit header
                _("Fi&le Contents")),
            `VSpacing (2)
	), `HSpacing (2));

	// dialog caption
        string caption = _("Expert Manual Configuration");
        string help = BootCommon::getExpertManualHelp ();

        list exits = getExitEvents ([]);

        Wizard::SetContentsButtons (caption, contents, help,
            BackButtonLabel (), OKButtonLabel ());

	Wizard::RestoreBackButton ();
	Wizard::RestoreAbortButton ();

	string filename = filenames[0]:"";
	if (default != "")
	    filename = default;
	if (size (files) > 1)
	    UI::ChangeWidget (`id (`filename), `Value, filename);
	UI::ChangeWidget (`id (`file), `Value, files[filename]:"");

        any ret = nil;
        while (! contains (exits, ret))
        {
            ret = UI::UserInput ();
	    if (ret == `filename)
	    {
		files[filename] = UI::QueryWidget (`id (`file), `Value);
		filename = UI::QueryWidget (`id (`filename), `Value);
		UI::ChangeWidget (`id (`file), `Value, files[filename]:"");
	    }
	    if (ret == `next)
	    {
		files[filename] = UI::QueryWidget (`id (`file), `Value);
		Bootloader::blSetFiles (files);
		BootCommon::changed = true;
		BootCommon::location_changed = true;
	    }
	    if (ret == `abort)
	    {
		if (! confirmAbortPopup ())
		    ret = nil;
	    }
        }
        return ret;
    }


    /**
      * Get generic aliases
      * @return map aliases
      */
    global define map getAliases () ``{
	return $[
	    "summary" : ``(runSummaryDialog ()),
// general routines
	    "fetch" : [``(BootCommon::fetchSettings ()), true],
	    "store" : [``(BootCommon::storeSettings ()), true],
// expert edit dialog
	    "editfiles" : ``(runEditFilesDialog ()),
// global settings dialogs
	    "globals" : ``(runGlobalsDialog ()),
	    "target" : ``(runTargetDialog ()),
// sections managment dialogs
	    "sects" : ``(runSectionsDialog ()),
	    "singlesect" : ``(runSingleSectionDialog ()),
// sequences definitions
	    "global_seq" :
		``(WizardSequencer (aliases, ws_data["glob_seq"]:$[])),
	    "sect_seq" :
		``(WizardSequencer (aliases, ws_data["sect_seq"]:$[])),
	];
    }


    /**
      * Run wizard sequencer
      * @return `next, `back or `abort
      */
    global define symbol runWizard () ``{

	map glob_seq = $[
	    "ws_start" : "fetch",
	    "fetch" : $[ `next : "globals", `abort: `abort],
	    "globals" : $[ `next: "target", `abort: `abort ],
	    "target" : $[ `next: "store", `abort: `abort ],
	    "store" : $[ `next: `next, `abort: `abort ],
	];

	map sect_seq = $[
	    "ws_start" : "fetch",
	    "fetch" : $[ `next : "sects", `abort: `abort],
	    "sects" : $[ `next: "store", `add : "singlesect",
		`edit : "singlesect", `abort: `abort ],
	    "singlesect" : $[ `next: "sects", `abort: `abort],
	    "store" : $[ `next: `next, `abort: `abort ],
	];

	map normal_sequence = $[
	    "ws_start" : "summary",
	    "summary" : $[
		`next: `next,
		`abort: `abort,
		`glob : "global_seq",
		`manual : "editfiles",
		`sections : "sect_seq",
	     ],
	    "editfiles" : $[ `next : "summary", `abort: `abort ],
	    "global_seq" : $[ `next : "summary", `abort: `abort ],
	    "sect_seq" : $[ `next : "summary", `abort: `abort ],
	];

	map ws_data = $[
	    "start_seq" : "startseq",
	    "startseq" : normal_sequence,
	    "glob_seq" : glob_seq,
	    "sect_seq" : sect_seq,
	];

	// add specific aliases and modify sequence if needed
	ws_data = Bootloader::blGetSequence (ws_data);

	map aliases = getAliases ();
	// merge new aliases
	foreach (`k, `v, ws_data["aliases"]:$[], ``{
	    aliases[k] = v;
	});
	string start_seq = ws_data["start_seq"]:"";
	map sequence = ws_data[start_seq]:$[];

	// run wizard
	y2milestone ("Starting wizard sequencer");
	return WizardSequencer (aliases, sequence);
    }

}
