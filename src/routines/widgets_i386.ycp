/**
 * File:
 *      include/bootloader/routines/widgets_i386.ycp
 *
 * Module:
 *      Bootloader installation and configuration
 *
 * Summary:
 *      Widgets for being used by bootloader for i368
 *
 * Authors:
 *      Jiri Srain <jsrain@suse.cz>
 *
 * $Id$
 *
 */


{

textdomain "bootloader";

include "bootloader/routines/helps.ycp";
include "bootloader/routines/popups.ycp";
include "bootloader/grub/helps.ycp";

void InitDiskOrder(string widget) {
  list<string> disksOrder = BootCommon::DisksOrder ();

  UI::ChangeWidget ( `id(`disks), `Items, disksOrder);
  UI::ChangeWidget (`id (`disks), `CurrentItem, disksOrder[0]:"");
}

string GetItemID(term t){
  return argsof((term)argsof(t)[0]:`id(""))[0]:"";
}

void StoreDiskOrder(string widget, map event) {
  list<term> disksOrder = (list<term>)UI::QueryWidget(`id(`disks), `Items);
  list<string> result = (list<string>) maplist(term t, disksOrder, {
    return GetItemID(t);
  });
  BootCommon::mbrDisk = result[0]:"";
  integer index = 0;
  BootCommon::device_mapping = listmap (string d, result, {
    string indexs = tostring(index);
    index = index + 1;
    return $[ d : sformat ("hd%1", indexs)];
  });
}

string NewDevicePopup(){
  term popup = `VBox (`VSpacing (1),
      // textentry header
      `InputField (`id (`devname), `opt (`hstretch), _("&Device")),
      `VSpacing (1),
       `HBox (`HStretch (),
          `PushButton (`id (`ok), `opt (`key_F10, `default),
              Label::OKButton ()),
          `HStretch (),
          `PushButton (`id (`cancel), `opt (`key_F8),
              Label::CancelButton ()),
          `HStretch ()
      ),
      `VSpacing (1)
  );
  UI::OpenDialog (popup);
  symbol pushed = (symbol)UI::UserInput ();
  string new_dev = (string) UI::QueryWidget (`id (`devname), `Value);
  UI::CloseDialog ();
  string ret = "";
  if (pushed == `ok){
    ret = new_dev;
  }
  return ret;
}


symbol HandleDiskOrder( string widget, map event ){
  any action = event["ID"]:nil;
  boolean changed = false;
  list<term> disksOrder = (list<term>)UI::QueryWidget(`id(`disks), `Items);
  string current = (string)UI::QueryWidget (`id (`disks), `CurrentItem);
  integer pos = 0;
  while (pos < size (disksOrder)
    && GetItemID(disksOrder[pos]:`Item(`id(""))) != current)
        pos = pos + 1;

  //disabling & enabling up/down
  UI::ChangeWidget (`id (`up), `Enabled, pos > 0 && pos < size (disksOrder));
  UI::ChangeWidget (`id (`down), `Enabled, pos < size (disksOrder) - 1);

  if (action == `up){
    changed= true;
    disksOrder =
      (list<term>) BootCommon::swapItems (disksOrder, pos, pos - 1);
  } else if (action == `down){
    changed= true;
    disksOrder =
          (list<term>) BootCommon::swapItems (disksOrder, pos, pos + 1);
  } else if (action == `delete){
    changed = true;
    disksOrder = remove(disksOrder,pos);
    UI::ChangeWidget (`id (`disks), `CurrentItem,
        (pos > 0) ? GetItemID(disksOrder[(pos-1)]:`Item(`id("")))
                  : GetItemID(disksOrder[0]:`Item(`id(""))));
  } else if (action == `add) {
    string new_dev = NewDevicePopup();
    if (new_dev != ""){
      changed = true;
      disksOrder = add(disksOrder, `item(`id(new_dev),new_dev));
    }
  }

  if (changed){
    UI::ChangeWidget (`id (`disks), `Items, disksOrder);
  }
}

boolean ValidateDiskOrder(string key, map event) {
  list<term> disksOrder = (list<term>)UI::QueryWidget(`id(`disks), `Items);
  if (size(disksOrder)>0)
    return true;
  Popup::Warning(_("Device map must contain at least one device"));
  return false;
}

map<string,any> DisksOrderWidget(){
  term contents = `HBox (`HSpacing (2), `VBox (
                        `VSpacing (1),
                        `SelectionBox (`id (`disks),
                          `opt (`notify, `immediate),_("D&isks"), []),
                        `HBox(
                                `HStretch (),
                                `PushButton (`id (`add),
                                `opt (`key_F3), Label::AddButton ()),
                                `PushButton (`id (`delete),
                                `opt(`key_F5), Label::DeleteButton ()),
                                `HStretch ()
                        ),
                        `VSpacing (1)
                       ),
                       `HSquash (
                            `VBox (
                                 `VStretch (),
                                 `PushButton (`id (`up),
                                 `opt (`hstretch), _("&Up")),
                                 `PushButton (`id (`down),
                                 `opt (`hstretch), _("&Down")),
                                 `VStretch ()
                            )
                       ),
                       `HSpacing (2)
                     );
  return $[
    "widget" : `custom,
    "custom_widget" : contents,
    "init" : InitDiskOrder,
    "handle" : HandleDiskOrder,
    "store" : StoreDiskOrder,
    "help" : i386InstallDetailsHelp (),
    "validate_type" : `function,
    "validate_function" : ValidateDiskOrder
  ];
}


/**
 * Init function of a widget
 * @param widget string widget key
 */
void  InitBootLoaderLocationWidget(string widget) {
    list<string> boot_devices = BootCommon::getPartitionList(`boot);
    list <string> list_global_target_keys = ["boot_mbr", "boot_boot", "boot_root", "boot_extended"];
    foreach(string key, list_global_target_keys, 
    {
	string value = BootCommon::globals[key]:nil;
	if (value != nil)
	    UI::ChangeWidget (`id (key), `Value, (value == "true")? true: false);
    });
    UI::ChangeWidget (`id ("boot_custom_list"),`Items, boot_devices);
    if ((!haskey(BootCommon::globals,"boot_custom")) && 
        (BootCommon::globals["boot_custom"]:"" == ""))
    {
	UI::ChangeWidget (`id ("boot_custom_list"),`Enabled, false);
    } else {
	UI::ChangeWidget (`id ("boot_custom"), `Value, true);
	UI::ChangeWidget (`id ("boot_custom_list"),`Enabled, true);
	UI::ChangeWidget (`id ("boot_custom_list"),`Value, BootCommon::globals["boot_custom"]:"");
    }
}
/**
 * handle function of a widget
 * @param widget string widget key
 * @param event map event that caused the operation
 * @return symbol
 */
symbol HandleBootLoaderLocationWidget (string widget, map event) {
    any ret = event["ID"]:nil;
    if (ret == "boot_custom")
    {
	if ((boolean)UI::QueryWidget(`id("boot_custom"), `Value))
	    UI::ChangeWidget (`id ("boot_custom_list"),`Enabled, true);
	else
	    UI::ChangeWidget (`id ("boot_custom_list"),`Enabled, false);
    }
    return nil;
}


/**
 * Store function of a widget
 * @param widget string widget key
 * @param event map event that caused the operation
 */
void StoreBootLoaderLocationWidget (string widget, map event) {

    list <string> list_global_target_keys = ["boot_mbr", "boot_boot", "boot_root", "boot_extended"];
    foreach(string key, list_global_target_keys, 
    {
	string value = ((boolean)UI::QueryWidget(`id(key), `Value))?"true":"false";
	BootCommon::globals[key]= value;
    });
    if ((boolean)UI::QueryWidget(`id("boot_custom"), `Value))
	BootCommon::globals["boot_custom"]= (string)UI::QueryWidget(`id("boot_custom_list"), `Value);
}

/** FIXME: merge help text to one for BootLoaderLocationWidget
 *  Function merge help text from ../grub/helps.ycp
 *
 * @return string help text for widget BootLoaderLocationWidget 
 */
string  HelpBootLoaderLocationWidget()
{
    string ret = "";
    ret = grub_help_messages["boot_mbr"]:"";
    ret = ret + "\n";
    ret = ret + grub_help_messages["boot_root"]:"";
    ret = ret + "\n";
    ret = ret + grub_help_messages["boot_boot"]:"";
    ret = ret + "\n";
    ret = ret + grub_help_messages["boot_extended"]:"";
    ret = ret + "\n";
    ret = ret + grub_help_messages["boot_custom"]:"";
    return ret;
}

map<string,any> grubBootLoaderLocationWidget ()
{
    term contents = `VBox (
	`Frame (_("Boot Loader Location"),
	   `VBox (`HBox(`HSpacing(1),`VBox(
	       `Left(`CheckBox( `id("boot_mbr"), _("Boot from &Master Boot Record"))),
	       `Left(`CheckBox( `id("boot_root"), _("Boot from &Root Partition"))),
	       `Left(`CheckBox( `id("boot_boot"), _("Boo&t from Boot Partition"))),
	       `Left(`CheckBox( `id("boot_extended"), _("Boot from &Extended Partition"))),
	       `Left(`CheckBox( `id("boot_custom"), `opt(`notify), _("C&ustom Boot Partition"))),
	       `Left(`ComboBox( `id("boot_custom_list"), `opt (`editable, `hstretch),"", [])),
	       `VStretch()
            )))
         ),
	`VStretch()	
    );
 
    return $[
      "widget" : `custom,
      "custom_widget" : contents,
      "init" : InitBootLoaderLocationWidget,
      "handle" : HandleBootLoaderLocationWidget,
      "store" : StoreBootLoaderLocationWidget,
      "help" : HelpBootLoaderLocationWidget(),
  ];
}

/**
 * Handle function of a widget
 * @param widget string widget key
 * @param event map event description of event that occured
 * @return symbol to return to wizard sequencer, or nil
 */
symbol InstDetailsButtonHandle (string widget, map event) 
{
    return `inst_details;
}


map<string,any> grubInstalationDetials ()
{
    return $[
      "widget" : `push_button,
      // push button
      "label" : _("Boot Loader Installation &Details"),
      "handle_events" : ["inst_details"],
      "handle" : InstDetailsButtonHandle,
      "help" : InstDetailsHelp (),
    ];
}



/**
 * Cache for genericWidgets function
 */
map<string,map<string,any> > _grub_widgets = nil;

/**
 * Get generic widgets
 * @return a map describing all generic widgets
 */
global map<string,map<string,any> > grubWidgets () {
    if (_grub_widgets == nil)
    {
	_grub_widgets = $[
	    "loader_location"	  : grubBootLoaderLocationWidget (),
	    "inst_details"	  : grubInstalationDetials (),
	];
    }
    return _grub_widgets;
}


} // include end
