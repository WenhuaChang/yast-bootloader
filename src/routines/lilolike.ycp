/**
 * File:
 *      include/bootloader/routines/lilolike.ycp
 *
 * Module:
 *      Bootloader installation and configuration
 *
 * Summary:
 *      Functions common for lilo-like bootloaders only
 *
 * Authors:
 *      Jiri Srain <jsrain@suse.cz>
 *
 * $Id$
 *
 */
{

    import "StorageDevices";
    import "Storage";

    import "BootCommon";
    import "Mode";
    import "Arch";

    /**
      * Refresh disk locations
      * @return boolean true if bootloader location should be set again
      */
    global define boolean RefreshDisks() ``{
	boolean ret = true;
	if (! DisksChanged ())
	    ret = false;

	y2milestone ("Reconfiguring locations");
	DetectDisks ();

	return ret;
    }

    /**
     *  IsBootAccessible()
     *  @return boolean true if accessible
     */
    global define boolean IsBootAccessible() ``{
	if (Mode::config)
	    return true;
        boolean boot_partition_accessible = true;

        if (!LbaSupport())
        {
            string boot_mount_point = "";
            // check, if no /boot partition exists

            if (lookup (Storage::GetMountPoints(), "/boot", "") == "")
            {
                boot_mount_point = "/";
            }
            else
            {
                boot_mount_point = "/boot";
            }

            // check if boot mount point is below cyl 1024

            foreach (string dname, map ddata, Storage::GetTargetMap(),
            ``{
                list partitions = ddata["partitions"]:[];
                if (partitions != [])
                {
                    foreach (`pentry, partitions,
                    ``{
                        if (pentry["mount"]:"" == boot_mount_point)
                        {
                            boot_partition_accessible =
				(1024 > pentry["region",0]:0);
                        }
                    });
                }

            });

        }
        if (boot_partition_accessible)
            y2milestone("Boot partition accessible");
        else
            y2milestone("Boot partition unaccessible");

        return (boot_partition_accessible);
    }

    /**
      * Check whether disk settings were changed since last checking
      * @return boolean true if needs to recheck
      */
    global define boolean DisksChanged () ``{
	if (Mode::config)
	    return false;
        map mp = Storage::GetMountPoints();
        string actual_root = mp["/", 0]:"";
        string actual_boot = mp["/boot", 0]:actual_root;

        // don't change configuration if '/' and '/boot' were not changed
        // and location is "floppy", "mbr" or "boot"
        if (actual_boot == BootCommon::BootPartitionDevice
            && actual_root == BootCommon::RootPartitionDevice
            && BootCommon::location != "custom"
            && BootCommon::location != "")
        {
            return false;
        }

        if (BootCommon::location == "custom")
        {
	    list all_partitions = BootCommon::getPartitionList(`boot);

            if (!contains(all_partitions, BootCommon::loader_device))
            {
                y2milestone ("Location should be set again");
                return true;
            }
            else if (actual_boot == BootPartitionDevice
                && actual_root == RootPartitionDevice)
            {
                return false;
            }
        }
	return false;
    }

    /**
      * Should backup copy of bootloader bootsector be created?
      * @return boolean true if yes.
      */
    global define boolean createBackupBS () ``{
	if (! Mode::initial)
	    return false;
	map mp = Storage::GetMountPoints ();
	list data = mp["/boot"]:(mp["/"]:[]);
	string bpd = data[0]:"";
	// ???? FIXME ???? how about LVM/MD ????
	return bpd == BootPartitionDevice;
    }

    /**
      * If device is part of RAID (md), then return first of its members
      * otherwise return the same as argument
      * @param device string device of the RAID
      * @return string first member of the RAID
      */
    global define string getDeviceOfRaid (string device) ``{
	// get list of all partitions (not marked to be deleted)
	map tm = Storage::GetTargetMap ();
	list partitions = [];

	foreach ( string dev, map disk, tm, ``{
	    if( Storage::IsRealDisk( dev, disk ) )
	    {
		list l = filter( map p, disk["partitions"]:[],
		    ``(p["delete"]:false==false) );
		partitions = merge (partitions, l);
            }
        });

	// filter partitions to relevant list according to raid name
	list md_list = filter (`e, partitions, ``(e["raid_name"]:"" == device));
	// get the devices
	list dev_list = maplist (`e, md_list, ``(e["device"]:""));
	dev_list = filter (`d, dev_list, ``(d != ""));
	if (size (dev_list) > 0)
	{
	    dev_list = sort (dev_list);
	    return dev_list[0]:"";
	}
	return device;
    }

    /**
      * Detect /boot and / (root) partition devices and store settings
      * to internal variables
      */
    global define void DetectDisks () ``{
/*	map tm = Storage::GetTargetMap ();
	list partitions = [];

	foreach ( string dev, map disk, tm, ``{
	    if( Storage::IsRealDisk( dev, disk ) )
	    {
		list l = filter( map p, disk["partitions"]:[],
		    ``(p["delete"]:false==false) );
		partitions = merge (partitions, l);
            }
        });*/

	if (Mode::config)
	    return;
        map mp = Storage::GetMountPoints();

        list mountdata_boot = mp["/boot"]:(mp["/"]:[]);
	list mountdata_root = mp["/"]:[];

        y2milestone( "mountPoints %1", mp );
        y2milestone( "mountdata_boot %1", mountdata_boot );

        BootCommon::RootPartitionDevice = mp["/", 0]:"";

        if (BootCommon::RootPartitionDevice == "")
        {
            y2error ("No mountpoint for / !!");
        }

        // if /boot changed, re-configure location
        BootCommon::BootPartitionDevice
            = mountdata_boot[0]:BootCommon::RootPartitionDevice;

	if (BootCommon::mbrDisk == "" || BootCommon::mbrDisk == nil)
	{
	    // mbr detection.
	    BootCommon::mbrDisk = FindMbrDisk();
	}

        if (BootCommon::location == "" || BootCommon::location == nil)
            BootCommon::location = ConfigureLocation ();

/*	if (mountdata_boot[3]:"" == "raid1")
	{
	    list md_list = filter (`e, partitions,
		``(e["raid_name"]:"" == mountdata_boot[0]:""));
	    list dev_list = maplist (`e, md_list, ``(e["device"]:""));
	    dev_list = filter (`d, dev_list, ``(d != ""));
	    if (size (dev_list) > 0)
	    {
		dev_list = sort (dev_list);
		BootCommon::BootPartitionDevice = dev_list[0]:"";
	    }
	}
        if (mountdata_root[3]:"" == "raid1")
        {
            list md_list = filter (`e, partitions,
                ``(e["raid_name"]:"" == mountdata_root[0]:""));
            list dev_list = maplist (`e, md_list, ``(e["device"]:""));
            dev_list = filter (`d, dev_list, ``(d != ""));
            if (size (dev_list) > 0)
            {
                dev_list = sort (dev_list);
                BootCommon::RootPartitionDevice = dev_list[0]:"";
            }
        }*/

        BootCommon::loader_device = BootCommon::GetBootloaderDevice ();
/*	if (BootCommon::location != "floppy")
	{
	    BootCommon::activate = true;
	}*/
    }

    /**
     * ConfigureLocation()
     * Where to install the bootloader.
     * It just gives "mbr" or "floppy"
     * @return string location proposed to bootloader
     */
    global define string ConfigureLocation() ``{
        string loc = "mbr";                       // default to mbr
        string device   = BootCommon::mbrDisk;

// this doesn't solve anything, because stage2 must be loaded some way
// nor bootsector on floppy doesn't have any possibility to load it
// see bugzilla 29524
/*        if (!IsBootAccessible()                 // above cyl 1024
            && StorageDevices::FloppyPresent)
        {
            // if we're on an old system without lba support
            // (the last needs a too big initrd, see bugzilla #7864)

            loc = "floppy";                // floppy and fd0
            device   = StorageDevices::FloppyDevice;
        }*/

        y2milestone ("ConfigureLocation (%1 on %2)", loc, device);
        return loc;
    }

    /**
      * FindMbrDisk()
      * try to find the system's mbr device
      * @return string   mbr device
      */
    global define string FindMbrDisk() ``{
        // can hwinfo find the disk ?

        string probed_mbr_disk = SCR::Read(.probe.boot_disk);
        if (probed_mbr_disk != "")
        {
            y2milestone ("MBR probed as %1", probed_mbr_disk);
            return probed_mbr_disk;
        }

	map mp = Storage::GetMountPoints();
        string bootDisk = mp["/boot",2]:(mp["/",2]:"");

        // look for disk with bios_id 0x80
        list disks = SCR::Read(.probe.disk);
	// fallback
        string mbr_disk = disks[0,"dev_name"]:bootDisk;

        foreach (`disk, disks,
        ``{
            if (disk["bios_id"]:"" == "0x80")
            {
                y2milestone ("disk with bios_id 0x80: %1", disk);
                mbr_disk = disk["dev_name"]:bootDisk;
            }
        });

        y2milestone("MBR Disk: %1", mbr_disk);
        return mbr_disk;
    }

    /**
      * Answer whether LBA is supported
      * @return boolean true if supported
      */
    global define boolean LbaSupport() ``{
        if (Arch::i386)
        {
            list internal_bios = SCR::Read (.probe.bios);
            boolean lba_support = internal_bios[0, "lba_support"]:false;
            if (getLoaderType (false) == "lilo")
                return lookup_value (globals, "lba32", lba_support);
            else
                return lba_support;
        }
        else
            return true;
    }

    /**
      * Update /etc/sysconfig/bootloader:LOADER_LOCATION according to
      * current location in bootloader configuration file
      */
    global define void updateLoaderLocation () ``{
	if (! getBooleanAttrib ("bootloader_on_disk"))
	    return;
	// custom is always OK
	if (location == "custom")
	    return;
	// first floppy disk
	if (loader_device == StorageDevices::FloppyDevice)
	{
	    location = "floppy";
	    return;
	}
	// mbr
	if (loader_device == mbrDisk)
	{
	    location = "mbr";
	    return;
	}
	// bootsector of boot partition
	if (loader_device == getDeviceOfRaid (BootPartitionDevice))
	{
	    location = "boot";
	    return;
	}
	// bootsector of root partition
	if (loader_device == getDeviceOfRaid (RootPartitionDevice))
	{
	    location = "root";
	    return;
	}
	// /dev/null or empty means bootloader not installed
	if (loader_device == "/dev/null" || loader_device == "")
	{
	    location = "none";
	    return;
	}
	// other
	location = "custom";
    }

    /**
      * Set default section and loader device in lilo-style bootloader
      */
    global define void finishReading () ``{
        BootCommon::loader_device
            = lookup_value (BootCommon::globals, "boot", "");
        if (lookup_value (BootCommon::globals, "default", "") == "")
        {
            BootCommon::addValueToBootloaderSection (`globals, "default",
                lookup_value (BootCommon::sections[0]:[],
                 "label", ""));
        }
    }

    /**
      * Install the bootloader, display a popup with log if something
      *  goes wrong
      * @param command string command to install the bootloader
      * @param logfile string filename of file used to write bootloader log
      * @return boolean true on success
      */
    global define boolean installBootLoader (string command, string logfile) ``{
	map exit = SCR::Execute (.target.bash_output, command);
	boolean ret = 0 == exit["exit"]:1;
	if (! ret)
	{
	    string log = SCR::Read (.target.string, logfile);
	    log = log + exit["stdout"]:"" + exit["stderr"]:"";
	    if (exit["exit"]:1 == 139)
	    {
		// means: process received signal SIGSEGV
		// please, use some usual translation
		// proofreaders: don't change this text
		log = log + _("Segmentation fault");
	    }

            errorWithLogPopup (sformat (
		// error popup - label, %1 is bootloader name
		_("Error occurred while installing %1"),
		getLoaderName (getLoaderType (false))), log);
	}
	return ret;
    }

    /**
      * Fix global section of lilo-like bootloader
      */
    global define void liloFixGlobals () ``{
	string default = lookup_value (BootCommon::globals, "default", "");
	string first = "";
	if (default != "")
	{
	    boolean exists = false;
	    foreach (`s, BootCommon::sections, ``{
		string label = lookup_value (s, "label", "");


		if (label == default)
		    exists = true;
		if (first == "")
		    first = label;
	    });
	    if (! exists)
		BootCommon::addValueToBootloaderSection (
		    `globals, "default", first);
	}
    }

    /**
      * Fix section of lilo-like bootloader
      */
    global define void liloFixSections () ``{
	list parts = BootCommon::getPartitionList(`parts_old);
	if (BootCommon::partitioning_last_change
		!= Storage::GetTargetChangeTime()
	    && BootCommon::files_edited)
	{
	    displayFilesEditedPopup ();
	    BootCommon::files_edited = false;
	    return;
	}
	list old_sect_list = BootCommon::sections;
	createSections ();
	map new_sect = listmap (`s, BootCommon::sections, ``{
	    string label = lookup_value (s, "label", "");
	    map intern = lookup_value (s, "__intern__", $[]);
	    string type = intern["type"]:label;
	    return [type, s];
	});
	old_sect_list = maplist (`s, old_sect_list, ``{
	    string label = lookup_value (s, "label", "");
	    map intern = lookup_value (s, "__intern__", $[]);
	    string type = intern["type"]:label;
	    if (! intern["auto"]:false)
	    {
		y2milestone ("Leaving section %1", label);
		return s;
	    }
	    else if (! intern["changed"]:false)
	    {
		y2milestone ("Recreating section %1, new is %2",
		    label, new_sect[type]:[]);
		return new_sect[type]:[];
	    }
	    else
	    {
		y2milestone ("Warning on section %1", label);
		boolean cont = true;
                if (type != "linux" && type != "failsafe"
                    && type != "memtest86")
		{
		    foreach (`n, intern["devs"]:[], ``{
		        if (! contains (parts, n))
		        {
			    cont = false;
		        }
		    });
		}
                list new_this_section = new_sect[type]:[];
                map new_this_intern = lookup_value (
                    new_this_section, "__intern__", $[]);
		list new_devs = toset(new_this_intern["devs"]:[]);
		list old_devs = toset(intern["devs"]:[]);
                if (size (new_devs) != size (old_devs))
                    cont = false;
                else
                {
                    foreach (`d, old_devs, ``{
                        if (! contains (new_devs, d))
                            cont = false;
                    });
                }
		if (! cont)
		{
		    intern["auto"] = false;
		    displayDiskChangePopup (label);
		}
		s = maplist( `i, s, ``{
		    if (i["key"]:"" == "__intern__")
			i["value"] = intern;
		     return i;
		});
		return s;
	    }
	});

	y2milestone ("Checking for sections needing some of %1", del_parts);
	list(string) to_remove = [];
	foreach (`s, BootCommon::sections, ``{
	    map intern = lookup_value (s, "__intern__", $[]);
	    list(string) devs = intern["devs"]:[];
	    string label = lookup_value (s, "label", "");
	    y2milestone ("Section %1 needs %2", label, devs);
	    boolean to_add = false;
	    foreach (string d, devs, ``{
		if (contains (del_parts, d))
		{
		    to_add = true;
		}
	    });
	    if (to_add)
	    {
		map old_sect = listmap (`s, old_sect_list, ``{
		    return [label, s];
		});

		if (label != "" && ! haskey(old_sect, label))
		{
		    y2milestone ("Adding %1", s);
		    to_remove = add (to_remove, d);
		    old_sect_list = add (old_sect_list, s);
		}
	    }
	});
	del_parts = BootCommon::difflist (del_parts, to_remove);
	old_sect_list = filter (`s, old_sect_list, ``(s != []));
	BootCommon::sections = old_sect_list;
    }

    /**
      * Filter sections, remove those pointing to unexistent image
      */
    global define void liloRemoveUnexistentSections () ``{
	BootCommon::sections = filter (`s, BootCommon::sections, ``{
	    string label = lookup_value (s, "label", "");
	    map intern = lookup_value (s, "__intern__", $[]);
	    string type = intern["type"]:"";
            if (label == "")
	    {
		y2warning ("Removing section with empty title");
                return false;
	    }
	    if (! contains (["linux", "failsafe", "memtest86"], type))
		return true;

	    string kernel = lookup_value (s, "image", "");
	    if (kernel == "")
		return true;
	    if (SCR::Read (.target.size, kernel) == -1)
	    {
		y2warning ("Removing section %1 with unexistent kernel %2",
		    label, kernel);
		return false;
	    }
	    return true;
	});
    }

    /**
      * Remove or add initrd option if needed, update append option if some
      *  parameters were changed
      */
    global define void liloUpdateIninrdAppend () ``{
        BootCommon::sections = maplist (`s, BootCommon::sections, ``{
            string initrd = lookup_value (s, "initrd", "");
	    string title = lookup_value (s, "label", "");
	    map intern = lookup_value (s, "__intern__", $[]);
	    string type = intern["type"]:"";

            if ((type == "linux" || type == "failsafe")
		&& BootCommon::write_settings["insert_initrd"]:false)
            {
		initrd = "/boot/initrd";
		s = modifySection (s, "initrd", initrd);
            }
            if (initrd != "")
            {
                if (-1 == SCR::Read (.target.size, initrd))
		    s = modifySection (s, "initrd", nil);
            }
            if (type == "linux" && lookup_value (s, "append", nil) != nil
		&& Mode::initial)
	    {
		s = modifySection (s, "append", BootCommon::updateKernelParams (
		    lookup_value (s, "append", "")));
	    }
            return s;
	});
    }

}
