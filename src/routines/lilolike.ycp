/**
 * File:
 *      include/bootloader/routines/lilolike.ycp
 *
 * Module:
 *      Bootloader installation and configuration
 *
 * Summary:
 *      Functions common for lilo-like bootloaders only
 *
 * Authors:
 *      Jiri Srain <jsrain@suse.cz>
 *
 * $Id$
 *
 */
{

    import "StorageDevices";
    import "Storage";

    import "BootCommon";
    import "Mode";
    import "Arch";

    /**
      * Refresh disk locations
      * @return boolean true if bootloader location should be set again
      */
    global define boolean RefreshDisks() ``{
	boolean ret = true;
	if (! DisksChanged ())
	    ret = false;

	y2milestone ("Reconfiguring locations");
	DetectDisks ();

	return ret;
    }

    /**
     *  IsBootAccessible()
     *  @return boolean true if accessible
     */
    global define boolean IsBootAccessible() ``{
	if (Mode::config)
	    return true;
        boolean boot_partition_accessible = true;

        if (!LbaSupport())
        {
            string boot_mount_point = "";
            // check, if no /boot partition exists

            if (lookup (Storage::GetMountPoints(), "/boot", "") == "")
            {
                boot_mount_point = "/";
            }
            else
            {
                boot_mount_point = "/boot";
            }

            // check if boot mount point is below cyl 1024

            foreach (string dname, map ddata, Storage::GetTargetMap(),
            ``{
                list partitions = ddata["partitions"]:[];
                if (partitions != [])
                {
                    foreach (`pentry, partitions,
                    ``{
                        if (pentry["mount"]:"" == boot_mount_point)
                        {
                            boot_partition_accessible =
				(1024 > pentry["region",0]:0);
                        }
                    });
                }

            });

        }
        if (boot_partition_accessible)
            y2milestone("Boot partition accessible");
        else
            y2milestone("Boot partition unaccessible");

        return (boot_partition_accessible);
    }

    /**
      * Check whether disk settings were changed since last checking
      * @return boolean true if needs to recheck
      */
    global define boolean DisksChanged () ``{
	if (Mode::config)
	    return false;
        map mp = Storage::GetMountPoints();
        string actual_root = mp["/", 0]:"";
        string actual_boot = mp["/boot", 0]:actual_root;

        // don't change configuration if '/' and '/boot' were not changed
        // and location is "floppy", "mbr" or "boot"
        if (actual_boot == BootCommon::BootPartitionDevice
            && actual_root == BootCommon::RootPartitionDevice
            && BootCommon::location != "custom"
            && BootCommon::location != "")
        {
            return false;
        }

        if (BootCommon::location == "custom")
        {
	    list all_partitions = BootCommon::getPartitionList(`boot);

            if (!contains(all_partitions, BootCommon::loader_device))
            {
                y2milestone ("Location should be set again");
                return true;
            }
            else if (actual_boot == BootPartitionDevice
                && actual_root == RootPartitionDevice)
            {
                return false;
            }
        }
	return false;
    }

    /**
      * Should backup copy of bootloader bootsector be created?
      * @return boolean true if yes.
      */
    global define boolean createBackupBS () ``{
	if (! Mode::initial)
	    return false;
	map mp = Storage::GetMountPoints ();
	list data = mp["/boot"]:(mp["/"]:[]);
	string bpd = data[0]:"";
	return bpd == BootPartitionDevice;
    }

    /**
      * Detect /boot and / (root) partition devices and store settings
      * to internal variables
      */
    global define void DetectDisks () ``{
	map tm = Storage::GetTargetMap ();
	list partitions = [];

	foreach ( string dev, map disk, tm, ``{
	    if( Storage::IsRealDisk( dev, disk ) )
	    {
		list l = filter( map p, disk["partitions"]:[],
		    ``(p["delete"]:false==false) );
		partitions = merge (partitions, l);
            }
        });

	if (Mode::config)
	    return;
        map mp = Storage::GetMountPoints();

        list mountdata_boot = mp["/boot"]:(mp["/"]:[]);
	list mountdata_root = mp["/"]:[];

        y2milestone( "mountPoints %1", mp );
        y2milestone( "mountdata_boot %1", mountdata_boot );

        BootCommon::RootPartitionDevice = mp["/", 0]:"";

        if (BootCommon::RootPartitionDevice == "")
        {
            y2error ("No mountpoint for / !!");
        }

        // if /boot changed, re-configure location
        BootCommon::BootPartitionDevice
            = mountdata_boot[0]:BootCommon::RootPartitionDevice;

	if (BootCommon::mbrDisk == "" || BootCommon::mbrDisk == nil)
	{
	    // mbr detection.
	    BootCommon::mbrDisk = FindMbrDisk();
	}

        if (BootCommon::location == "" || BootCommon::location == nil)
            BootCommon::location = ConfigureLocation ();

	if (mountdata_boot[3]:"" == "raid1")
	{
	    list md_list = filter (`e, partitions,
		``(e["raid_name"]:"" == mountdata_boot[0]:""));
	    list dev_list = maplist (`e, md_list, ``(e["device"]:""));
	    dev_list = filter (`d, dev_list, ``(d != ""));
	    if (size (dev_list) > 0)
	    {
		dev_list = sort (dev_list);
		BootCommon::BootPartitionDevice = dev_list[0]:"";
	    }
	}
        if (mountdata_root[3]:"" == "raid1")
        {
            list md_list = filter (`e, partitions,
                ``(e["raid_name"]:"" == mountdata_root[0]:""));
            list dev_list = maplist (`e, md_list, ``(e["device"]:""));
            dev_list = filter (`d, dev_list, ``(d != ""));
            if (size (dev_list) > 0)
            {
                dev_list = sort (dev_list);
                BootCommon::RootPartitionDevice = dev_list[0]:"";
            }
        }

        BootCommon::loader_device = BootCommon::GetBootloaderDevice ();
/*	if (BootCommon::location != "floppy")
	{
	    BootCommon::activate = true;
	}*/
    }

    /**
     * ConfigureLocation()
     * Where to install the bootloader.
     * It just gives "mbr" or "floppy"
     * @return string location proposed to bootloader
     */
    global define string ConfigureLocation() ``{
        string loc = "mbr";                       // default to mbr
        string device   = BootCommon::mbrDisk;

        if (!IsBootAccessible()                 // above cyl 1024
            && StorageDevices::FloppyPresent)
        {
            // if we're on an old system without lba support
            // (the last needs a too big initrd, see bugzilla #7864)

            loc = "floppy";                // floppy and fd0
            device   = StorageDevices::FloppyDevice;
        }

        y2milestone ("ConfigureLocation (%1 on %2)", loc, device);
        return loc;
    }

    /**
      * FindMbrDisk()
      * try to find the system's mbr device
      * @return string   mbr device
      */
    global define string FindMbrDisk() ``{
        // can hwinfo find the disk ?

        string probed_mbr_disk = SCR::Read(.probe.boot_disk);
        if (probed_mbr_disk != "")
        {
            y2milestone ("MBR probed as %1", probed_mbr_disk);
            return probed_mbr_disk;
        }

	map mp = Storage::GetMountPoints();
        string bootDisk = mp["/boot",2]:(mp["/",2]:"");

        // look for disk with bios_id 0x80
        list disks = SCR::Read(.probe.disk);
	// fallback
        string mbr_disk = disks[0,"dev_name"]:bootDisk;

        foreach (`disk, disks,
        ``{
            if (disk["bios_id"]:"" == "0x80")
            {
                y2milestone ("disk with bios_id 0x80: %1", disk);
                mbr_disk = disk["dev_name"]:bootDisk;
            }
        });

        y2milestone("MBR Disk: %1", mbr_disk);
        return mbr_disk;
    }

    /**
      * Answer whether LBA is supported
      * @return boolean true if supported
      */
    global define boolean LbaSupport() ``{
        if (Arch::i386)
        {
            list internal_bios = SCR::Read (.probe.bios);
            boolean lba_support = internal_bios[0, "lba_support"]:false;
            if (getLoaderType (false) == "lilo")
                return lookup_value (globals, "lba32", lba_support);
            else
                return lba_support;
        }
        else
            return true;
    }

    /**
      * Update /etc/sysconfig/bootloader:LOADER_LOCATION according to
      * current location in bootloader configuration file
      */
    global define void updateLoaderLocation () ``{
	if (! getBooleanAttrib ("bootloader_on_disk"))
	    return;
	// custom is always OK
	if (location == "custom")
	    return;
	// first floppy disk
	if (loader_device == StorageDevices::FloppyDevice)
	{
	    location = "floppy";
	    return;
	}
	// mbr
	if (loader_device == mbrDisk)
	{
	    location = "mbr";
	    return;
	}
	// bootsector of boot partition
	if (loader_device == BootPartitionDevice)
	{
	    location = "boot";
	    return;
	}
	// bootsector of root partition
	if (loader_device == RootPartitionDevice)
	{
	    location = "root";
	    return;
	}
	// /dev/null or empty means bootloader not installed
	if (loader_device == "/dev/null" || loader_device == "")
	{
	    location = "none";
	    return;
	}
	// other
	location = "custom";
    }

    /**
      * Set default section and loader device in lilo-style bootloader
      */
    global define void finishReading () ``{
        BootCommon::loader_device
            = lookup_value (BootCommon::globals, "boot", "");
        if (lookup_value (BootCommon::globals, "default", "") == "")
        {
            BootCommon::addValueToBootloaderSection (`globals, "default",
                lookup_value (BootCommon::sections[0]:[],
                 "label", ""));
        }
    }

}
