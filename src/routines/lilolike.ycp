/**
 * File:
 *      include/bootloader/routines/lilolike.ycp
 *
 * Module:
 *      Bootloader installation and configuration
 *
 * Summary:
 *      Functions common for lilo-like bootloaders only
 *
 * Authors:
 *      Jiri Srain <jsrain@suse.cz>
 *      Olaf Dabrunz <od@suse.de>
 *
 * $Id$
 *
 */
{

textdomain "bootloader";

import "Arch";
import "Mode";
import "Storage";
import "StorageDevices";
import "BootArch";
import "Map";

global string DiskOrderSummary ();
global list<string> DisksOrder ();
global void DetectDisks ();
global void ProposeDeviceMap ();
global boolean DisksChanged ();

include "bootloader/routines/i386.ycp";

/**
 * Is embedding 1.5 stage of bootloader to dedicated partition area possible?
 * @return true if it is possible
 */
// FIXME: remove this function, it is obsolete (now handled within grub by
// using "setup" instead of "install")
// The code probably does not work with multiple bootloader locations anyway.
// Keeping this temporarily until no other code references it anymore (so that
// for now, the code compiles). This is only used from widget code, and that
// code is probably obsolete as well.
// This code previously existed in lilolike.ycp and in grub/misc.ycp...
global boolean allowEmbed15 () {
    // allow only if /boot, /root or MBR device selected
    // (corrected anyway to use boot_* keys; only grub knows about embed_1.5)
    if (! (BootCommon::globals["boot_boot"]:"false" == "true"
	 || BootCommon::globals["boot_root"]:"false" == "true"
	 || BootCommon::globals["boot_mbr"]:"false" == "true"
    ))
    {
	return false;
    }
    // check filesystem on /boot for Reiserfs and JFS
    map mp = Storage::GetMountPoints ();
    list bp_info
	= mp["/boot"]:mp["/"]:[];
    list<map> partitions
	= Storage::GetTargetMap ()[bp_info[2]:"", "partitions"]:[];
    boolean ret = false;
    foreach (map p, partitions, {
	if (p["device"]:"" == BootCommon::BootPartitionDevice)
	{
	    symbol fs = (symbol)p["used_fs"]:nil;
	    if (fs == `reiser || fs == `jfs)
		ret = true;
	}
    });
    return ret;
}
/**
 * Check whether disk settings were changed since last checking
 * @return boolean true if needs to recheck
 */
global boolean DisksChanged () {
    if (Mode::config ())
	return false;
    map mp = Storage::GetMountPoints();
    string actual_root = mp["/", 0]:"";
    string actual_boot = mp["/boot", 0]:actual_root;

    // don't change configuration if '/' and '/boot' were not changed
    // and location is "floppy", "mbr" or "boot"
    if (actual_boot == BootCommon::BootPartitionDevice
	&& actual_root == BootCommon::RootPartitionDevice
            && selected_location != "custom"
            && selected_location != ""
	    && selected_location != nil)
    {
	return false;
    }

    list all_partitions = BootCommon::getPartitionList(`boot);

    if (!contains(all_partitions, BootCommon::loader_device))
    {
	y2milestone ("Location should be set again");
	return true;
    }
    return false;
}

/**
 * FindMbrDisk()
 * try to find the system's mbr device
 * @return string   mbr device
 */
global string FindMBRDisk() {
    // check the disks order, first has MBR
    list<string> order = DisksOrder ();
    if (size (order) > 0)
    {
	string ret = order[0]:"";
	y2milestone ("First disk in the order: %1, using for MBR", ret);
	return ret;
    }

    // OK, order empty, use the disk with boot partition
    map mp = Storage::GetMountPoints();
    string boot_disk = mp["/boot",2]:(mp["/",2]:"");
    y2milestone ("Disk with boot partition: %1, using for MBR", boot_disk);
    return boot_disk;
}



/**
 * function check all partitions and it tries to find /boot partition
 * if it is MD Raid and soft-riad return correct device for analyse MBR
 * @param list<map> list of partitions
 * @return string device for analyse MBR
 */
define string soft_MDraid_boot_disk(list<map> partitions)
{
   string result = "";
   string boot_device = "";
   if ((BootCommon::BootPartitionDevice != nil) && (BootCommon::BootPartitionDevice != ""))
       boot_device = BootCommon::BootPartitionDevice;
   else
       boot_device = BootCommon::RootPartitionDevice;

   foreach(map p, partitions, {
	if (p["device"]:"" == boot_device)
	{
	   if ((p["type"]:nil == `sw_raid) && (p["fstype"]:"" == "MD Raid"))
	   {
	      string device_1 = p["devices",0]:"";
	      y2debug("device_1: %1", device_1);
	      map dp = Storage::GetDiskPartition (device_1);
	      y2debug("dp: %1", dp);
	      result = dp["disk"]:"";
	   }
	}
   });
   y2milestone("Device for analyse MBR from soft-raid (MD-Raid only): %1", result);
   return result;
}



    /**
     * ConfigureLocation()
     * Where to install the bootloader.
     * Returns the type of device where to install: one of "boot", "root", "mbr", "mbr_md"
     * Also sets internal global variable selected_location to this.
     *
     * Sets internal global variables:
     *	    - selected_location	to the type of bootloader device (currently one of: "boot", "root", "mbr", "mbr_md")
     *	    - loader_device	to the actual device name to install the bootloader to (e.g. "/dev/hda1") or to "mbr_md"
     *	    - activate		to true if the loader_device needs to be activated in the MBR
     *      - activate_changed	leave untouched, except when
     *				    - booting from a primary /boot partition on the first disk (the one with the MBR seen by the BIOS), then set to true
     *				      (FIXME: why only then?)
     *	    - repl_mbr		leave untouched, except when
     *				    - booting from a primary /boot partition on the first disk, then set to true when
     *					- the examination of the code in the MBR
     *					    - by examine_mbr.pl shows that it
     *						- DOES NOT look like a valid "stage 1" at all (not enough entropy to contain valid code)	    OR
     *						- DOES NOT look like a "generic MBR" (= DOS MBR) (OK as stage 1 to boot primary part. on 1st disk)  OR
     *						- DOES     look like a LILO or GRUB MBR (replace them with generic code
     *							   (if stage 1 is not in MBR, see code in updateMBR()),
     *							   they probably contain an obsolete block list for stage 2)				    OR
     *						- DOES     look like some "stage 1" code (has enough entropy, but no known signature)		    OR
     *					    - by KeepMBR() -> ThinkPadMBR() shows that it
     *						- DOES NOT look like a Thinkpad MBR (begins with specific code sequence from that one)
     *				      otherwise set to false
     *
     * @return string type of location proposed to bootloader
     */
     // FIXME: replace with grub_ConfigureLocation() when lilo et al. have
     // changed to stop using selected_location and loader_device.
    string ConfigureLocation() {
        selected_location = "mbr";             // default to mbr
        loader_device   = BootCommon::mbrDisk;
	// check whether the /boot partition
	//  - is primary:			    is_logical	-> false
	//  - is on the first disk (with the MBR):  disk_is_mbr -> true
	map<string,any> tm = Storage::GetTargetMap ();
	map dp = Storage::GetDiskPartition (BootPartitionDevice);
	string disk = dp["disk"]:"";
	boolean disk_is_mbr = disk == mbrDisk;
	map dm = tm[disk]:$[];
	list<map> partitions = dm["partitions"]:[];
	boolean is_logical = false;
	string extended = nil;
	list<string> needed_devices = [ BootPartitionDevice ];
	map<string,integer> md_info = Md2Partitions (BootPartitionDevice);
	if (md_info != nil && size (md_info) > 0)
	{
	    disk_is_mbr = false;
	    needed_devices = maplist (string d, integer b, md_info, {
		map pdp = Storage::GetDiskPartition (d);
		string p_disk = pdp["disk"]:"";
		if (p_disk == mbrDisk)
		    disk_is_mbr = true;
		return d;
	    });
	}
	y2milestone ("Boot partition devices: %1", needed_devices);
	foreach (map p, partitions, {
	    if (p["type"]:nil == `extended)
	    {
		extended = (string)p["device"]:nil;
	    }
	    else if (contains (needed_devices, p["device"]:"")
	        && p["type"]:nil == `logical)
	    {
		is_logical = true;
	    }
	});
	y2milestone ("/boot is on 1st disk: %1", disk_is_mbr);
	y2milestone ("/boot is in logical partition: %1", is_logical);
	y2milestone ("The extended partition: %1", extended);

	// keep_mbr, if the MBR contains special code that needs to be kept,
	//           like Thinkpad boot code (and ATM only Thinkpad boot code
	//           is recognized)
	boolean keep_mbr = KeepMBR (loader_device);

	integer exit = 0;
	// if is primary, store bootloader there
	if (disk_is_mbr && ! is_logical)
	{
	    selected_location = "boot";
	    loader_device = BootPartitionDevice;
	    activate = true;
	    activate_changed = true;
	    // examine_mbr.pl returns
	    //	    - != 0 (errno, e.g. 2) for a read error: "cannot read 512
	    //	           bytes from <dev>"
	    //	    - 254  for an "invalid MBR", i.e. without enough entropy to
	    //	           contain boot code
	    //	    - 0    for a "Generic MBR" (DOS MBR)
	    //	    - 254  for a GRUB or lilo "stage 1"
	    //	    - 254  for an unknown MBR
            //	    - 0    for a Vista MBR
	  
            
            // check if there is raid and if it soft-raid select correct device for analyse MBR
            // bnc #398356
	    if (size (needed_devices) > 1)
	       disk = soft_MDraid_boot_disk(partitions);
	    if (disk == "")
	       disk = dp["disk"]:"";

	    map out = (map)SCR::Execute (.target.bash_output, sformat (
		"/usr/lib/YaST2/bin/examine_mbr.pl %1", disk));
	    y2milestone ("MBR examining script returned %1", out);
	    exit = out["exit"]:0;
	    repl_mbr = (exit == 254) && (! keep_mbr);

	}
	else if (size (needed_devices) > 1)
	{
	    loader_device = "mbr_md";
	    selected_location = "mbr_md";
	}

	if (keep_mbr)
	{
	    if (is_logical && extended != nil)
		loader_device = extended;
	    else
		loader_device = BootPartitionDevice;
	    selected_location = "boot";
	}
	if (! contains (getPartitionList (`boot), loader_device))
	{
	    selected_location = "mbr";             // default to mbr
	    loader_device   = BootCommon::mbrDisk;
	}

        y2milestone ("ConfigureLocation (%1 on %2)",
	    selected_location, loader_device);

	// set active flag
	if (selected_location == "mbr")
	{
	    // we are installing into MBR:
	    // if there is an active partition, then we do not need to activate
	    // one (otherwise we do)
            activate = size (Storage::GetBootPartition (mbrDisk)) == 0;
	}
	else
	{
	    // if not installing to MBR, always activate
	    activate = true;
	}

        return selected_location;
    }

    /**
      * Detect /boot and / (root) partition devices
      * If loader_device is empty or the device is not available as a boot
      * partition, also calls ConfigureLocation to configure loader_device, set
      * selected_location and set the activate flag if needed
      * all these settings are stored in internal variables
      */
    global void DetectDisks () {
	// #151501: AutoYaST needs to know the activate flag and the
	// loader_device; jsrain also said this code is probably a bug:
	// commenting out, but this may need to be changed and made dependent
	// on a "clone" flag (i.e. make the choice to provide minimal (i.e. let
	// YaST do partial proposals on the target system) or maximal (i.e.
	// stay as closely as possible to this system) info in the AutoYaST XML
	// file)
	// if (Mode::config ())
	//    return;
        map mp = Storage::GetMountPoints();

        list mountdata_boot = mp["/boot"]:(mp["/"]:[]);
	list mountdata_root = mp["/"]:[];

        y2milestone( "mountPoints %1", mp );
        y2milestone( "mountdata_boot %1", mountdata_boot );

        BootCommon::RootPartitionDevice = mp["/", 0]:"";

        if (BootCommon::RootPartitionDevice == "")
        {
            y2error ("No mountpoint for / !!");
        }

        // if /boot changed, re-configure location
        BootCommon::BootPartitionDevice
            = mountdata_boot[0]:BootCommon::RootPartitionDevice;

	if (BootCommon::mbrDisk == "" || BootCommon::mbrDisk == nil)
	{
	    // mbr detection.
	    BootCommon::mbrDisk = FindMBRDisk();
	}

	if (loader_device == nil || loader_device == ""
	    || ! contains (getPartitionList (`boot), loader_device))
            ConfigureLocation ();

    }

    /**
      * Converts the md device to the list of devices building it
      * @param md_device string md device
      * @return a map of devices (from device name to BIOS ID or nil if
      *   not detected) building the md device
      */
    global define map<string, integer> Md2Partitions (string md_device) {
	map<string,integer> ret = $[];
	map<string,any> tm = (map<string,map>)Storage::GetTargetMap();
	foreach (string disk, any descr_a, tm, ``{
	    map<string,any> descr = (map<string,any>)descr_a;
	    string bios_id_str = descr["bios_id"]:"";
	    integer bios_id = 256; // maximum + 1 (means: no bios_id found)
	    if (bios_id_str != "")
		bios_id = tointeger (bios_id);
	    list<map<string,any> > partitions = (list<map<string,any> >)
		descr["partitions"]:[];
	    foreach (map<string,any> partition, partitions, ``{
		if (partition["used_by"]:"" == substring(md_device,5))
		{
		    string d = (string)(partition["device"]:"");
		    ret[d] = bios_id;
		}
	    });
	});
	y2milestone ("Partitions building %1: %2", md_device, ret);
	return ret;
    }

    /**
      * Converts the md device to the first of its members
      * @param md_device string md device
      * @return string one of devices building the md array
      */
    global define string Md2Partition (string md_device) {
	map<string,integer> devices = Md2Partitions (md_device);
	if (size (devices) == 0)
	    return md_device;
	integer minimal = 129; // maximum + 2
	string found = "";
	foreach (string k, integer v, devices, {
	    if (v < minimal)
	    {
		found = k;
		minimal = v;
	    }
	});
	return found;
    }


/**
 * Run delayed updates
 *
 * This is used by perl-Bootloader when it cannot remove sections from the
 * bootloader configuration from the postuninstall-script of the kernel. It
 * writes a command to a delayed update script that is then called here to
 * remove these sections.
 *
 * The script is deleted after execution.
 */
global void RunDelayedUpdates () {
    string scriptname = "/boot/perl-BL_delayed_exec";
    string cmd = sformat("test -x %1 && { cat %1 ; %1 ; }", scriptname);

    y2milestone ("running delayed update command: %1", cmd);
    map out = (map)SCR::Execute (.target.bash_output, cmd);
    y2milestone ("command returned %1", out);

    cmd = sformat("rm -f %1", scriptname);
    out = (map)SCR::Execute (.target.bash_output, cmd);
}


/**
 * fallback list for kernel flavors (adapted from Kernel.ycp), used if we have
 * no better information
 * order is from special to general, but prefer "default" in favor of "xen"
 */
// FIXME: handle "rt" and "vanilla"?
// bnc #400526 there is not xenpae anymore...
list<string> generic_fallback_flavors = [
	"s390", "iseries64", "ppc64", "bigsmp", "default", "xen",
];

/**
 * Fix global section of lilo-like bootloader
 *
 * This currently only tries to fix the "default" key if necessary. It is when
 * the referenced section does not exist anymore or during a system update when
 * a special comment in the bootloader configuration tells us that we have to
 * update the "default" key. An empty "default" value is not changed, because
 * this means that no default is wanted.
 *
 * If we need to fix the "default" key we take the following steps:
 *
 *  - If we are fixing the configuration at the end of an update and the
 *    special key "former_default_image_flavor" exists, try to set the default
 *    to the first "linux.*" section with an image of this flavor (preferring
 *    "linux" entries over possibly older "linux-.*" entries).
 *
 *  - Otherwise go through a list of fallback kernel flavours and use the first
 *    "linux.*" section that contains a matching image (preferring "linux"
 *    entries over possibly older "linux-.*" entries).
 *
 *  - Otherwise, simply use the first section as the default section.
 */
global void FixGlobals () {
    string defaultv = globals["default"]:"";
    string first = "";

    y2milestone ("fixing default section");

    // nothing to do if default is empty
    if (defaultv == "")
	return;

    // does default section exist?
    boolean exists = false;
    foreach (map<string,any> s, sections, {
	string label = s["name"]:"";
	if (label == defaultv)
	    exists = true;
	if (first == "")
	    first = label;
    });

    if (exists &&
	(! Mode::update() || globals["former_default_image_flavor"]:nil == nil))
	return;

    // need to fix "default"
    boolean old_entry_found = false;
    string found_name = "";
    list<string> fallback_flavors = generic_fallback_flavors;

    if (Mode::update() && globals["former_default_image_flavor"]:nil != nil) {
	fallback_flavors = prepend(fallback_flavors, globals["former_default_image_flavor"]:"");

	// former_default_image_flavor is removed at the end of the update
	globals = remove (globals, "former_default_image_flavor");
    }

    y2milestone ("looking for image flavors %1", fallback_flavors);
    foreach (string flavor, fallback_flavors, {
	if (found_name != "")
	    return;

	foreach (map<string,any> s, sections, {
	    string label = s["name"]:"";
	    if (regexpmatch (s["original_name"]:"", "^linux(-.*)?$") ||
		regexpmatch (s["image"]:"", "^.*-" + flavor + "$") ||
		regexpmatch (s["kernel"]:"", "^.*-" + flavor + "$")) {
		// found, if we have not yet found a match, or the previously
		// found one was for an "old" entry and we now found a "new"
		// one
		if (found_name == "" ||
		    (old_entry_found && regexpmatch (s["original_name"]:"", "^linux$"))) {
		    found_name = label;
		    if (regexpmatch (s["original_name"]:"", "^linux-.*$"))
			old_entry_found = true;
		    else
			old_entry_found = false;
		}
	    }
	});
    });

    if (found_name != "")
	globals["default"] = found_name;
    else
	globals["default"] = first;

    y2milestone ("setting new default section to: %1", globals["default"]:nil);
}


string getLargestSwapPartition () {
    map<string, integer> swap_sizes = getSwapPartitions ();
    list<string> swap_parts = (list<string>)
        maplist (string name, integer size, swap_sizes, ``(name));
    swap_parts = sort (string a, string b, swap_parts,
		       ``(swap_sizes[a]:0 > swap_sizes[b]:0)
		       );
    return swap_parts[0]:"";
}


/**
 * Fix section of lilo-like bootloader
 */
global void FixSections (void() create_sections) {
    list<string> parts = getPartitionList(`parts_old);
    if (partitioning_last_change
	    != Storage::GetTargetChangeTime()
	&& BootCommon::files_edited)
    {
	displayFilesEditedPopup ();
	files_edited_warned = true;
	return;
    }

    // save old sections and propose new ones in global "sections"
    // (the updated list of old sections will become the new section list in
    // the end)
    list<map<string,any> > old_sect_list = sections;

    create_sections ();

    // new_sect is a map with elements containing: "type" -> section
    map<string,map<string,any> > new_sect = listmap (map<string,any> s,
	sections,
    {
	string label = s["name"]:"";
	string type = s["original_name"]:label;
	return $[type: s];
    });

    // remember a list with all the section "types" in the old section list
    // (needed later in this function to find newly created sections)
    list<string> old_section_types = maplist (map<string,any> s, old_sect_list,
    {
	return s["original_name"]:"";
    });

    // in the old list of sections:
    //	- only keep sections that the user created (no "__auto", or false) or
    //	  changed ("__changed") in the UI
    //  - replace unchanged sections with ones we proposed just now (if
    //    available)
    //  - also notify user when devices for a "changed by user" section are
    //    unavailable or would now be proposed differently (and mark section as
    //    "created by user")
    old_sect_list = maplist (map<string,any> s, old_sect_list, {
	string label = s["name"]:"";
	string type = s["original_name"]:label;
	if (! s["__auto"]:false)
	{
	    y2milestone ("Leaving section %1", label);
	    return s;
	}
	else if (! s["__changed"]:false)
	{
	    y2milestone ("Recreating section %1, new is %2",
		label, new_sect[type]:$[]);
	    return new_sect[type]:$[];
	}
	else
	{
	    // section was created by us, then changed by the user:
	    //	- keep it, except if no newly created section of same type can
	    //	  be found (which probably means we have a bug, because
	    //	  "__auto" says we created the old section as well)
	    //  - maybe notify user to check it (and then mark it as a "user
	    //    defined section")
	    y2milestone ("Warning on section %1", label);
	    boolean cont = true;
	    // if "non-standard" section name and a used device is not
	    // available anymore, notify user
	    if (type != "linux" && type != "failsafe"
		&& type != "memtest86" && type != "wildcard")
	    {
		foreach (string n, s["__devs"]:[], {
		    if (! contains (parts, n))
		    {
			cont = false;
		    }
		});
	    }
	    // find section of same type in newly created sections;
	    // if not found (which should not happen, since according to the
	    // "__auto" key we created it) delete this section
	    map<string,any> new_this_section = new_sect[type]:$[];
	    if (new_this_section == $[]) {
		y2warning("Warning, could not find freshly proposed section" +
		    "corresponding to section %1, deleting it",
		    s["name"]:"");
		return $[];
	    }
	    // if the devices for this section and the freshly created one of
	    // the same type are different, notify user
	    list new_devs = toset(new_this_section["__devs"]:[]);
	    list old_devs = toset(s["__devs"]:[]);
	    if (size (new_devs) != size (old_devs))
		cont = false;
	    else
	    {
                foreach (any d, old_devs, ``{
		    if (! contains (new_devs, d))
			cont = false;
                });
	    }
	    // display info popup for this section;
	    // also, next time we come through this function, consider this
	    // section as a section created by the user (and leave it as it is)
	    if (! cont)
	    {
		s["__auto"] = false;
		displayDiskChangePopup (label);
	    }
	    return s;
	}
    });

    // in newly created sections, fix "resume" parameter in append line if
    // necessary
    y2milestone ("Checking for sections using the resume parameter");
    sections = maplist (map<string,any> s, BootCommon::sections, ``{
	string append = s["append"]:"";
	string resume = getKernelParamFromLine (append, "resume");
	if (resume != "" && resume != nil
	    && ! haskey (getSwapPartitions (), resume))
	// points to unexistent swap partition
	{
	    // bnc# 335526 - Installing memtest with lilo screws up installation
	    if (search(s["original_name"]:"", "memtest") == nil)
	    {
	    	append = setKernelParamToLine (append, "resume", BootCommon::Dev2MountByDev(getLargestSwapPartition ()));
	    	s["append"] = append;
	    }
	}
	return s;
    });

    // now add sections from newly created ones that were unknown before in the
    // old section list, if not already removed by the user (#170469)
    foreach (map<string,any> s, sections, {
	string label = s["name"]:"";
	string type = s["original_name"]:label;
	if (! contains (old_section_types, type) &&
	    ! contains (removed_sections, type))
	{
	    y2milestone ("Adding new section \"%1\": %2",
		label, s);
	    old_sect_list = add(old_sect_list, s);
	    return s;
	}
    });

    // Strange (I must have misread the code here):
    // if a newly created section uses one or more deleted devices, and a
    // section of that type does not exist anymore in the old section list, add
    // it to the old section list
    y2milestone ("Checking for sections needing some of %1", del_parts);
    list<string> to_remove = [];
    foreach (map<string,any> s, sections, {
	list<string> devs = s["__devs"]:[];
	string label = s["name"]:"";
	y2milestone ("Section %1 needs %2", label, devs);
	boolean to_add = false;
	foreach (string d, devs, {
	   if (contains (del_parts, d))
	    {
		to_add = true;
	    }
	});
	if (to_add)
	{
	    map old_sect = listmap (map<string,any> os, old_sect_list, {
		return $[label: os];
	    });

	    if (label != "" && ! haskey(old_sect, label))
	    {
		y2milestone ("Adding %1", s);
		to_remove = add (to_remove, label);
		old_sect_list = add (old_sect_list, s);
	    }
	}
    });

    // FIXME: BUG: looks like a bug to remove a list of labels from the list of
    // deleted devices
    del_parts = (list<string>)difflist (del_parts, to_remove);

    // cleanup: throw away empty sections
    old_sect_list = filter (map<string,any> s, old_sect_list, {
	return s != $[];
    });

    // save old, updated section list as proposed section list
    sections = old_sect_list;
}

/**
 * Update sections of bootloader menu
 * modifies internal structures
 * @param replace boolean true if old sectinos shall be replaced
 * @param create_linux_section a reference to a function to create linux
 *   section anew
 */
global void UpdateSections (boolean replace,
    map<string,any>(string) create_linux_section)
{
    list<map<string,any> > out = BootCommon::sections;
    list<string> recreated = [];
    boolean linux_resume_added = false;

    map<string,any> default_sect = create_linux_section ("linux");
    string default_kernel = default_sect["kernel"]:"";
    string default_initrd = default_sect["initrd"]:"";
    string default_name = default_sect["name"]:"";

    list<string> sections_to_recreate = ["linux", "failsafe", "memtest86"];
    if (getLoaderType (false) == "grub")
    {
	sections_to_recreate = add (sections_to_recreate, "xen");
    }

    // if replace == true,  replace all sections that have a type in
    //                      sections_to_recreate with a newly created version
    // if replace == false, only adjust "append" line of "linux" section
    //
    // at the end of the loop, if one of the sections_to_recreate does not
    // exist, create it
    foreach (string t, sections_to_recreate, {
	map<string,any> m = create_linux_section (t);
	boolean f_changed = false;
	out = maplist (map<string,any> s, out, {
	    string label = s["name"]:"";
	    string sect_type = s["original_name"]:"";
	    if (sect_type == "")
		sect_type = label;
	    if (sect_type == t)
	    {
		f_changed = true;
		if (replace && m != $[])
		{
		    y2milestone ("Recreated section %1: %2", label, m);
		    recreated = add (recreated, label);
		    return m;
		}
		else if (t == "linux")
		{
		    string append = s["append"]:"";
		    string resume = BootCommon::getKernelParamFromLine (
			append, "resume");
		    if (! haskey (BootCommon::getSwapPartitions (), resume))
		    {
			append = setKernelParamToLine (append,
			    "resume", BootCommon::Dev2MountByDev(getLargestSwapPartition ()));
			s["append"] = append;
			linux_resume_added = true;
		    }
		    return s;
                }
		else
		    return s;
	    }
	    else
	    {
		return s;
	    }
	});
	// if we did NOT change or replace the old section (meaning: there was
	// none), but create_linux_section() gave us a new section, then
	// prepend or append the section created by create_linux_section()
        if (! f_changed && m != $[])
	{
	    y2milestone ("Recreated section: %1", m);
	    recreated = add (recreated, m["name"]:"");
            if (t == "linux")
		out = prepend (out, m);
            else
		out = add (out, m);
	}
    });
    y2milestone ("All recreated sections: %1", recreated);

    // for grub and replace-mode only:
    // convert sections that boot "other" installations (another Linux, Windows
    // etc.) to chainloader and configfile sections
    //
    // ! contains (sections_to_recreate, original_name)         AND
    // original_name == name (e.g. "openSUSE 10.3 (/dev/sdb1)") AND
    // haskey("image")						AND
    // haskey("initrd")
    //
    //  => if bootable, convert to "chainloader"
    //       otherwise, convert to "configfile" and hope for the best
    //
    if (getLoaderType (false) == "grub" && replace)
    {
	y2milestone ("Converting sections for other installation to use chainloader/configfile entries...");
	out = maplist (map<string,any> s, out, {
	    string label = s["name"]:"";
	    string sect_type = s["original_name"]:"";
	    y2milestone ("label: %1, sect_type: %2", label, sect_type);
	    if (!contains(sections_to_recreate, sect_type) &&
		 sect_type == label &&
		 haskey(s, "image") &&
		 haskey(s, "initrd"))
	     {
		string dev = (string) s["root"]:nil;

		// create new entry
		s = $[
		    "name":		label,
		    "original_name":	sect_type,
		    "root":		BootCommon::Dev2MountByDev(dev)
		];

		if (dev != nil && IsPartitionBootable(dev))
		{
		    //     bootable =>  chainloader
		    s["noverifyroot"] = "true";
		    s["chainloader"] = BootCommon::Dev2MountByDev(dev);
		    s["blockoffset"] = "1";
		    s["type"] = "other";
		    y2milestone ("Updating section \"%1\" booting other installation to use chainloader entry", s["name"]:"");
		}
		else
		{
		    // not bootable =>  configfile
		    // let's hope the config file can be found (should work at
		    // least for all SUSE installations using grub)
		    s["configfile"] = "/boot/grub/menu.lst";
		    s["type"] = "menu";
		    y2milestone ("Updating section \"%1\" booting other installation to use configfile entry", s["name"]:"");
		}
		return s;
	    }
	    else
		return s;

	});
    }


    // now adjust these keys in sections that need it:
    //  - kernel
    //  - initrd
    //  - name
    //  - device (e.g. for SATA: /dev/hda -> /dev/sda)
    //  - append
    out = maplist (map<string,any> s, out, {
	string label = s["name"]:"";
	string type = s["original_name"]:label;
	// FIXME: do we still need to remove strings from kernel or initrd names?
	//        if yes: add "image"
	//        if no: remove loop
	//        probably need to do this depending on the version of the old
	//        installation
	foreach (string key, ["kernel", "initrd"], {
	    string value = s[key]:"";
	    if (regexpmatch (value, "^.*\.shipped.*$"))
	    {
		value = regexpsub (value,
		    "^(.*)\.shipped(.*)$", "\\1\\2");
	    }
	    else if (regexpmatch (value, "^.*\.suse.*$"))
	    {
		value = regexpsub (value,
		    "^(.*)\.suse(.*)$", "\\1\\2");
	    }
	    // This was broken (was: s["key"] = value;)
	    s[key] = value;
	});
	// If we did not replace the sections anyway, adjust the section titles:
	// Does this section
	//  - use the default kernel of a linux section \ i.e. it uses the updated kernel
	//  - use the default initrd of a linux section /
	//  - contain the name of the first "linux" section read from disk in
	//    its name
	// then, update the section name
	if (!replace
	    && s["kernel"]:"" == default_kernel
	    && s["initrd"]:"" == default_initrd
	    && issubstring (s["name"]:"", read_default_section_name)
	    && read_default_section_name != ""
	    && read_default_section_name != default_name)
	{
	    // idea of this:
	    // orig_name == "linux":    "Linux"		    -> "<new name>"
	    // orig_name == "failsafe": "Failsafe -- Linux" -> "Failsafe -- <new name>"
	    y2milestone ("Updating label of section %1...", s["name"]:"");
	    string old_name = s["name"]:"";
	    integer i1 = search (old_name, read_default_section_name);
	    integer i2 = i1 + size (read_default_section_name);
	    s["name"] = substring (old_name, 0, i1) + default_name
		+ substring (old_name, i2);
	    y2milestone ("... to %1", s["name"]:"");
	}

	// Update device names in sections for certain section types, if the
	// section has not been recreated anyway
	// FIXME: never update device names twice!
	foreach (string key, ["root", "chainloader"], {
	    // FIXME: for some reason, this used to update "linux" and
	    // "failsafe" even if they have been recreated; but "other"
	    // sections were never updated -- since there are no calls to
	    // UpdateSections() with replace == false, ATM we disable updating
	    // "linux" and "failsafe", and add "other", seed
	    // BootCommon::update_section_types
	    if ((contains (update_section_types, type)
		    && ! contains (recreated, label))
		|| key == "chainloader")
	    {
		string device = (string) s[key]:nil;
		y2milestone ("Checking for update: device %1 of key %2, section %3", device, key, label);
		if (device != nil)
		{
		    y2milestone ("Updating root/other device of section %1",
			label);
		    device = BootCommon::UpdateDevice (device);
		    s[key] = device;
		}
	    }
	});
	if (type == "linux" && haskey (s, "append"))
	{
	    string option = s["append"]:"";
	    foreach (string o, ListAdditionalKernelParams (), {
		option = setKernelParamToLine (option, o, "false");
	    });
	    option = option + " " + GetAdditionalKernelParams ();
	    if (getKernelParamFromLine (option, "splash") == "false")
		option = setKernelParamToLine
		    (option, "splash", "silent");
	    s["append"] = option;
	}
	else if (haskey (s, "append")
	    && contains (BootCommon::update_section_types, type)
	   && ! contains (recreated, label))
	{
	    string option = s["append"]:"";
	    if (type != "linux" || ! linux_resume_added)
	    {
		string resume
		    = BootCommon::getKernelParamFromLine (
			option, "resume");
		if (resume != "false")
		{
		    y2milestone ("Updating resume device of section %1", label);
		    resume = BootCommon::UpdateDevice (resume);
		    option = BootCommon::setKernelParamToLine (
			option, "resume", BootCommon::Dev2MountByDev(resume));
		}
	    }
	    s["append"] = option;
	}
	return s;
    });
    sections = out;
}

/**
 * Update global options of bootloader
 * modifies internal sreuctures
 */
global void UpdateGlobals () {
    if (BootCommon::globals["timeout"]:"" == "")
        BootCommon::globals["timeout"] = "8";
    list<string> s1_devs
	= splitstring (BootCommon::globals["stage1_dev"]:"", ",");
    s1_devs = maplist (string d, s1_devs, {
	return UpdateDevice (d);
    });
    BootCommon::globals["stage1_dev"] = mergestring (s1_devs, ",");
    BootCommon::globals["gfxmenu"] = "/boot/message";

    // now that the label for the "linux" section is not "linux" anymore, but
    // some product dependent string that can change with an update ("SLES_10"
    // -> "SLES_10_SP1"), we need to update the label in the "default" line for
    // LILO and GRUB (although the latter only needs it to correctly transform
    // back to the section number)
    // FIXME: is this needed/wanted for ELILO as well?
    if ( contains (["lilo", "grub"], getLoaderType (false)))
	FixGlobals ();
}

/**
 * Update the device map according to changed device names
 * Read device map and store it in internal structures
 */
global void UpdateDeviceMap () {
    device_mapping = mapmap (string unix, string fw, device_mapping, {
	y2milestone ("Updating device in devmap entry %1 -> %2",
	    unix, fw);
	unix = BootCommon::UpdateDevice (unix);
	return $[ unix : fw ];
    });
    y2milestone ("Updated device map: %1", device_mapping);
}

/**
 * Filter sections, remove those pointing to unexistent image
 * @param path_prefix string prefix to be added to kernel path
 * @param relative_path_prefix prefix to be added to relative kernel
 *  paths (without leading slash)
 */
global void RemoveUnexistentSections (string path_prefix,
    string relative_path_prefix)
{
    string defaultv = globals["default"]:"";
    string first = nil;
    BootCommon::sections = filter (map<string,any> s, BootCommon::sections, {
	string label = s["name"]:"";

	// do not touch the wildcard section
	if (regexpmatch (s["image"]:"", ".+\\-\\*"))
	{
	    if (first == nil)
		first = label;
	    return true;
	}

	string type = s["original_name"]:"";
        if (label == "")
	{
	    y2warning ("Removing section with empty title");
	    if (label == defaultv)
		defaultv = nil;
	    return false;
	}
	// FIXME the following check makes sense for all sections`
	if (! contains (["linux", "failsafe", "memtest86", "xen"], type))
	{
	    if (first == nil)
		first = label;
	    return true;
	}
	string kernel = s["image"]:"";
	if (kernel == "")
	{
	    if (first == nil)
		first = label;
	    return true;
	}
	if (substring (kernel, 0, 1) == "/")
	{
	    kernel = path_prefix + kernel;
	}
	else
	{
	    if (relative_path_prefix == "")
		return true;
	    kernel = relative_path_prefix + kernel;
	}
	if (SCR::Read (.target.size, kernel) == -1)
	{
	    y2warning ("Removing section %1 with unexistent kernel %2",
		label, kernel);
	    if (label == defaultv)
		defaultv = nil;
	    return false;
	}
	if (first == nil)
	    first = label;
	return true;
    });
    if (defaultv == nil)
	defaultv = first;
    globals["default"] = defaultv;
}

/**
 * Remove or add initrd option if needed, update append option if some
 *  parameters were changed
 */
global void UpdateInitrdLine () {
    sections = maplist (map<string,any> s, sections, {
        string initrd = s["initrd"]:"";
	string title = s["name"]:"";
	string type = s["original_name"]:"";

	// do not touch the wildcard section
	if (regexpmatch (s["initrd"]:"", ".+\\-\\*"))
	{
	    return s;
	}

        if ((type == "linux" || type == "failsafe")
	    && write_settings["insert_initrd"]:false)
        {
	    s["initrd"] = BootArch::InitrdImage ();
        }
	else if (type == "xen" && write_settings["insert_initrd"]:false)
	{
	   // bnc #400526 there is not xenpae any more...
	   s["initrd"] = "/boot/initrd-xen";
	}
        if (initrd != "")
        {
	    // check for initrd in GRUB format, keep them
	    // FIXME change the check for leading slash
	    if (getLoaderType (false) == "grub"
		&& substring (initrd, 0, 1) == "(")
	    {
		return s;
	    }
	    if (-1 == SCR::Read (.target.size, initrd) && haskey (s, "initrd"))
		s = remove (s, "initrd");
        }
	return s;
    });
}

/**
  * Update append option if some parameters were changed
  */
global void UpdateAppend () {
    sections = maplist (map<string,any> s, sections, {
	string type = s["original_name"]:"";
        if ((type == "linux" || type == "wildcard" || type == "global")
	    && s["append"]:nil != nil
	    && Stage::initial ())
	{
	    s["append"] = UpdateKernelParams (s["append"]:"");
	}
        return s;
    });
    if (haskey (globals, "append"))
    {
	globals["append"] = UpdateKernelParams (globals["append"]:"");
    }
}

/**
 * Update the gfxboot/message/... line if exists
 */
global void UpdateGfxMenu () {
    string message = globals["gfxmenu"]:"";
    if ((message != "") && (search(message, "(") == nil))
    {
	if (-1 == SCR::Read (.target.size, message))
	{
	    globals = remove (globals, "gfxmenu");
	}
    }

}


/*** helper functions for ProposeDeviceMap: ***/
/**
 * Returns true if any device from list devices is in device_mapping
 * marked as hd0.
 */
boolean isHd0(list<string> devices)
{
    boolean ret = false;

    foreach (string value, devices,
        {
            if (device_mapping[value]:"" == "hd0"){
                ret = true;
            }
        });

    return ret;
}

/**
 * Returns first key from mapping associated with value.
 * Example:
 *      map = $[ "a" : "1",
 *               "b" : "2",
 *               "c" : "3",
 *               "d" : "2"];
 *      getDeviceFromMapping("1", map) -> "a"
 *      getDeviceFromMapping("2", map) -> "b"
 */
string getKey(string value, map<string, string> mapping)
{
    string ret = "";

    foreach (string key, string val, mapping,
        {
            if (value == val){
                ret = key;
                return;
            }
        });

    return ret;
}

/**
 * This function changes order of devices in device_mapping.
 * All devices listed in bad_devices are maped to "hdN" are moved to the end
 * (with changed number N). And second step is putting device with boot partition
 * on top (i.e. device_mapping[dev_with_boot] = "hd0").
 *
 * Example:
 *      device_mapping = $[ "/dev/sda" : "hd0",
 *                          "/dev/sdb" : "hd1",
 *                          "/dev/sdc" : "hd2",
 *                          "/dev/sdd" : "hd3",
 *                          "/dev/sde" : "hd4" ];
 *      bad_devices = [ "/dev/sda", "/dev/sdc" ];
 *
 *      changeOrderInDeviceMapping(bad_devices);
 *      // after call, device_mapping is:
 *      device_mapping -> $[ "/dev/sda" : "hd3",
 *                           "/dev/sdb" : "hd0",
 *                           "/dev/sdc" : "hd4",
 *                           "/dev/sdd" : "hd1",
 *                           "/dev/sde" : "hd2" ];
 */
void changeOrderInDeviceMapping(list<string> bad_devices)
{
    integer cur_id = 0;
    list keys = [];
    string value = "";
    string tmp = "";
    string tmp2 = "";

    // get keys from device_mapping, it's not possible to use foreach over keys and values
    // of device_mapping directly, because during the loop device_mapping is changing.
    foreach (string key, string value, device_mapping, { keys = add(keys, key); });

    // put bad_devices at bottom
    foreach (string key, (list<string>)keys,
        {
                value = device_mapping[key]:"";

                // if device is mapped on hdX and this device is _not_ in bad_devices
                if (substring(value, 0, 2) == "hd"
                    && !contains(bad_devices, key)){
                        // get device name of mapped on "hd"+cur_id
                        tmp = getKey("hd" + tostring(cur_id), device_mapping);

                        // swap tmp and key devices (swap their mapping)
                        device_mapping[tmp] = value;
                        device_mapping[key] = "hd" + tostring(cur_id);

                        cur_id = cur_id + 1;
                }
        });

    // put device with boot partition on the top:
    /*
    tmp = (regexptokenize(BootCommon::BootPartitionDevice, "([a-z/]+)[0-9]*"))[0]:"";
    if (haskey(device_mapping, tmp) && device_mapping[tmp]:"" != "hd0"){
        y2debug("Putting device with boot partition (%1) on the top.", tmp);

        tmp2 = getKey("hd0", device_mapping);
        device_mapping[tmp2] = device_mapping[tmp]:"";
        device_mapping[tmp] = "hd0";
    }*/
}
/*** helper functions END ***/

/**
 * Generate device map proposal, store it in internal variables.
 *
 * FATE #302075:
 *   When user is installing from USB media or any non IDE disk or bios simply
 *   set any non IDE disk as first and user is not installing on this removable
 *   (non IDE) disk, the order of disks proposed by bios must be changed because
 *   of future remove of USB disk.
 *   This function must find right place for bootloader (which is most probably
 *   boot sector of boot partition (where /boot dir is located)) and change the
 *   order of disks in device map.
 *   This method is only heuristic because order of disks after remove of usb
 *   disk can't be determined by any method.
 *
 *   Algorithm for solving problem with usb disk propsed by bios as hd0:
 *      if usbDiskDevice == hd0 && BootDevice != usbDiskDevice:
 *          change order of disks in device_mappings to have BootDevice as hd0
 */
// FIXME: remove that function from here, as it is grub only
// NOTE: there is a local copy in routines/grub/misc.ycp now
global void ProposeDeviceMap () {
    list<string> usb_disks = []; // contains those usb removable disks

    device_mapping = $[];

    map<string,map> targetMap = $[];
    if (Mode::config ())
	y2milestone ("Skipping device map proposing in Config mode");
    else
	targetMap = (map<string,map>)Storage::GetTargetMap();

    // filter out members of BIOS RAIDs
    targetMap = filter (string k, map v, targetMap, {
	return v["used_by_type"]:nil != `UB_DMRAID;
    });
    // filter out non-disk devices
    targetMap = filter (string k, map v, targetMap, {
	return v["type"]:`CT_UNKNOWN==`CT_DMRAID || v["type"]:`CT_UNKNOWN==`CT_DISK;
    });

    y2milestone ("Target map: %1", targetMap);

    // add devices with known bios_id
    // collect BIOS IDs which are used
    map ids = $[];
    foreach (string target_dev, map target, targetMap, {
        string bios_id = target["bios_id"]:"";
        if (bios_id != "")
        {
            integer index = tointeger (bios_id) - tointeger ("0x80");
            string grub_dev = sformat ("hd%1", index);
	    // FATE #303548 - doesn't add disk with same bios_id with different name (multipath machine)
	    if (! ids[index]:false)
            {
	    	device_mapping[target_dev] = grub_dev;
            	ids[index] = true;
	    }
        }
    });
    // and guess other devices
    // don't use already used BIOS IDs
    foreach (string target_dev, map target, targetMap, {
        string bios_id = target["bios_id"]:"";
        if (bios_id == "")
        {
            integer index = 0;
            while (ids[index]:false)
                index = index + 1;
            string grub_dev = sformat ("hd%1", index);
	    device_mapping[target_dev] = grub_dev;
            ids[index] = true;
        }
    });

    // Fill usb_disks list with usb removable devices.
    //
    // It's not easy to determine how to identify removable usb devices. Now
    // it tests if driver of device is usb-storage. If you find better
    // algorithm how to find removable usb devices, put it here into foreach
    // to apply this algorithm on all devices.
    foreach (string target_dev, map target, targetMap,
        {
            string driver = target["driver"]:"";
            if (driver == "usb-storage"){
                usb_disks = add(usb_disks, target_dev);
            }
        });
    y2milestone("Found usb discs: %1", usb_disks);
    
    // change order in device_mapping if usb disk is hd0
    // (FATE #302075)
    if (isHd0(usb_disks)
        && BootCommon::BootPartitionDevice != getKey("hd0", device_mapping)){
	y2milestone ("Detected device mapping: %1", device_mapping);
        y2milestone("Changing order in device mapping needed...");
        changeOrderInDeviceMapping(usb_disks);
    }

    if (StorageDevices::FloppyPresent())
	device_mapping[StorageDevices::FloppyDevice()] = "fd0";

    y2milestone ("Detected device mapping: %1", device_mapping);
}

/**
 * Get the order of disks according to BIOS mapping
 * @return a list of all disks in the order BIOS sees them
 */
global list<string> DisksOrder () {
    if (device_mapping == nil || size (device_mapping) == 0)
    {
	ProposeDeviceMap ();
    }
    map<string,string> devmap_rev = mapmap (string k, string v,
	BootCommon::device_mapping,
    {
	return $[ v : k ];
    });
    devmap_rev = filter (string k, string v, devmap_rev, {
	return substring (k, 0, 2) == "hd";
    });
    list<string> order = maplist (string k, string v, devmap_rev, {
	return v;
    });
    return order;
}

/**
 * Get the summary of disks order for the proposal
 * @return string a line for the summary (or nil if not intended to be shown)
 */
global string DiskOrderSummary () {
    list<string> order = DisksOrder ();
    string ret = nil;
    if (size (order) > 1)
    {
	ret = sformat (
	    // part of summary, %1 is a list of hard disks device names
	    _("Order of Hard Disks: %1"),
	    mergestring (order, ", "));
    }
    return ret;
}


} // EOF

/*
 * Local variables:
 *     mode: ycp
 *     mode: font-lock
 *     mode: auto-fill
 *     indent-level: 4
 *     fill-column: 78
 * End:
 */
