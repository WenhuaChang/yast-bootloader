/**
 * File:
 *      include/bootloader/routines/widgets.ycp
 *
 * Module:
 *      Bootloader installation and configuration
 *
 * Summary:
 *      Common widgets for being used by several bootloaders
 *
 * Authors:
 *      Jiri Srain <jsrain@suse.cz>
 *
 * $Id$
 *
 */


{

    textdomain "bootloader";

    import "Label";
    import "BootCommon";
    import "Mode";
    import "Storage";
    import "StorageDevices";
    include "bootloader/routines/popups.ycp";

    /**
      * Get map of dialogs and widgets
      * @return map of dialogs and widgets
      */
    global define map GetWidgets () ``{
	return $[
	    "sections"		: ``(BootCommon::getSectionsWidget ()),
	    "singlesection"	: ``(BootCommon::getSingleSectionWidget ()),
	    "globalsection"	: ``(BootCommon::getGlobalSectionWidget ()),
	    "resetbutton"	: ``(BootCommon::getResetButtonWidget ()),
	    "manual_edit_button": ``(BootCommon::getManualEditWidget ()),
	    "tableentries"	: $[
		"__location"	: ``(BootCommon::getTargetWidget ()),
		"__loader_type" : ``(BootCommon::getLoaderSelectionWidget ()),
		"__sections"	: ``(BootCommon::getSectionsTableEntry ()),
		"__default_section" : ``(BootCommon::getDefaultSectionTableEntry ()),
		"__section_type": ``(BootCommon::getSectionTypeWidget ()),
		"__save_method" : ``(BootCommon::getSaveMethod ()),
		"__backup_mbr"	: ``(BootCommon::getBackupMbrWidget ()),
		"__sep1"	: $["label" : "---------------"],
		"__sep2"	: $["label" : "---------------"],
		"__sep3"	: $["label" : "---------------"],
		"label"		: ``(BootCommon::getLabelWidget ()),
		"alias"		: ``(BootCommon::getAliasWidget ()),
		"timeout"	: ``(BootCommon::getTimeoutWidget ()),
		"password"	: ``(BootCommon::getPasswdWidget ()),
		"__repl_mbr"	: ``(BootCommon::getReplMbrWidget ()),
		"__activate"	: ``(BootCommon::getActivateWidget ()),
		"message"	: ``(BootCommon::getMessageWidget ()),
	    ],
	];
    }

    /**
      * Generic version of FixSequence function
      * Just leave everything as is
      * @param ws_data map default wizard sequencer data
      * @return map updated wizard sequencer data
      */
    global define map FixSequence (map ws_data) ``{
	return ws_data;
    }

// Bootloader target widget

    /**
      * Get map of Target widget
      * @return map of Target widget
      */
    global define map getTargetWidget () ``{
        term targetlist = `VBox (
            `VSpacing (0.4),
            `Left (`RadioButton (`id ("mbr"), `opt (`notify),
		// radiobutton, %1 is device (eg. /dev/hda)
                sformat(_("&Master boot record of %1"), mbrDisk),
                (location == "mbr")
            )),
            `VSpacing (0.4),
            `Left (`RadioButton (`id ("boot"), `opt (`notify),
		// radiobutton, %1 is device (eg. /dev/hda1)
                sformat(_("Boot &Sector of Boot Partition %1"),
                     BootPartitionDevice),
                (location == "boot")
            )),
            `VSpacing (0.4),
            `Left (`RadioButton (`id ("root"), `opt (`notify),
		// radiobutton, %1 is device (eg. /dev/hda1)
                sformat(_("Boot Sector of Roo&t Partition %1"),
                    RootPartitionDevice),
                (location == "root")
            ))
        );

        if (StorageDevices::FloppyPresent)
        {
            targetlist = add (targetlist, `VSpacing (1));
            targetlist = add (targetlist, `Left (`RadioButton (`id ("floppy"),
		 `opt (`notify),
		// radiobutton, %1 is device name, typically /dev/fd0
                sformat (_("&Floppy disk %1"), StorageDevices::FloppyDevice),
                (location == "floppy")
            )));
        }

        targetlist = add (targetlist, `HBox (
            `VBox (`Label (""), `RadioButton (`id ("custom"), `opt (`notify),
		// radiobutton
		_("Ot&her"),
                (location == "custom"))),
            `HSpacing (2),
            `VBox (
                `ComboBox (`id (`loc), `opt (`editable, `hstretch, `notify), "",
                    getPartitionList(`boot)),
                `HSpacing (15)
            ),
            `HStretch ()
        ));

        targetlist = add (targetlist, `VSpacing (0.4));

	// frame
        term widget = `Frame (_("Boot Loader Location"),
            `RadioButtonGroup (`id (`location),
                targetlist
            )
        );
	return $[
	    "widget" : widget,
	    "restore" : ``(BootCommon::targetRead ()),
	    "handle" : ``(BootCommon::targetWrite ()),
//	    "help" : getLocationsHelp (),
	    "validate" : ``(BootCommon::targetValidate ()),
		// table cell / label
	    "label" : _("Boot Loader Location"),
	    "summary" : ``(BootCommon::locationSummary ()),
	    "deletable" : false,
	    "ordering" : false,
	    "key_only_once" : true,
	];
    }

    /**
      * Restore settings of Target widget
      */
    global define void targetRead () ``{
	UI::ChangeWidget (`id (`loc), `Value, loader_device);
	UI::ChangeWidget (`id (`location), `CurrentButton, location);
	UI::SetFocus (`id (`loc));
    }

    /**
      * Handle function of widget
      * @param op any operation to handle
      * @param save boolean true if op should lead to closing & saving widget
      * @return any changed op (if needed)
      */
    global define any targetWrite (any op, boolean save) ``{
	if (! save)
	    return nil;
	location = UI::QueryWidget (`id (`location), `CurrentButton);
	loader_device = UI::QueryWidget (`id (`loc), `Value);
	BootCommon::storeSettings ();
	loader_device = BootCommon::GetBootloaderDevice ();
	BootCommon::location_changed = true;
	return nil;
    }

    /**
      * Validate the target widget
      * @return true if everything is OK
      */
    global define boolean targetValidate () ``{
	string rb = UI::QueryWidget (`id (`location), `CurrentButton);
	if (rb == nil)
	{
	    setLocationErrorPopup ();
	    UI::SetFocus (`id (`location));
	    return false;
	}
	if (rb == "custom" && UI::QueryWidget (`id (`loc), `Value) == "")
	{
	    setLocationErrorPopup ();
	    UI::SetFocus (`is (`loc));
	    return false;
	}
	return true;
    }

    /**
      * Summary function for option
      * @return string summary text
      */
    global define string locationSummary () ``{
	map targetMap = Storage::GetTargetMap ();
	map boot_target = targetMap[loader_device]:$[];
	string target_name = "";
	if (boot_target == $[])
	    target_name = loader_device;
	else
	    target_name = boot_target["name"]:"disk";
	return target_name;
    }


// password widget


    /**
      * Get map of widget
      * @return map of widget
      */
    global define map getPasswdWidget () ``{
	return $[
		// frame
	    "widget" : `VBox (
                `Left (`CheckBox (`id (`usepas), `opt (`notify),
			// checkbox
                    _("&Enable Boot Loader Password Protection"))),
                `HBox (
			// password textentry
                    `HWeight (1, `Password (`id (`pw1), _("&Password"))),
                    `HSpacing (2),
			// password textentry
                    `HWeight (1, `Password (`id (`pw2), _("Re&type Password")))
                ),
                `VSpacing (0.4)
            ),
	    "restore" : ``(BootCommon::restorePasswdWidget ()),
	    "handle" : ``(BootCommon::handlePasswdWidget ()),
	    "validate" : ``(BootCommon::validatePasswdWidget ()),
	    "help" : getPasswdHelp (),
	    "summary" : ``(BootCommon::getPasswdSummary ()),
	    "key_only_once" : true,
	];
    }

    /**
      * Restore function of widget
      */
    global define void restorePasswdWidget () ``{
	string passwd = lookup_value (
	    current_globals, current_option_name, nil);
	if (passwd == nil)
	{
	    UI::ChangeWidget (`id (`usepas), `Value, false);
	    UI::ChangeWidget (`id (`pw1), `Enabled, false);
	    UI::ChangeWidget (`id (`pw1), `Value, "");
	    UI::ChangeWidget (`id (`pw2), `Enabled, false);
	    UI::ChangeWidget (`id (`pw2), `Value, "");
	}
	else
	{
	    UI::ChangeWidget (`id (`usepas), `Value, true);
	    UI::ChangeWidget (`id (`pw1), `Enabled, true);
	    UI::ChangeWidget (`id (`pw1), `Value, "**********");
	    UI::ChangeWidget (`id (`pw2), `Enabled, true);
	    UI::ChangeWidget (`id (`pw2), `Value, "**********");
	}
	UI::SetFocus (`id (`usepas));
    }

    /**
      * Handle function of widget
      * @param op any operation to handle
      * @param save boolean true if op should lead to closing & saving widget
      * @return any changed op (if needed)
      */
    global define any handlePasswdWidget (any op, boolean save) ``{
	if (op == `usepas)
	{
	    boolean enabled = UI::QueryWidget (`id (`usepas), `Value);
	    UI::ChangeWidget (`id (`pw1), `Enabled, enabled);
	    UI::ChangeWidget (`id (`pw2), `Enabled, enabled);
	}
	else if (save)
	{
	    string password = nil;
	    boolean usepass = UI::QueryWidget (`id (`usepas), `Value);
	    y2milestone ("Usepass: %1", usepass);
	    if (usepass)
	    {
		if (UI::QueryWidget (`id (`pw1), `Value) != "**********")
		{
		    password = UI::QueryWidget (`id (`pw1), `Value);
		    if (haskey (BootCommon::current_bootloader_attribs,
			"update_passwd"))
		    {
			eval (BootCommon::current_bootloader_attribs[
			    "update_passwd"]:nil);
		    }
		}
	    }
	    current_section = modifySection (current_section, "password",
		password);
	}
	return nil;
    }

    /**
      * Validate function of widget
      * @return true if widget settings ok
      */
    global define boolean validatePasswdWidget () ``{
	if (! UI::QueryWidget (`id (`usepas), `Value))
	    return true;
	if (UI::QueryWidget (`id (`pw1), `Value) == "")
	{
	    emptyPasswdErrorPopup ();
	    UI::SetFocus (`id (`pw1));
	    return false;
	}
	if (UI::QueryWidget (`id (`pw1), `Value)
	    == UI::QueryWidget (`id (`pw2), `Value)
	)
	    return true;
	passwdMissmatchPopup ();
	UI::SetFocus (`id (`pw1));
	return false;
    }

    /**
      * Summary function for option
      * @return string summary text
      */
    global define string getPasswdSummary () ``{
	if (lookup_value (BootCommon::current_section, "password", nil) != nil)
		// table cell
	    return _("Password will be needed");
	else
		// table cell
	    return _("No password will be needed");
    }

// sections managment widget

    /**
      * Get map of widget
      * @return map of widget
      */
    global define map getSectionsWidget () ``{
	return $[
	    "widget" : `VBox (
		`HBox (
			`Table (`id (`sects), `opt (`keepSorting, `immediate, `notify), `header (
			// table header
			_("Def."),
			// table header
			_("Label"),
			// table header
			_("Type"),
			// table header
			_("Image / Device")
			), []),
		    `HSpacing (1),
		    `VBox (
			`VStretch (),
			// pushbutton
			`PushButton (`id (`up), _("&Up")),
			// pushbutton
			`PushButton (`id (`down), _("&Down")),
			`VStretch ()
		    )
		),
		`HBox (
		    `PushButton (`id (`add), `opt (`key_F3), Label::AddButton ()),
		    `PushButton (`id (`edit), `opt (`key_F4), Label::EditButton ()),
		    `PushButton (`id (`delete), `opt (`key_F5), Label::DeleteButton ()),
		    `HStretch (),
			// pushbutton
		    `PushButton (`id (`default), _("Set as De&fault"))
		)
	    ),
	    "restore" : ``(BootCommon::sectionsRead ()),
	    "handle" : ``(BootCommon::sectionsHandle ()),
	    "help" : getSectionsHelp (),
	    "exits" : [`add, `edit],
	    "key_only_once" : true,
	];
    }

    /**
      * Refresh and redraw widget wits sections
      * @param sects list of current sections
      */
    global define void sectionsRedrawTable (list sects) ``{
	boolean elilo = getLoaderType (false) == "elilo";
	list sec = maplist (map s, sects, ``{
	    string image = lookup_value (s, "image", "");
	    string root = lookup_value (s, "root", "");
            return `item (`id (lookup_value (s, "label", "")),
                lookup_value (current_globals, "default", "")
			== lookup_value (s, "label", "")
                    ? UI::Glyph (`CheckMark) : "",
                lookup_value (s, "label", ""),
                image == "" ? _("other") : _("image"),
                image != ""
                ? sformat ("%1   (%2%3)",
                    image,
                    elilo
			? ""
			: select (BootCommon::splitPath (image), 0, ""),
                    root == "" ? ""
                        : ((elilo ? "" : ", ")
			    + sformat ("root=%1", root)))
                : lookup_value (s, "other", "")
            );
        });
	UI::ChangeWidget (`id (`sects), `Items, sec);
    }

    /**
      * Restore function of widget
      */
    global define void sectionsRead () ``{
	sectionsRedrawTable (BootCommon::current_sections);
	UI::SetFocus (`id (`sects));
    }

    /**
      * Handle function of widget
      * @param op any operation to handle
      * @param save boolean true if op should lead to closing & saving widget
      * @return symbol changed op (if needed)
      */
    global define symbol sectionsHandle (any op, boolean save) ``{
	y2milestone ("Handling event %1", op);
	string current = UI::QueryWidget (`id (`sects), `CurrentItem);
	integer counter = 0;
	integer index = 0;
	foreach (`s, BootCommon::current_sections, ``{
	    if (lookup_value (s, "label", "") == current)
		index = counter;
	    counter = counter + 1;
	});
	list sects = BootCommon::current_sections;
	if (op == `up)
	{
	    if (index > 0)
	    {
		sects = swapItems(sects, index, index - 1);
		index = index - 1;
		BootCommon::current_sections = sects;
		sectionsRedrawTable (sects);
		UI::ChangeWidget (`id (`sects), `CurrentItem,
		    sects[index, "label"]:0);
		BootCommon::sections_changed = true;
	    }
	}
	else if (op == `down)
	{
	    if (index < (size(sects) - 1))
	    {
		sects = swapItems(sects, index, index + 1);
                index = index + 1;
		BootCommon::current_sections = sects;
		sectionsRedrawTable (sects);
		UI::ChangeWidget (`id (`sects), `CurrentItem,
		    sects[index, "label"]:0);
		BootCommon::sections_changed = true;
	    }
	}
	else if (op == `default)
	{
	    addValueToBootloaderSection (`current_globals, "default", current);
	    sectionsRedrawTable (sects);
	    UI::ChangeWidget (`id (`sects), `CurrentItem, current);
	    BootCommon::sections_changed = true;
	}
	else if (op == `add)
	{
	    list selected = sects[index]:[];
	    string name = lookup_value (selected,
		BootCommon::getSectionTitle (), "");
	    if (askClone (name))
	    {
		selected = modifySection (
		    eval (selected),
		    BootCommon::getSectionTitle (),
		    BootCommon::getFreeSectionLabel ());
		BootCommon::current_section = selected;
	    }
	    else
	    {
		BootCommon::current_section = BootCommon::convertSection
		    (nil, "image", nil);
	    }
	    BootCommon::current_section_name = "";
	    BootCommon::one_section_changed = true;
	}
	else if (op == `edit)
	{
	    y2milestone ("Editing title %1, index %2", current, index);
	    BootCommon::current_section = eval (sects[index]:$[]);
	    BootCommon::current_section_name
		= lookup_value (sects[index]:[], "label", "");
	    BootCommon::one_section_changed = false;
	}
	else if (op == `delete && confirmSectionDeletePopup (current))
	{
	    sects = remove (sects, index);
	    if (current ==lookup_value (current_globals,
		"default", ""))
	    {
		addValueToBootloaderSection (`current_globals, "default",
		    lookup_value (sects[0]:[], "label", ""));
	    }
	    BootCommon::current_sections = sects;
	    sectionsRedrawTable (sects);
	    BootCommon::sections_changed = true;
	}
	if (save && op != `edit && op != `add)
	{
	    if (BootCommon::sections_changed)
	    {
		BootCommon::changed = true;
		BootCommon::markOptionChanged (`current_globals, "__sections");
		BootCommon::markOptionChanged (`current_globals, "__default_section");
	    }
	}
	if (op == `back)
	{
	}
	UI::SetFocus (`id (`sects));
	return nil;
    }

    /**
      * Get map of widget
      * @return map of widget
      */
    global define map getLoaderSelectionWidget () ``{
        list loaders = maplist (`l, BootCommon::getBootloaders (), ``{
            return `item (`id (l), BootCommon::getLoaderName (l));
        });

	return $[
	    "widget" : (`ComboBox (`id (`loader_type), `opt (`notify),
			// combobox header
                        _("Boot &Loader Type"), loaders
                    )),
	    "restore" : ``(BootCommon::loaderTypeRestore ()),
	    "handle" : ``(loaderTypeSave ()),
	    "help" : nil,
	    "exits" : [],
		// table item / label
	    "label" : _("Boot Loader Type"),
	    "summary" : ``(BootCommon::loaderTypeSummary ()),
	    "deletable" : false,
	    "ordering" : false,
	    "key_only_once" : true,
	];
    }

    /**
      * Restore function of widget
      */
    global define void loaderTypeRestore () ``{
	UI::ChangeWidget (`id (`loader_type), `Value,
	    BootCommon::getLoaderType (false));
	UI::SetFocus (`id (`loader_type));
    }

    /**
      * Summary function for option
      * @return string summary text
      */
    global define string loaderTypeSummary () ``{
	return BootCommon::getLoaderName (BootCommon::getLoaderType (false));
    }

    /**
      * Get map of widget
      * @return map of widget
      */
    global define map getSingleSectionWidget () ``{
	return $[
	    "widget" : (`HBox (`HSpacing (2), `VBox (
		    `Table (`id (`settings), `opt (`immediate, `notify, `keepSorting),
			`header (_("Ch."), _("Option"), _("Value")), []),
		    `HBox (
			`PushButton (`id (`add), `opt (`key_F3), Label::AddButton ()),
			`PushButton (`id (`edit), `opt (`key_F4), Label::EditButton ()),
			`PushButton (`id (`delete), `opt (`key_F5), Label::DeleteButton ()),
			`HStretch ()
		    )
		), `HSpacing (2))),
	    "restore" : ``(singleSectionRead ()),
	    "handle" : ``(singleSectionHandle ()),
	    "help" : getSingleSectionHelp (),
	    "exits" : [`sections],
	    "key_only_once" : true,
	];
    }

    /**
      * Get map of widget
      * @return map of widget
      */
    global define map getGlobalSectionWidget () ``{
	map ret = getSingleSectionWidget ();
	ret["help"] = getGlobalSectionHelp ();
	ret["handle"] = ``(globalSectionHandle ());
	ret["widget"] = (`HBox (`HSpacing (2), `VBox (
	    `Table (`id (`settings), `opt (`immediate, `notify, `keepSorting),
		// table header, shortcut for changed, keep very short
		`header (_("Ch."),
		// table header
		_("Option"),
		// table header
		_("Value")), []),
	    `HBox (
		`PushButton (`id (`add), `opt (`key_F3), Label::AddButton ()),
		`PushButton (`id (`edit), `opt (`key_F4), Label::EditButton ()),
		`PushButton (`id (`delete), `opt (`key_F5),
		    Label::DeleteButton ()),
		`HStretch (),
		`ReplacePoint (`id (`reset_rp), `VSpacing (0))
	    )
	), `HSpacing (2)));
	return ret;
    }

    /**
      * Update list of options to display in current section
      * @param _options list of all options
      * @return list of options as it should be displayed
      */
    global define list UpdateOptionsList (list _options) ``{
	list prependlist = [];
	list orig_opts = _options;
	any type = BootCommon::getSectionType (BootCommon::current_section);
	if (type == `global)
	{
	    prependlist = ["__loader_type", "__sep2", "__location",
		"__default_section", "__sections", "__activate", "__repl_mbr",
		"__backup_mbr", "__save_method", "__sep1"];
	    _options = filter (`o, _options, ``(
		o["key"]:"" != "boot" && o["key"]:"" != "default"));
	}
	else
	{
	    prependlist = ["label", "__section_type", "__sep1"];
	}
	_options = filter (`o, _options, ``(! contains (
	    prependlist, o["key"]:"")));
	if (Mode::initial)
	{
	    prependlist = filter (`p, prependlist, ``(p != "__save_method"));
	}
	prependlist = maplist (`p, prependlist, ``{
	    map m = getValueMap (orig_opts, p);
	    if (m == $[])
	    {
		m = $[ "key" : p];
	    }
	    return m;
	});
	list options = merge (prependlist, _options);
	return options;
    }

    /**
      * Get map of widget
      * @return map of widget
      */
    global define map getResetButtonWidget () ``{
	return $[
	    "widget" : `VSpacing (0),
	    "handle" : ``(resetButtonHandle ()),
	    "restore" : ``(BootCommon::resetButtonRestore ()),
	    "help" : getSummaryButtonsHelp (),
	    "key_only_once" : true,
	];
    }

    global define void resetButtonRestore () ``{
	list items = [];
	if (getBooleanAttrib ("propose"))
	{
	    items = add (items,
		// menubutton item, keep as short as possible
		`item (`id (`propose), _("&Propose New Configuration")));
	}
	if (getBooleanAttrib ("scratch"))
	{
	    items = add (items,
		// menubutton item, keep as short as possible
		`item (`id (`scratch), _("&Start from Scratch")));
	}
        if ((Mode::normal || Mode::config || Mode::repair)
	    && getBooleanAttrib ("read"))
	{
	    items = add (items,
		// menubutton item, keep as short as possible
		`item (`id (`reread), _("&Reread Configuration from Disk")));
	}
	list additional_entries = getAnyTypeAttrib ("additional_entries", []);
	items = merge (items, additional_entries);

	if ((Mode::normal || Mode::repair)
	    && getBooleanAttrib ("restore_mbr")
	    && SCR::Read (.target.size, "/boot/backup/mbr") > 0)
	{
	    items = add (items,
		// menubutton item, keep as short as possible
		`item (`id (`restore_mbr), _("Restore MBR of hard disk")));
	}

	if (size (items) > 0)
	{
	    UI::ReplaceWidget (`id (`reset_rp),
		`MenuButton (`id (`reset), _("Res&et"), items));
	}
	else
	{
	    UI::ReplaceWidget (`id (`reset_rp), `VSpacing (0));
	}

    }

    /**
      * Get map of widget
      * @return map of widget
      */
    global define map getManualEditWidget () ``{
	return $[
	    "widget" : `HBox (`HStretch (),
		// pushbutton
		`PushButton (`id (`manual), _("E&dit Configuration Files")),
		`HStretch ()
	    ),
	    "exits" : [`manual],
	    "help" : getManualEditHelp (),
	    "key_only_once" : true,
	];
    }

    /**
      * Get map of widget
      * @return map of widget
      */
    global define map getSectionsTableEntry () ``{
	return $[
		// table item / label
	    "label" : _("Available Sections"),
	    "summary" : ``(BootCommon::getSectionsSummary ()),
	    "deletable" : false,
	    "ordering" : false,
	    "key_only_once" : true,
	];
    }

    /**
      * Summary function for option
      * @return string summary text
      */
    global define string getSectionsSummary () ``{
	string default_name = BootCommon::getDefaultSection ();
	string sect_title = BootCommon::getSectionTitle ();
	list sects = maplist (`s, BootCommon::sections, ``{
            string title = lookup_value (s, sect_title, "");
	    boolean is_default = default_name == title;
	    // suffix after section name, keep short, to summary and table
            string def = is_default ? _(" (default)") : "";
	    return sformat ("%1%2", title, def);
        });
	return mergestring (sects, ", ");
    }

    /**
      * Get map of widget
      * @return map of widget
      */
    global define map getDefaultSectionTableEntry () ``{
	return $[
		// table item / label
	    "label" : _("Default Section"),
	    "summary" : ``(BootCommon::getDefaultSection ()),
	    "deletable" : false,
	    "ordering" : false,
	    "key_only_once" : true,
	];
    }

    /**
      * Get map of widget
      * @return map of widget
      */
    global define map getSectionTypeWidget () ``{
        return $[
            "widget" : (`ComboBox (`id (`section_type), `opt (`notify),
			// combobox header
                        _("Section &Type"), ["image", "other"]
                    )),
            "restore" : ``(BootCommon::sectionTypeRestore ()),
            "handle" : ``(BootCommon::sectionTypeSave ()),
            "help" : nil,
            "exits" : [],
		// table item / label
            "label" : _("Section Type"),
            "summary" : ``(BootCommon::sectionTypeSummary ()),
	    "deletable" : false,
	    "ordering" : false,
	    "key_only_once" : true,
        ];
    }

    /**
      * Restore function of widget
      */
    global define void sectionTypeRestore () ``{
	string key = BootCommon::getKernelKey ();
        UI::ChangeWidget (`id (`section_type), `Value,
	    lookup_value (BootCommon::current_section, key, nil) == nil
		? "other"
		: "image");
	UI::SetFocus (`id (`section_type));
    }

    /**
      * Handle function of widget
      * @param op any operation to handle
      * @param save boolean true if op should lead to closing & saving widget
      * @return any changed op (if needed)
      */
    global define any sectionTypeSave (any op, boolean save) ``{
	if (! save)
	    return;
        string ntype = UI::QueryWidget (`id (`section_type), `Value);
	string otype = BootCommon::getSectionType (BootCommon::current_section);
	if (otype == ntype)
	    return nil;
	BootCommon::current_section = BootCommon::convertSection (
	    otype, ntype, BootCommon::current_section);
	return nil;
    }

    /**
      * Summary function for option
      * @return string summary text
      */
    global define string sectionTypeSummary () ``{
	string key = BootCommon::getKernelKey ();
	return lookup_value (
		BootCommon::current_section, key, nil) == nil
	    ? _("other")
	    : _("image");
    }

    /**
      * Get map of widget
      * @return map of widget
      */
    global define map getBackupMbrWidget () ``{
	return $[
	    "restore" : ``(BootCommon::backupMbrRestore ()),
	    "handle" : ``(BootCommon::backupMbrSave ()),
	    "type" : "b",
	    "help" : "", //TODO BootCommon::backupMbrHelp (),
	    "exits" : [],
	    // table item / label
	    "label" : _("Backup original MBR"),
	    // checkbox label, %1 is device (eg. /dev/hda)
	    "widget_label" : sformat (_("&Backup MBR of %1"),
		BootCommon::mbrDisk),
	    "summary" : ``(BootCommon::backupMbrSummary ()),
	    "deletable" : false,
	    "ordering" : false,
	    "key_only_once" : true,
	];
    }

    /**
      * Restore function of widget
      */
    global define void backupMbrRestore () ``{
        UI::ChangeWidget (`id (`value), `Value, backup_mbr);
        UI::SetFocus (`id (`value));
    }

    /**
      * Handle function of widget
      * @param op any operation to handle
      * @param save boolean true if op should lead to closing & saving widget
      * @return any changed op (if needed)
      */
    global define any backupMbrSave (any op, boolean save) ``{
        if (! save)
            return nil;
        backup_mbr = UI::QueryWidget (`id (`value), `Value);
        return nil;
    }

    /**
      * Summary function for option
      * @return string summary text
      */
    global define string backupMbrSummary () ``{
        if (backup_mbr)
            // table item / label, %1 is device (eg. /dev/hda)
            return sformat (_("Backup MBR of %1"), BootCommon::mbrDisk);
        else
            // table item / label
            return _("Do not backup current MBR");
    }


    /**
      * Get map of widget
      * @return map of widget
      */
    global define map getSaveMethod () ``{
	return $[
            "restore" : ``(BootCommon::saveMethodRestore ()),
            "handle" : ``(BootCommon::saveMethodSave ()),
	    "type" : "b",
	    "help" : BootCommon::getSaveMethodHelp (),
	    "exits" : [],
		// table item / label
	    "label" : _("Save method"),
		// table item / label
	    "widget_label" : _("Force &saving everything"),
	    "summary" : ``(BootCommon::saveMethodSummary ()),
	    "deletable" : false,
	    "ordering" : false,
	    "key_only_once" : true,
	];
    }

    /**
      * Restore function of widget
      */
    global define void saveMethodRestore () ``{
        UI::ChangeWidget (`id (`value), `Value, save_all);
        UI::SetFocus (`id (`value));
    }

    /**
      * Handle function of widget
      * @param op any operation to handle
      * @param save boolean true if op should lead to closing & saving widget
      * @return any changed op (if needed)
      */
    global define any saveMethodSave (any op, boolean save) ``{
        if (! save)
            return nil;
        save_all = UI::QueryWidget (`id (`value), `Value);
        return nil;
    }

    /**
      * Summary function for option
      * @return string summary text
      */
    global define string saveMethodSummary () ``{
        if (save_all)
            // table item / label
            return _("Force saving everything");
        else
            // table item / label
            return _("Save only changed files");
    }

    /**
      * Get map of widget
      * @return map of widget
      */
    global define map getTimeoutWidget () ``{
	return $[
	    "restore" : ``(BootCommon::timeoutRestore ()),
	    "handle" : ``(BootCommon::timeoutSave ()),
	    "summary" : ``(BootCommon::timeoutSummary ()),
	    "key_only_once" : true,
	];
    }

    /**
      * Restore function of widget
      */
    global define void timeoutRestore () ``{
	integer timeout = lookup_value (BootCommon::current_section,
	    "timeout", 0);
	UI::ChangeWidget (`id (`value), `Value,
	    timeout / BootCommon::getTimeoutMultiplier ());
	UI::SetFocus (`id (`value));
    }

    /**
      * Handle function of widget
      * @param op any operation to handle
      * @param save boolean true if op should lead to closing & saving widget
      * @return any changed op (if needed)
      */
    global define any timeoutSave (any op, boolean save) ``{
	if (! save)
	    return nil;
	integer timeout = UI::QueryWidget (`id (`value), `Value)
	    * BootCommon::getTimeoutMultiplier ();
	BootCommon::current_section = modifySection (
	    BootCommon::current_section, "timeout", timeout);
	return nil;
    }

    /**
      * Summary function for option
      * @return string summary text
      */
    global define string timeoutSummary () ``{
	integer timeout = lookup_value (current_section, "timeout", 0);
	return sformat (_("%1 s"),
	    timeout / BootCommon::getTimeoutMultiplier ());
    }

    /**
      * Get map of widget
      * @return map of widget
      */
    global define map getLabelWidget () ``{
	return $[
		// table item / label
	    "label" : _("Section Name"),
	    "validate" : ``(BootCommon::labelValidate ()),
	    "deletable" : false,
	    "ordering" : false,
	    "key_only_once" : true,
	];
    }

    /**
      * Validate function of widget
      * @return true if ok
      */
    global define boolean labelValidate () ``{
	list(string) existing = [];
	list(string) aliases = BootCommon::getAliasesKeys ();
	foreach (`s, BootCommon::current_sections, ``{
	    foreach (`e, s, ``{
		if (e["key"]:"" == BootCommon::getSectionTitle ()
		    || contains (aliases, e["key"]:""))
		{
		    existing = add (existing, e["value"]:"");
		}
	    });
	});
	existing = filter (string l, existing,
	    ``(l != BootCommon::current_section_name));
	existing = add (existing, "");
	string new = UI::QueryWidget (`id (`value), `Value);

	if (contains (existing, new))
	{
	    usedNameErrorPopup ();
	    return false;
	}
	return true;
    }

    /**
      * Get map of widget
      * @return map of widget
      */
    global define map getAliasWidget () ``{
	map ret = getLabelWidget ();
	ret["deletable"] = true;
	ret["ordering"] = true;
        ret["validate"] = ``(BootCommon::labelValidate ());
        return ret;
    }

    /**
      * Get map of widget
      * @return map of widget
      */
    global define map getReplMbrWidget () ``{
	return $[
		// table item / label
	    "label" : _("Replace Code in MBR"),
	    "restore" : ``(BootCommon::replMbrRestore ()),
	    "handle" : ``(BootCommon::replMbrHandle ()),
	    "summary" : ``(BootCommon::replMbrSummary ()),
	    "type" : "b",
	    "deletable" : false,
	    "ordering" : false,
	    "key_only_once" : true,
	];
    }

    /**
      * Restore function of widget
      */
    global define void replMbrRestore () ``{
	UI::ChangeWidget (`id (`value), `Value, repl_mbr);
	UI::SetFocus (`id (`value));
    }

    /**
      * Handle function of widget
      * @param op any operation to handle
      * @param save boolean true if op should lead to closing & saving widget
      * @return any changed op (if needed)
      */
    global define any replMbrHandle (any op, boolean save) ``{
        if (! save)
            return nil;
	repl_mbr = UI::QueryWidget (`id (`value), `Value);
	if (repl_mbr)
	    BootCommon::location_changed = true;
	return nil;
    }

    /**
      * Summary function for option
      * @return string summary text
      */
    global define string replMbrSummary () ``{
	if (repl_mbr)
		// table item / label
	    return sformat (_("Replace %1 with Generic Code"),
		BootCommon::mbrDisk);
	else
		// table item / label
	    return _("Leave Untouched");
    }

    /**
      * Get widget map
      * @return map of widget
      */
    global define map getActivateWidget () ``{
	return $[
		// table item
	    "label" : _("Activate Boot Loader Partition"),
	    "restore" : ``(BootCommon::activateRestore ()),
	    "handle" : ``(BootCommon::activateHandle ()),
	    "summary" : ``(BootCommon::activateSummary ()),
	    "type" : "b",
	    "deletable" : false,
	    "ordering" : false,
	    "key_only_once" : true,
	];
    }

    /**
      * Restore function of widget
      */
    global define void activateRestore () ``{
        UI::ChangeWidget (`id (`value), `Value, activate);
	UI::SetFocus (`id (`value));
    }

    /**
      * Handle function of widget
      * @param op any operation to handle
      * @param save boolean true if op should lead to closing & saving widget
      * @return any changed op (if needed)
      */
    global define any activateHandle (any op, boolean save) ``{
        if (! save)
            return nil;
        activate = UI::QueryWidget (`id (`value), `Value);
        if (activate)
            BootCommon::location_changed = true;
	activate_changed = true;
	return nil;
    }

    /**
      * Summary function for option
      * @return string summary text
      */
    global define string activateSummary () ``{
        if (activate)
		// table item
		// FIXME partition %1 of %2
            return sformat (_("Yes, activate %1"),
		lookup (BootCommon::getPartitionToActivate (), "dev", ""));
        else
		// table item
            return _("No");
    }

    /**
      * Get map of widget
      * @return map of widget
      */
    global define map getMessageWidget () ``{
	return $[
	    "delete" : ``(BootCommon::deleteMessage ()),
	    "key_only_once" : true,
	];
    }

    /**
      * Delete function of widget
      */
    global define void deleteMessage () ``{
	BootCommon::current_section = filter (`e, BootCommon::current_section,
	    ``(e["key"]:"" != "__intern__"));
    }

} // include end
