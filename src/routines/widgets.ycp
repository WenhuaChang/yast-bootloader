/**
 * File:
 *      include/bootloader/routines/widgets.ycp
 *
 * Module:
 *      Bootloader installation and configuration
 *
 * Summary:
 *      Common widgets for being used by several bootloaders
 *
 * Authors:
 *      Jiri Srain <jsrain@suse.cz>
 *
 * $Id$
 *
 */


{

    textdomain "bootloader";

    include "ui/common_messages.ycp";
    include "bootloader/routines/popups.ycp";

    /**
      * Get map of dialogs and widgets
      * @return map of dialogs and widgets
      */
    global define map GetWidgets () ``{
	return $[
//		"prompt" : getPromptWidget (),
		"sections" : ``(BootCommon::getSectionsWidget ()),
		"singlesection" : ``(BootCommon::getSingleSectionWidget ()),
		"globalsection" : ``(BootCommon::getGlobalSectionWidget ()),
		"summarybuttons" : ``(BootCommon::getSummaryButtonsWidget ()),
		"tableentries" : $[
		    "__location": ``(BootCommon::getTargetWidget ()),
		    "__loader_type" : ``(BootCommon::getLoaderSelectionWidget ()),
		    "__sections" : ``(BootCommon::getSectionsTableEntry ()),
		    "__default_section" : ``(BootCommon::getDefaultSectionTableEntry ()),
		    "__section_type" : ``(BootCommon::getSectionTypeWidget ()),
		    "__sep1" : $["label" : "---------------"],
		    "__sep2" : $["label" : "---------------"],
		    "__sep3" : $["label" : "---------------"],
		    "label" : ``(BootCommon::getLabelWidget ()),
		    "alias" : ``(BootCommon::getAliasWidget ()),
		    "timeout" : ``(BootCommon::getTimeoutWidget ()),
		    "password" : ``(BootCommon::getPasswdWidget ()),
		    "__repl_mbr" : ``(BootCommon::getReplMbrWidget ()),
		    "activate" : ``(BootCommon::getActivateWidget ()),
		    "message" : ``(BootCommon::getMessageWidget ()),
		],
	];
    }

    /**
      * Generic version of FixSequence function
      * Just leave everything as is
      * @param ws_data map default wizard sequencer data
      * @return map updated wizard sequencer data
      */
    global define map FixSequence (map ws_data) ``{
	return ws_data;
    }

// Bootloader target widget

    /**
      * Get map of Target widget
      * @return map of Target widget
      */
    global define map getTargetWidget () ``{
        term targetlist = `VBox (
            `VSpacing (0.4),
            `Left (`RadioButton (`id ("mbr"), `opt (`notify),
		// radiobutton, %1 is device (eg. /dev/hda)
                sformat(_("&Master boot record of %1"), mbrDisk),
                (location == "mbr")
            )),
            `VSpacing (0.4),
            `Left (`RadioButton (`id ("boot"), `opt (`notify),
		// radiobutton, %1 is device (eg. /dev/hda1)
                sformat(_("Boot &Sector of Boot Partition %1"),
                     BootPartitionDevice),
                (location == "boot")
            )),
            `VSpacing (0.4),
            `Left (`RadioButton (`id ("root"), `opt (`notify),
		// radiobutton, %1 is device (eg. /dev/hda1)
                sformat(_("Boot Sector of Roo&t Partition %1"),
                    RootPartitionDevice),
                (location == "root")
            ))
        );

        if (StorageDevices::FloppyPresent)
        {
            targetlist = add (targetlist, `VSpacing (1));
            targetlist = add (targetlist, `Left (`RadioButton (`id ("floppy"),
		 `opt (`notify),
		// radiobutton
                _("&Floppy disk"),
                (location == "floppy")
            )));
        }

        targetlist = add (targetlist, `HBox (
            `VBox (`Label (""), `RadioButton (`id ("custom"), `opt (`notify),
		// radiobutton
		_("Ot&her"),
                (location == "custom"))),
            `HSpacing (2),
            `VBox (
                `ComboBox (`id (`loc), `opt (`editable, `hstretch, `notify), "",
                    getPartitionList(`boot)),
                `HSpacing (15)
            ),
            `HStretch ()
        ));

        targetlist = add (targetlist, `VSpacing (0.4));

	// frame
        term widget = `Frame (_("Boot Loader Location"),
            `RadioButtonGroup (`id (`location),
                targetlist
            )
        );
	return $[
	    "widget" : widget,
	    "restore" : ``(BootCommon::targetRead ()),
	    "handle" : ``(BootCommon::targetWrite ()),
//	    "help" : getLocationsHelp (),
	    "validate" : ``(BootCommon::targetValidate ()),
		// table cell / label
	    "label" : _("Boot Loader Location"),
	    "summary" : ``(BootCommon::locationSummary ()),
	    "deletable" : false,
	    "ordering" : false,
	];
    }

    /**
      * Restore settings of Target widget
      */
    global define void targetRead () ``{
	UI::ChangeWidget (`id (`loc), `Value, loader_device);
	UI::ChangeWidget (`id (`location), `CurrentButton, location);
	UI::SetFocus (`id (`loc));
    }

    /**
      * Handle function of widget
      * @param op any operation to handle
      * @param tosave list of operations, which lead to closing & saving widget
      * @return any changed op (if needed)
      */
    global define any targetWrite (any op, list tosave) ``{
	if (! contains (tosave, op))
	    return;
	location = UI::QueryWidget (`id (`location), `CurrentButton);
	loader_device = UI::QueryWidget (`id (`loc), `Value);
	BootCommon::storeSettings ();
	loader_device = BootCommon::GetBootloaderDevice ();
	BootCommon::location_changed = true;
	return;
    }

    /**
      * Validate the target widget
      * @return true if everything is OK
      */
    global define boolean targetValidate () ``{
	string rb = UI::QueryWidget (`id (`location), `CurrentButton);
	if (rb == nil)
	{
	    setLocationErrorPopup ();
	    UI::SetFocus (`id (`location));
	    return false;
	}
	if (rb == "custom" && UI::QueryWidget (`id (`loc), `Value) == "")
	{
	    setLocationErrorPopup ();
	    UI::SetFocus (`is (`loc));
	    return false;
	}
	return true;
    }

    /**
      * Summary function for option
      * @return string summary text
      */
    global define string locationSummary () ``{
	map targetMap = Storage::GetTargetMap ();
	map boot_target = targetMap[loader_device]:$[];
	string target_name = "";
	if (boot_target == $[])
	    target_name = loader_device;
	else
	    target_name = boot_target["name"]:"disk";
	return target_name;
    }


// password widget


    /**
      * Get map of widget
      * @return map of widget
      */
    global define map getPasswdWidget () ``{
	return $[
		// frame
	    "widget" : `VBox (
                `Left (`CheckBox (`id (`usepas), `opt (`notify),
			// checkbox
                    _("&Enable Boot Loader Password Protection"))),
                `HBox (
			// password textentry
                    `HWeight (1, `Password (`id (`pw1), _("&Password"))),
                    `HSpacing (2),
			// password textentry
                    `HWeight (1, `Password (`id (`pw2), _("Re&type Password")))
                ),
                `VSpacing (0.4)
            ),
	    "restore" : ``(BootCommon::restorePasswdWidget ()),
	    "handle" : ``(BootCommon::handlePasswdWidget ()),
	    "validate" : ``(BootCommon::validatePasswdWidget ()),
	    "help" : getPasswdHelp (),
	    "summary" : ``(BootCommon::getPasswdSummary ()),
	];
    }

    /**
      * Restore function of widget
      */
    global define void restorePasswdWidget () ``{
	string passwd = current_globals[current_option_name]:nil;
	if (passwd == nil)
	{
	    UI::ChangeWidget (`id (`usepas), `Value, false);
	    UI::ChangeWidget (`id (`pw1), `Enabled, false);
	    UI::ChangeWidget (`id (`pw1), `Value, "");
	    UI::ChangeWidget (`id (`pw2), `Enabled, false);
	    UI::ChangeWidget (`id (`pw2), `Value, "");
	}
	else
	{
	    UI::ChangeWidget (`id (`usepas), `Value, true);
	    UI::ChangeWidget (`id (`pw1), `Enabled, true);
	    UI::ChangeWidget (`id (`pw1), `Value, "**********");
	    UI::ChangeWidget (`id (`pw2), `Enabled, true);
	    UI::ChangeWidget (`id (`pw2), `Value, "**********");
	}
	UI::SetFocus (`id (`usepas));
    }

    /**
      * Handle function of widget
      * @param op any operation to handle
      * @param tosave list of operations, which lead to closing & saving widget
      * @return any changed op (if needed)
      */
    global define any handlePasswdWidget (any op, list tosave) ``{
	if (op == `usepas)
	{
	    boolean enabled = UI::QueryWidget (`id (`usepas), `Value);
	    UI::ChangeWidget (`id (`pw1), `Enabled, enabled);
	    UI::ChangeWidget (`id (`pw2), `Enabled, enabled);
	}
	else if (contains (tosave, op))
	{
	    boolean usepass = UI::QueryWidget (`id (`usepas), `Value);
	    y2milestone ("Usepass: %1", usepass);
	    if (usepass)
	    {
		if (UI::QueryWidget (`id (`pw1), `Value) != "**********")
		{
		    string ps = UI::QueryWidget (`id (`pw1), `Value);
		    if (getLoaderType (false) == "grub")
			ps = sformat ("--md5 %1", cryptmd5 (ps));
		    current_section["password"] = ps;
		}
	    }
	    else if (haskey (current_section, "password"))
	    {
		current_section
		    = remove (current_section, "password");
	    }
	}
    }

    /**
      * Validate function of widget
      * @return true if widget settings ok
      */
    global define boolean validatePasswdWidget () ``{
	if (! UI::QueryWidget (`id (`usepas), `Value))
	    return true;
	if (UI::QueryWidget (`id (`pw1), `Value) == "")
	{
	    emptyPasswdErrorPopup ();
	    UI::SetFocus (`id (`pw1));
	    return false;
	}
	if (UI::QueryWidget (`id (`pw1), `Value)
	    == UI::QueryWidget (`id (`pw2), `Value)
	)
	    return true;
	passwdMissmatchPopup ();
	UI::SetFocus (`id (`pw1));
	return false;
    }

    /**
      * Summary function for option
      * @return string summary text
      */
    global define string getPasswdSummary () ``{
	if (BootCommon::current_section["password"]:nil != nil)
		// table cell
	    return _("Password will be needed");
	else
		// table cell
	    return _("No password will be needed");
    }

// sections managment widget

    /**
      * Get map of widget
      * @return map of widget
      */
    global define map getSectionsWidget () ``{
	return $[
	    "widget" : `VBox (
		`HBox (
		    `ReplacePoint (`id (`sects_rp),
			`Table (`id (`sects), `opt (`keepSorting), `header (
			// table header
			_("Def."),
			// table header
			_("Label"),
			// table header
			_("Type"),
			// table header
			_("Image / Device")
			), [])
		    ),
		    `HSpacing (1),
		    `VBox (
			`VStretch (),
			// pushbutton
			`PushButton (`id (`up), _("&Up")),
			// pushbutton
			`PushButton (`id (`down), _("&Down")),
			`VStretch ()
		    )
		),
		`HBox (
		    `PushButton (`id (`add), `opt (`key_F3), AddButtonLabel ()),
		    `PushButton (`id (`edit), `opt (`key_F4), EditButtonLabel ()),
		    `PushButton (`id (`delete), `opt (`key_F5), DeleteButtonLabel ()),
		    `HStretch (),
			// pushbutton
		    `PushButton (`id (`default), _("Set as De&fault"))
		)
	    ),
	    "restore" : ``(BootCommon::sectionsRead ()),
	    "handle" : ``(BootCommon::sectionsHandle ()),
	    "help" : getSectionsHelp (),
	    "exits" : [`add, `edit],
	];
    }

    /**
      * Refresh and redraw widget wits sections
      * @param sects list of current sections
      */
    global define void sectionsRedrawTable (list sects) ``{
	list sec = maplist (map s, sects, ``{
            return `item (`id (s["label"]:""),
                BootCommon::current_globals["default"]:""
			== s["label"]:""
                    ? UI::Glyph (`CheckMark) : "",
                s["label"]:"",
                s["image"]:"" == "" ? _("other") : _("image"),
                s["image"]:"" != ""
                ? sformat ("%1   (%2%3)",
                    s["image"]:"",
                    select (BootCommon::splitPath (s["image"]:""), 0, ""),
                    s["root"]:"" == "" ? ""
                        : sformat (", root=%1", s["root"]:""))
                : s["other"]:""
            );
        });
	UI::ReplaceWidget (`id (`sects_rp),
	    `Table (`id (`sects), `opt (`keepSorting), `header (
		// table header
		_("Default"),
		// table header
		_("Label"),
		// table header
		_("Type"),
		// table header
		_("Image / Device")
	    ), sec)
	);
    }

    /**
      * Restore function of widget
      */
    global define void sectionsRead () ``{
	sectionsRedrawTable (BootCommon::current_sections);
	UI::SetFocus (`id (`sects));
    }

    /**
      * Handle function of widget
      * @param op any operation to handle
      * @param tosave list of operations, which lead to closing & saving widget
      * @return symbol changed op (if needed)
      */
    global define symbol sectionsHandle (any op, list tosave) ``{
	y2milestone ("Handling event %1", op);
	string current = UI::QueryWidget (`id (`sects), `CurrentItem);
	integer counter = 0;
	integer index = 0;
	foreach (`s, BootCommon::current_sections, ``{
	    if (s["label"]:"" == current)
		index = counter;
	    counter = counter + 1;
	});
	list sects = BootCommon::current_sections;
	if (op == `up)
	{
	    if (index > 0)
	    {
		sects = swapItems(sects, index, index - 1);
		index = index - 1;
		BootCommon::current_sections = sects;
		sectionsRedrawTable (sects);
		UI::ChangeWidget (`id (`sects), `CurrentItem,
		    sects[index, "label"]:0);
		BootCommon::sections_changed = true;
	    }
	}
	else if (op == `down)
	{
	    if (index < (size(sects) - 1))
	    {
		sects = swapItems(sects, index, index + 1);
                index = index + 1;
		BootCommon::current_sections = sects;
		sectionsRedrawTable (sects);
		UI::ChangeWidget (`id (`sects), `CurrentItem,
		    sects[index, "label"]:0);
		BootCommon::sections_changed = true;
	    }
	}
	else if (op == `default)
	{
	    BootCommon::current_globals["default"] = current;
	    sectionsRedrawTable (sects);
	    UI::ChangeWidget (`id (`sects), `CurrentItem, current);
	    BootCommon::sections_changed = true;
	}
	else if (op == `add)
	{
	    BootCommon::current_section = $[
		"label" : getFreeSectionLabel (),
		"image" : "",
		"initrd" : "",
		"root" : "",
	    ];
	    BootCommon::current_section_name = "";
	    BootCommon::current_section_type = "image";
	    BootCommon::changed_settings[""] = $[];// FIXME this is wrong due to name and "current" variable
	    BootCommon::one_section_changed = true;
	}
	else if (op == `edit)
	{
	    y2milestone ("Editing title %1, index %2", current, index);
	    BootCommon::current_section = eval (sects[index]:$[]);
	    BootCommon::current_section_name
		= sects[index, "label"]:"";
	    BootCommon::current_section_type
		= sects[index, "image"]:"" == "" ? "other" : "image";

	    BootCommon::changed_settings_single_sect
		= eval (BootCommon::changed_settings[sects[index, "label"]:""]:$[]);
	    y2milestone ("Changed settings: %1", BootCommon::changed_settings_single_sect);
	    BootCommon::one_section_changed = false;
	}
	else if (op == `delete && confirmSectionDeletePopup (current))
	{
	    sects = remove (sects, index);
	    if (current == BootCommon::current_globals["default"]:"")
	    {
		BootCommon::current_globals["default"]
		    = sects[0, "label"]:"";
	    }
	    BootCommon::current_sections = sects;
	    sectionsRedrawTable (sects);
	    BootCommon::sections_changed = true;
	}
	if (contains (tosave, op) && op != `edit && op != `add)
	{
	    if (BootCommon::sections_changed)
	    {
		BootCommon::markOptionChanged (`global, "__sections");
		BootCommon::markOptionChanged (`global, "__default_section");
	    }
	}
	if (op == `back)
	{
	    BootCommon::changed_settings
		= eval (BootCommon::changed_settings_all_sections);
	    y2milestone ("Restoring changed to %1", BootCommon::changed_settings);
	}
	UI::SetFocus (`id (`sects));
    }

    /**
      * Get map of widget
      * @return map of widget
      */
    global define map getLoaderSelectionWidget () ``{
        list loaders = maplist (`l, BootCommon::getBootloaders (), ``{
            return `item (`id (l), BootCommon::getLoaderName (l));
        });

	return $[
	    "widget" : (`ComboBox (`id (`loader_type), `opt (`notify),
			// combobox header
                        _("Boot &Loader Type"), loaders
                    )),
	    "restore" : ``(BootCommon::loaderTypeRestore ()),
	    "handle" : ``(loaderTypeSave ()),
	    "help" : nil,
	    "exits" : [],
		// table item / label
	    "label" : _("Boot Loader Type"),
	    "summary" : ``(BootCommon::loaderTypeSummary ()),
	    "deletable" : false,
	    "ordering" : false,
	];
    }

    /**
      * Restore function of widget
      */
    global define void loaderTypeRestore () ``{
	UI::ChangeWidget (`id (`loader_type), `Value,
	    BootCommon::getLoaderType (false));
	UI::SetFocus (`id (`loader_type));
    }

    /**
      * Summary function for option
      * @return string summary text
      */
    global define string loaderTypeSummary () ``{
	return BootCommon::getLoaderName (BootCommon::getLoaderType (false));
    }

    /**
      * Get map of widget
      * @return map of widget
      */
    global define map getSingleSectionWidget () ``{
	return $[
	    "widget" : (`HBox (`HSpacing (2), `VBox (
		    `Table (`id (`settings), `opt (`immediate, `notify, `keepSorting),
			`header (_("Ch."), _("Option"), _("Value")), []),
		    `HBox (
			`PushButton (`id (`add), `opt (`key_F3), AddButtonLabel ()),
			`PushButton (`id (`edit), `opt (`key_F4), EditButtonLabel ()),
			`PushButton (`id (`delete), `opt (`key_F5), DeleteButtonLabel ()),
			`HStretch ()
		    )
		), `HSpacing (2))),
	    "restore" : ``(singleSectionRead ()),
	    "handle" : ``(singleSectionHandle ()),
	    "help" : getSingleSectionHelp (),
	    "exits" : [`sections],
	];
    }

    /**
      * Get map of widget
      * @return map of widget
      */
    global define map getGlobalSectionWidget () ``{
	map ret = getSingleSectionWidget ();
	ret["help"] = getGlobalSectionHelp ();
	ret["handle"] = ``(globalSectionHandle ());
	return ret;
    }

    /**
      * Update list of options to display in current section
      * @param _options map of all options (includinf order)
      * @return list of options as should bve displayed
      */
    global define list UpdateOptionsList (map _options) ``{
	list options = maplist (`k, `v, _options, ``(k));
	any type = BootCommon::current_section_type;
	if (type == `global)
	{
	    options = filter (`o, options, ``(o != "boot" && o != "default"));
	    options = filter (`o, options, ``(o != "loader_type"
		&& o != "location" && o != "default_section" && o != "sections"
		&& o != `repl_mbr && o != "activate"
	    ));
	    options = prepend (options, "__sep1");
	    options = prepend (options, "__repl_mbr");
	    options = prepend (options, "activate");
	    options = prepend (options, "__sections");
	    options = prepend (options, "__default_section");
	    options = prepend (options, "__location");
	    options = prepend (options, "__sep2");
	    options = prepend (options, "__loader_type");
	}
	else
	{
	    options = filter (`o, options, ``(o != "type" && o != "label"));
	    options = prepend (options, "__sep1");
	    options = prepend (options, "__section_type");
	    options = prepend (options, "label");
	}
	return options;
    }

    /**
      * Get map of widget
      * @return map of widget
      */
    global define map getSummaryButtonsWidget () ``{
	list items = [
		// menubutton item, keep as short as possible
            `item (`id (`propose), _("&Propose New Configuration")),
		// menubutton item, keep as short as possible
            `item (`id (`scratch), _("&Start from Scratch")),
	];
	if (Mode::normal || Mode::config || Mode::repair)
	    items = add (items,
		// menubutton item, keep as short as possible
                `item (`id (`reread), _("&Reread Configuration from Disk")));
	if (/*Mode::initial &&*/ BootCommon::getLoaderType (false) == "grub")
	    items = add (items, `item (`id (`propose_deep),
		// menubutton item, keep as short as possible
		_("Propose a New Configuration and &Merge with Other Existing Linux Menus")));
	return $[
	    "widget" : `HBox (`HStretch (),
//		`MenuButton (`id (`restore), _("Res&et"), items),
		// pushbutton
                `PushButton (`id (`manual), _("E&dit Configuration Files")),
		`HStretch ()
	    ),
	    "exits" : [`manual],
	    "handle" : ``(resetButtonHandle ()),
	    "help" : getSummaryButtonsHelp (),
	];
    }

    /**
      * Get map of widget
      * @return map of widget
      */
    global define map getSectionsTableEntry () ``{
	return $[
		// table item / label
	    "label" : _("Available Sections"),
	    "summary" : ``(BootCommon::getSectionsSummary ()),
	    "deletable" : false,
	    "ordering" : false,
	];
    }

    /**
      * Summary function for option
      * @return string summary text
      */
    global define string getSectionsSummary () ``{
	string default_name = BootCommon::getDefaultSection ();
	string sect_title = BootCommon::getSectionTitle ();
	list sects = maplist (`s, BootCommon::sections, ``{
            string title = s[sect_title]:"";
	    boolean is_default = default_name == title;
	    // suffix after section name, keep short, to summary and table
            string def = is_default ? _(" (default)") : "";
	    return sformat ("%1%2", title, def);
        });
	return mergestring (sects, ", ");
    }

    /**
      * Get map of widget
      * @return map of widget
      */
    global define map getDefaultSectionTableEntry () ``{
	return $[
		// table item / label
	    "label" : _("Default Section"),
	    "summary" : ``(BootCommon::getDefaultSection ()),
	    "deletable" : false,
	    "ordering" : false,
	];
    }

    /**
      * Get map of widget
      * @return map of widget
      */
    global define map getSectionTypeWidget () ``{
        return $[
            "widget" : (`ComboBox (`id (`section_type), `opt (`notify),
			// combobox header
                        _("Section &Type"), ["image", "other"]
                    )),
            "restore" : ``(BootCommon::sectionTypeRestore ()),
            "handle" : ``(BootCommon::sectionTypeSave ()),
            "help" : nil,
            "exits" : [],
		// table item / label
            "label" : _("Section Type"),
            "summary" : ``(BootCommon::sectionTypeSummary ()),
	    "deletable" : false,
	    "ordering" : false,
        ];
    }

    /**
      * Restore function of widget
      */
    global define void sectionTypeRestore () ``{
	string key = BootCommon::getKernelKey ();
        UI::ChangeWidget (`id (`section_type), `Value,
	    BootCommon::current_section[key]:nil == nil
		? "other"
		: "image");
	UI::SetFocus (`id (`section_type));
    }

    /**
      * Handle function of widget
      * @param op any operation to handle
      * @param tosave list of operations, which lead to closing & saving widget
      * @return any changed op (if needed)
      */
    global define any sectionTypeSave (any op, list tosave) ``{
	if (! contains (tosave, op))
	    return;
        string ntype = UI::QueryWidget (`id (`section_type), `Value);
	string otype = BootCommon::current_section[
		BootCommon::getKernelKey ()]:nil == nil
	    ? "other"
	    : "image";
	if (otype == ntype)
	    return;
	BootCommon::current_section = BootCommon::convertSection (
	    otype, ntype, BootCommon::current_section);
	BootCommon::current_section_type = ntype;
    }

    /**
      * Summary function for option
      * @return string summary text
      */
    global define string sectionTypeSummary () ``{
	string key = BootCommon::getKernelKey ();
	return BootCommon::current_section[key]:nil == nil
	    ? "other"
	    : "image";
    }

    /**
      * Get map of widget
      * @return map of widget
      */
    global define map getTimeoutWidget () ``{
	return $[
	    "restore" : ``(BootCommon::timeoutRestore ()),
	    "handle" : ``(BootCommon::timeoutSave ()),
	    "summary" : ``(BootCommon::timeoutSummary ()),
	];
    }

    /**
      * Restore function of widget
      */
    global define void timeoutRestore () ``{
	integer timeout = BootCommon::current_section["timeout"]:0;
	UI::ChangeWidget (`id (`value), `Value,
	    timeout / BootCommon::getTimeoutMultiplier ());
	UI::SetFocus (`id (`value));
    }

    /**
      * Handle function of widget
      * @param op any operation to handle
      * @param tosave list of operations, which lead to closing & saving widget
      * @return any changed op (if needed)
      */
    global define any timeoutSave (any op, list tosave) ``{
	if (! contains (tosave, op))
	    return op;
	integer timeout = UI::QueryWidget (`id (`value), `Value)
	    * BootCommon::getTimeoutMultiplier ();
	BootCommon::current_section["timeout"] = timeout;
	return op;
    }

    /**
      * Summary function for option
      * @return string summary text
      */
    global define string timeoutSummary () ``{
	integer timeout = BootCommon::current_section["timeout"]:0;
	return sformat (_("%1 s"),
	    timeout / BootCommon::getTimeoutMultiplier ());
    }

    /**
      * Get map of widget
      * @return map of widget
      */
    global define map getLabelWidget () ``{
	return $[
		// table item / label
	    "label" : _("Section Name"),
	    "validate" : ``(BootCommon::labelValidate ()),
	    "deletable" : false,
	    "ordering" : false,
	];
    }

    /**
      * Validate function of widget
      * @return true if ok
      */
    global define boolean labelValidate () ``{
	list(string) existing = [];
	list(string) aliases = BootCommon::getAliasesKeys ();
	foreach (`s, BootCommon::current_sections, ``{
	    existing = add (existing, s[BootCommon::getSectionTitle ()]:"");
	    foreach (`a, aliases, ``{
		existing = add (existing, s[a]:"");
	    });
	});
	existing = filter (string l, existing,
	    ``(l != BootCommon::current_section_name));
	existing = add (existing, "");
	string new = UI::QueryWidget (`id (`value), `Value);

	if (contains (existing, new))
	{
	    usedNameErrorPopup ();
	    return false;
	}
	return true;
    }

    /**
      * Get map of widget
      * @return map of widget
      */
    global define map getAliasWidget () ``{
	map ret = getLabelWidget ();
	ret["deletable"] = true;
	ret["ordering"] = true;
        ret["validate"] = ``(BootCommon::labelValidate ());
        return ret;
    }

    /**
      * Get map of widget
      * @return map of widget
      */
    global define map getReplMbrWidget () ``{
	return $[
		// table item / label
	    "label" : _("Replace Code in MBR"),
	    "restore" : ``(BootCommon::replMbrRestore ()),
	    "handle" : ``(BootCommon::replMbrHandle ()),
	    "summary" : ``(BootCommon::replMbrSummary ()),
	    "type" : "b",
	    "deletable" : false,
	    "ordering" : false,
	];
    }

    /**
      * Restore function of widget
      */
    global define void replMbrRestore () ``{
	UI::ChangeWidget (`id (`value), `Value, repl_mbr);
	UI::SetFocus (`id (`value));
    }

    /**
      * Handle function of widget
      * @param op any operation to handle
      * @param tosave list of operations, which lead to closing & saving widget
      * @return any changed op (if needed)
      */
    global define any replMbrHandle (any op, list tosave) ``{
        if (! contains (tosave, op))
            return op;
	repl_mbr = UI::QueryWidget (`id (`value), `Value);
	if (repl_mbr)
	    BootCommon::location_changed = true;
	return op;
    }

    /**
      * Summary function for option
      * @return string summary text
      */
    global define string replMbrSummary () ``{
	if (repl_mbr)
		// table item / label
	    return _("Replace with Generic Code");
	else
		// table item / label
	    return _("Leave Untouched");
    }

    /**
      * Get widget map
      * @return map of widget
      */
    global define map getActivateWidget () ``{
	return $[
		// table item
	    "label" : _("Activate Boot Loader Partition"),
	    "restore" : ``(BootCommon::activateRestore ()),
	    "handle" : ``(BootCommon::activateHandle ()),
	    "summary" : ``(BootCommon::activateSummary ()),
	    "type" : "b",
	    "deletable" : false,
	    "ordering" : false,
	];
    }

    /**
      * Restore function of widget
      */
    global define void activateRestore () ``{
        UI::ChangeWidget (`id (`value), `Value, activate);
	UI::SetFocus (`id (`value));
    }

    /**
      * Handle function of widget
      * @param op any operation to handle
      * @param tosave list of operations, which lead to closing & saving widget
      * @return any changed op (if needed)
      */
    global define any activateHandle (any op, list tosave) ``{
        if (! contains (tosave, op))
            return op;
        activate = UI::QueryWidget (`id (`value), `Value);
        if (activate)
            BootCommon::location_changed = true;

	return op;
    }

    /**
      * Summary function for option
      * @return string summary text
      */
    global define string activateSummary () ``{
        if (activate)
		// table item
            return _("Yes");
        else
		// table item
            return _("No");
    }

    /**
      * Get map of widget
      * @return map of widget
      */
    global define map getMessageWidget () ``{
	return $[
	    "delete" : ``(BootCommon::deleteMessage ()),
	];
    }

    /**
      * Delete function of widget
      */
    global define void deleteMessage () ``{
	BootCommon::current_section = remove
	    (BootCommon::current_section, "__intern__");
    }

} // include end
