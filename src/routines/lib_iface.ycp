/**
 * File:
 *      include/bootloader/routines/lib-iface.ycp
 *
 * Module:
 *      Bootloader installation and configuration
 *
 * Summary:
 *      Functions to interface the bootloader library
 *
 * Authors:
 *      Jiri Srain <jsrain@suse.cz>
 *
 * $Id$
 *
 * WARNING:
 *      To be included to BootCommon.ycp only
 *      Use import "BootCommon" instead.
 */



{

textdomain "bootloader";

import "System::Bootloader_API";
import "Storage";

/**
 * Loader the library has been initialized to use
 */
string library_initialized = nil;

/**
 * Prepare the data for perl-Bootloader library initialization
 * @return a map of data needed for the library initialization
 */
map<string,any> PrepareInitData () {
    map<string,any> mountpoints = mapmap (string k, list v,
	(map<string,list>)Storage::GetMountPoints (),
    {
	return $[ k : (any)v[0]:nil];
    });
    // get what's really mounted
    list<map<string,any> > mounted_list = (list<map<string,any> >)
	SCR::Read (.proc.mounts);
    map<string,string> mounted = listmap (map<string,any> m, mounted_list, {
	return $[ m["file"]:"" : m["spec"]:"" ];
    });
    y2milestone ("Really mounted: %1", mounted);
    mountpoints = filter (string k, any v, mountpoints, {
	string tmpdir = (string)SCR::Read (.target.tmpdir);
	integer tmp_sz = size (tmpdir);
	return is (v, string) && substring (k, 0, tmp_sz) != tmpdir;
    });
    if (! Stage::initial ())
    {
	mountpoints = filter (string k, any v, mountpoints, {
	    return mounted[k]:nil == v;
	});
    }
    y2milestone ("Detected mountpoints: %1", mountpoints);

    map<string,list<string> > md_info = $[];
    map<string,map> tm = (map<string,map>)Storage::GetTargetMap ();
    list<list<list> > pi = maplist (string disk, map info, tm,
    {
	if (info["type"]:`CT_UNKNOWN==`CT_LVM)
	    return [];
	list partitions = info["partitions"]:[];
	list<list> parts = maplist (map p, (list<map>)partitions, {
	    string raid = "";
	    if( p["used_by_type"]:`UB_NONE==`UB_MD )
		raid = p["used_by"]:"";
	    string device = p["device"]:"";
	    if (raid != "")
	    {
		list<string> members = md_info[raid]:[];
		members = add (members, device);
		md_info[raid] = members;
	    }
	    any nr = p["nr"]:nil;
	    if (nr == nil)
		nr = 0;
	    string nr_str = sformat ("%1", nr);
     /* FIXME: And the other information about the disk ?:
            p["fsid"] = LibStorage::PartitionInfo::swig_id_get(info);
            p["fstype"] = Partitions::FsIdToString( p["fsid"]:0 );
            p["region"] = [ LibStorage::PartitionInfo::swig_cylStart_get(info),
                            LibStorage::PartitionInfo::swig_cylSize_get(info) ];
            p["type"] = toSymbol( conv_ptype, t );
            p["boot"] = true;
      */

	    return [ device, disk, nr_str, tostring(p["fsid"]:0),
		p["fstype"]:"unknown", tostring(p["type"]:nil),
		tostring(p["region", 0]:0), tostring(p["region", 1]:0)
	    ];
	});
	return parts;
    });
    list<list> partinfo = flatten (pi);
    partinfo = filter (list p, partinfo, {return p != nil && p != [];});
    y2milestone ("Information about partitioning: %1", partinfo);
    y2milestone ("Information about MD arrays: %1", md_info);

    return $[
	"mountpoints" : mountpoints,
	"partitions" : partinfo,
	"md_arrays" : md_info,
    ];
}

/**
 * Initialize the bootloader library
 * @param force boolean true if the initialization is to be forced
 * @param loader string the loader to initialize the library for
 * @return boolean true on success
 */
global boolean InitializeLibrary (boolean force, string loader) {
    if (!force && loader == library_initialized)
        return true;

    y2milestone ("Initializing lib for %1", loader);
    System::Bootloader_API::initBootloader (loader);
    y2milestone ("Putting partitioning into library");
    map<string,any> init_data = PrepareInitData ();
    map<string,string> mountpoints = init_data["mountpoints"]:$[];
    list<list<string> > partitions = init_data["partitions"]:[];
    map<string,list<string> > md_arrays = init_data["md_arrays"]:$[];
    System::Bootloader_API::setMountPoints (mountpoints);
    System::Bootloader_API::setPartitions (partitions);
    System::Bootloader_API::setMDArrays (md_arrays);
    y2milestone ("Library initialization finished");
    library_initialized = loader;
    return true; // FIXME error checking
}

/**
 * Set boot loader sections
 * @param sections a list of all loader sections (as maps)
 * @return boolean true on success
 */
global boolean SetSections (list<map<string,string> > sections) {
    y2milestone ("Storing bootloader sections %1", sections);
    sections = maplist (map<string,string> s, sections, {
	s["__modified"] = "1";
	s = filter (string key, string value, s, {
	    return (! is (value, string)) || (value != "");
	});
	// FIXME: this distinction should be done in perl-Bootloader,
	// this is not generic
	if (s["type"]:"" == "xen")
	    s["type"] = "image";
	return s;
    });
    boolean ret = System::Bootloader_API::setSections (sections);
    if (! ret)
	y2error ("Storing bootloader sections failed");
    return ret;
}

/**
 * Get boot loader sections
 * @return a list of all loader sections (as maps)
 */
global list<map<string,string> > GetSections () {
    y2milestone ("Reading bootloader sections");
    list<map<string,string> > sects = System::Bootloader_API::getSections ();
    if (sects == nil)
    {
	y2error ("Reading sections failed");
	return [];
    }
    y2milestone ("Read sections: %1", sects);
    return sects;
}

/**
 * Set global bootloader options
 * @param globals a map of global bootloader options
 * @return boolean true on success
 */
global boolean SetGlobal (map<string,string> globals) {
    y2milestone ("Storing global options %1", globals);
    globals["__modified"] = "1";
    boolean ret = System::Bootloader_API::setGlobalOptions (globals);
    if (! ret)
	y2error ("Storing global options failed");
    return ret;
}

/**
 * Get global bootloader options
 * @return a map of global bootloader options
 */
global map<string,string> GetGlobal () {
    y2milestone ("Reading bootloader global options");
    map<string,string> glob = System::Bootloader_API::getGlobalOptions ();
    if (glob == nil)
    {
	y2error ("Reading global options failed");
	return $[];
    }
    y2milestone ("Read global options: %1", glob);
    return glob;
}

/**
 * Set the device mapping (Linux <-> Firmware)
 * @param device_map a map from Linux device to Firmware device identification
 * @return boolean true on success
 */
global boolean SetDeviceMap (map<string,string> device_map) {
    y2milestone ("Storing device map");
    boolean ret = System::Bootloader_API::setDeviceMapping (device_map);
    if (! ret)
	y2error ("Storing device map failed");
    return ret;
}

/**
 * Get the device mapping (Linux <-> Firmware)
 * @return a map from Linux device to Firmware device identification
 */
global map<string,string> GetDeviceMap () {
    y2milestone ("Reading device mapping");
    map<string,string> devmap = System::Bootloader_API::getDeviceMapping ();
    if (devmap == nil)
    {
	y2error ("Reading device mapping failed");
	return $[];
    }
    y2milestone ("Read device mapping: %1", devmap);
    return devmap;
}

/*
 * Display the log file written by the underlying bootloader libraries 
 */
global void bootloaderError (string error) {
    string bl_logfile = "/var/log/YaST2/y2log_bootloader";
    string bl_log = (string)SCR::Read (.target.string, bl_logfile);

    errorWithLogPopup (
	sformat (
	    // error popup - label, %1 is bootloader name
	    _("Error occurred while installing %1."),
	    BootCommon::getLoaderName (BootCommon::getLoaderType (false), `summary)
	),
	bl_log
    );
    y2error ("%1", error);
}

/**
 * Read the files from the system to internal cache of the library
 * @return boolean true on success
 */
global boolean ReadFiles () {
    y2milestone ("Reading Files");
    boolean ret = System::Bootloader_API::initConfig ();
    if (! ret)
	y2error ("Reading files failed");
    return ret;
}

/**
 * Flush the internal cache of the library to the disk
 * @return boolean true on success
 */
global boolean CommitSettings () {
    y2milestone ("Writing files to system");
    boolean ret = System::Bootloader_API::commitSettings ();
    if (! ret)
	bootloaderError ("Writing files to system failed");
    return ret;
}

/**
 * Update the bootloader settings, make updated saved settings active
 * @return boolean true on success
 */
global boolean UpdateBootloader () {
    y2milestone ("Updating bootloader configuration");
    boolean ret = System::Bootloader_API::updateBootloader (true);
    y2milestone ("return value from updateBootloader: %1", ret);
    if (! ret)
	bootloaderError ("Error occurred while updating configuration files");
    return ret;
}

/**
 * Initialize the boot loader (eg. modify firmware, depending on architecture)
 * @return boolean true on success
 */
global boolean InitializeBootloader () {
    y2milestone ("Initializing bootloader");
    boolean ret = System::Bootloader_API::initializeBootloader ();
    if (! ret)
        bootloaderError ("Error occurred while initializing bootloader");
    return ret;
}

/**
 * Get contents of files from the library cache
 * @return a map filename -> contents, empty map in case of fail
 */
global map<string,string> GetFilesContents () {
    y2milestone ("Getting contents of files");
    map<string,string> ret = System::Bootloader_API::getFilesContents ();
    if (ret == nil)
    {
	y2error ("Getting contents of files failed");
	return $[];
    }
    return ret;
}

/**
 * Set the contents of all files to library cache
 * @param files a map filename -> contents
 * @return boolean true on success
 */
global boolean SetFilesContents (map<string,string> files) {
    y2milestone ("Storing contents of files");
    boolean ret = System::Bootloader_API::setFilesFromStrings (files);
    if (! ret)
	y2error ("Settingg file contents failed");
    return ret;
}

} //end of include
