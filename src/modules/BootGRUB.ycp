/**
 * File:
 *      modules/BootGRUB.ycp
 *
 * Module:
 *      Bootloader installation and configuration
 *
 * Summary:
 *      Module containing specific functions for GRUB configuration
 *      and installation
 *
 * Authors:
 *      Jiri Srain <jsrain@suse.cz>
 *
 * $Id$
 *
 */

{
    module "BootGRUB";

    textdomain "bootloader";

    import "Kernel";
    import "Storage";

    import "BootCommon";

    include "bootloader/grub/misc.ycp";
    include "bootloader/grub/widgets.ycp";

    include "bootloader/routines/popups.ycp";

// private variables

    /**
      * map from grub device names to linux device names
      */
    global list device_map = [];
    /**
      * parsed contents of /etc/grub.conf file
      */
    global map grub_conf = $[];
    /**
      * was grub_conf changed by user manually?
      */
    global boolean gc_changed = false;
    /**
      * List of partitions deleted in primary proposal
      */
    list(string) del_parts = [];
    /**
      * Shall proposal merge menus?
      */
    global boolean deep_propose = false;

// variables for temporary data

    /**
      * Disks order for ordering widget purproses
      */
    global list(string) disks_order = nil;

// general functions

    /**
      * Return map of provided functions
      * @return map map of functions (eg. $["write":``(BootGRUB::Write ())])
      */
    global define map GetFunctions () ``{
	return $[
            "export"   : ``(BootGRUB::Export ()),
            "import"   : ``(BootGRUB::Import ()),
            "read"     : ``(BootGRUB::Read ()),
            "reset"    : ``(BootGRUB::Reset ()),
            "propose"  : ``(BootGRUB::Propose ()),
            "save"     : ``(BootGRUB::Save ()),
            "update"   : ``(BootGRUB::Update ()),
            "write"    : ``(BootGRUB::Write ()),
	    "sequence" : ``(BootGRUB::FixSequence ()),
	    "widgets"  : ``(BootGRUB::GetWidgets ()),
            "getfiles" : ``(BootGRUB::GetFiles ()),
            "setfiles" : ``(BootGRUB::SetFiles ()),
	    "getoptions":``(BootGRUB::GetOptions ()),
	    "updoptlst": ``(BootGRUB::UpdateOptionsList ()),
	];
    }

    /**
      * Export bootloader settings to a map
      * @return bootloader settings
      */
    global define map Export () ``{
	map ret = BootCommon::Export ();
	ret["device_map"] = device_map;
	ret["grub_conf"] = grub_conf;
	return ret;
    }
    /**
      * Import settings from a map
      * @param settings map of bootloader settings
      */
    global define void Import (map settings) ``{
	BootCommon::Import (settings);
	device_map = settings["device_map"]:proposeDeviceMap ();
	grub_conf = settings["grub_conf"]:proposeGrubConf ();
    }
    /**
      * Read settings from disk
      * @return boolean true on success
      */
    global define boolean Read () ``{
	BootCommon::DetectDisks ();
	grub_conf = readGrubConf ();
	device_map = readDeviceMap ();
	string mbrD = grubDev2unixDev ("(hd0)");
	if (mbrD != "/dev/null" && mbrD != nil && mbrD != "")
	    BootCommon::mbrDisk = mbrD;
	boolean ret = BootCommon::Read ();
	BootCommon::loader_device = grubDev2unixDev (grub_conf["device"]:"");
	return ret;
    }

    /**
      * Reset bootloader settings
      */
    global define void Reset () ``{
	device_map = [];
	BootCommon::Reset ();
	device_map = proposeDeviceMap ();
	grub_conf = proposeGrubConf ();
    }
    /**
      * Propose bootloader settings
      */
    global define void Propose () ``{
        if (! BootCommon::was_proposed)
	{
            BootCommon::DetectDisks ();
	    // refresh device map
	    if (device_map == [])
		device_map = proposeDeviceMap ();
	    if (grub_conf == $[])
		grub_conf = proposeGrubConf ();
	    del_parts = BootCommon::getPartitionList (`deleted);
	    string mbrD = grubDev2unixDev ("(hd0)");
	    if (mbrD != "/dev/null" && mbrD != nil && mbrD != "")
		BootCommon::mbrDisk = mbrD;
	}
	boolean disks_changed = BootCommon::RefreshDisks();
	if (disks_changed)
	{
	    if (askLocationResetPopup (BootCommon::loader_device))
	    {
		BootCommon::location = "";
		BootCommon::DetectDisks ();
	    }
	}

	BootCommon::loader_device = BootCommon::GetBootloaderDevice ();

	if (size (BootCommon::sections) == 0)
	{
	    createSections ();
	    BootCommon::kernelCmdLine = Kernel::cmdLine;
	}
	else
	{
	    fixSections (disks_changed);
	}
	if (size (BootCommon::globals) == 0)
	{
	    createGlobals ();
	}
	else
	{
	    fixGlobals (disks_changed);
	}

	y2milestone ("Proposed sections: %1", BootCommon::sections);
	y2milestone ("Proposed globals: %1", BootCommon::globals);
	BootCommon::saveCfgFileToAgent ();
    }

    /**
      * Save all bootloader configuration files
      * @return boolean true if success
      */
    global define boolean Save () ``{
	SCR::Execute (.target.bash, "test -f /boot/grub/menu.lst && /bin/cp /boot/grub/menu.lst /boot/grub/menu.lst.old");
	SCR::Execute (.target.bash, "test -f /boot/grub/device.map && /bin/cp /boot/grub/device.map /boot/grub/device.map.old");
	SCR::Execute (.target.bash, "test -f /etc/grub.conf && /bin/cp /etc/grub.conf /etc/grub.conf.old");
	grub_conf["device"] = unixDev2grubDev (BootCommon::loader_device);
	saveGrubConf (grub_conf);
	saveDeviceMap (device_map);
	BootCommon::sections = filter (`s, BootCommon::sections, ``{
	    if (s["__intern__", "converted"]:false)
	    {
		return true;
	    }
            if (s["title"]:"" == "")
	    {
		y2milestone ("Removing section with empty title");
                return false;
	    }
            if (! contains (["linux", "failsafe", "memtest86"], s["title"]:""))
	    {
                return true;
	    }

	    string kernel = s["kernel"]:"";
	    if (kernel == "")
		return true;
	    kernel = select (
		filter (`k, splitstring (kernel, " "), ``(k != "")), 0, "");
	    if (kernel == "")
		return true;
	    kernel = grub2file (kernel);
	    if (SCR::Read (.target.size, kernel) == -1)
	    {
		y2milestone ("Removing section %1 with unexistent kernel",
		    s["title"]:"");
		return false;
	    }
	    return true;
	});
	BootCommon::sections = maplist (`s, BootCommon::sections, ``{
	    string title = s["title"]:"";
	    if (s["__intern__", "converted"]:false)
		return s;
            if (s["title"]:"" == "linux")
                s["kernel"] = BootCommon::updateKernelParams (s["kernel"]:"");
	    string initrd = s["initrd"]:"";
	    if (initrd != "")
	    {
		initrd = grub2file (initrd);
		if (-1 == SCR::Read (.target.size, initrd))
		    s = remove (s, "initrd");
	    }
	    else if ((title == "linux" || title == "failsafe")
		&& BootCommon::write_settings["insert_initrd"]:false)
	    {
		if (title == "linux")
		    s["initrd"] = file2grub ("/boot/initrd");
		else
		    s["initrd"] = file2grub ("/boot/initrd.shipped");
	    }
	    return s;
	});
	string gfxmenu = BootCommon::globals["gfxmenu"]:"";
	if (gfxmenu != "")
	{
	    gfxmenu = grub2file (gfxmenu);
	    if (-1 == SCR::Read (.target.size, gfxmenu))
		BootCommon::globals = remove (BootCommon::globals, "gfxmenu");
	}
	boolean ret = BootCommon::Save ();
	SCR::Execute (.target.bash, "/bin/chmod 600 /boot/grub/menu.lst");
	return ret;
    }
    /**
      * Update read settings to new version of configuration files
      */
    global define void Update () ``{
	updateSections (true);
	updateGlobals ();
    }
    /**
      * Write bootloader settings to disk
      * @return boolean true on success
      */
    global define boolean Write () ``{
	boolean ret = true;
	BootCommon::updateMBR ();
	if (BootCommon::location_changed)
	{
	    if (! (BootCommon::location == "floppy" && saveToFLoppyPopup ()))
		ret = false;
// save if mkfs or fdformat failed too
//	    if (ret)
		SCR::Execute (.target.bash, "test -f /var/log/YaST2/y2loggrub && /bin/rm /var/log/YaST2/y2loggrub");
		ret = 0 == SCR::Execute (.target.bash, "cat /etc/grub.conf \
| /usr/sbin/grub --batch --device-map=/boot/grub/device.map >> \
/var/log/YaST2/y2loggrub 2>&1"
	    );
	    if (ret)
	    {
		ret = 0 != SCR::Execute (.target.bash,
		    "/usr/bin/grep \"Error [0-9]*: \" /var/log/YaST2/y2loggrub");
	    }
	    if (! ret)
	    {
		string log = SCR::Read (.target.string,
		    "/var/log/YaST2/y2loggrub");
		// error popup - label
                errorWithLogPopup (_("Error occurred while installing GRUB"),
                    log);
	    }
	}
	return ret;
    }

    /**
      * Get map of bootloader options
      * @return map of options
      */
    global define map GetOptions () ``{
	return $[
	    `global: [
                "default",
                "fallback",
                "hiddenmenu",
                "timeout",
                "title",
		"gfxmenu",
		"timeout",
                "bootp",
                "color",
                "device",
                "dhcp",
                "hide",
                "ifconfig",
                "pager",
                "partnew",
                "parttype",
                "password",
                "rarp",
                "serial",
                "setkey",
                "terminal",
                "tftpserver",
                "unhide",


	    ],
	    "image" : [
                "bootp",
                "color",
                "device",
                "dhcp",
                "hide",
                "ifconfig",
                "pager",
                "partnew",
                "parttype",
                "password",
                "rarp",
                "serial",
                "setkey",
                "terminal",
                "tftpserver",
                "unhide",

                "blocklist",
                "boot",
                "cat",
                "cmp",
                "configfile",
                "debug",
                "displayapm",
                "displaymem",
                "embed",
                "find",
                "fstest",
                "geometry",
                "halt",
                "help",
                "impsprobe",
                "initrd",
                "install",
                "ioprobe",
                "kernel",
                "lock",
                "makeactive",
                "map",
                "md5crypt",
                "module",
                "modulenounzip",
                "pause",
                "quit",
                "reboot",
                "read",
                "root",
                "rootnoverify",
                "savedefault",
                "setup",
                "testload",
                "testvbe",
                "uppermem",
                "vbeprobe",

	    ],
	    "other" : [
                "bootp",
                "color",
                "device",
                "dhcp",
                "hide",
                "ifconfig",
                "pager",
                "partnew",
                "parttype",
                "password",
                "rarp",
                "serial",
                "setkey",
                "terminal",
                "tftpserver",
                "unhide",

                "blocklist",
                "boot",
                "cat",
                "chainloader",
                "cmp",
                "configfile",
                "debug",
                "displayapm",
                "displaymem",
                "embed",
                "find",
                "fstest",
                "geometry",
                "halt",
                "help",
                "impsprobe",
                "install",
                "ioprobe",
                "lock",
                "makeactive",
                "map",
                "md5crypt",
                "module",
                "modulenounzip",
                "pause",
                "quit",
                "reboot",
                "read",
                "root",
                "rootnoverify",
                "savedefault",
                "setup",
                "testload",
                "testvbe",
                "uppermem",
                "vbeprobe",
	    ],
	];
    }

// end of mandatory functions
//----------------------------------------------------------------------------

    /**
      * Create linux section
      * @param title strign section title (linux, failsafe, memtest)
      * @return section description structure
      */
    global define map createLinuxSection (string title) ``{
	if (title == "memtest86")
	{
	  if ((Mode::normal && Pkg::IsProvided ("gfxboot"))
		|| ((! Mode::normal) && Pkg::IsSelected ("gfxboot")))
	    return $[
		"__order__":["title", "kernel"],
		"kernel" : file2grub ("/boot/memtest.bin"),
		"title" : "memtest86",
		"__intern__" : $[
		    "auto" : true,
		    "changed" : false,
		    "devs" : [BootCommon::BootPartitionDevice],
		    "kernel" : "/boot/memtest.bin",
		],
	    ];
	  else
		return $[];
	}
	string vgastring = Kernel::vgaType != ""
	    ? sformat ("vga=%1", Kernel::vgaType)
	    : "";
	string initrd = title == "failsafe" ? "initrd.shipped" : "initrd";
	string image = title == "failsafe" ? "vmlinuz.shipped" : "vmlinuz";
	string append = title == "failsafe"
	    ? "ide=nodma apm=off acpi=off vga=normal "
	      + ((Arch::x86_64) ? "iommu=noforce " : "nosmp noapic ")
	      + "maxcpus=0 3"
	    : sformat ("%1 %2", vgastring, Kernel::cmdLine);
	return $[
	    "__order__":["title", "kernel", "initrd"],
	    "title" : title,
	    "kernel" : sformat ("%1 %2 %3",
		file2grub ("/boot/" + image),
		sformat ("root=%1", BootCommon::RootPartitionDevice),
		append
	    ),
	    "initrd" : file2grub ("/boot/" + initrd),
	    "__intern__" : $[
		"changed" : false,
		"auto" : true,
		"devs" : [
		    BootCommon::BootPartitionDevice,
		    BootCommon::RootPartitionDevice
		],
		"kernel" : "/boot/" + image,
		"initrd" : "/boot/" + initrd,
	    ]
	];
    }

    /**
      * Propose sections to bootloader menu
      * modifies internal sreuctures
      */
    global define void createSections () ``{
	list out = [
	    createLinuxSection ("linux")
	];
	list(string) others_ignore = [];
	list others = Storage::GetForeignPrimary();
	y2milestone ("Other primaries: %1", others);
	list other_l = Storage::GetOtherLinuxPartitions();
	y2milestone ("Other linux parts: %1", other_l);

	string tmpdir = SCR::Read (.target.tmpdir) + "/bldetect/";

	if (deep_propose && other_l != nil && size (other_l) > 0
	    && 0 == SCR::Execute (.target.bash, sformat (
		"test -d %1 || /bin/mkdir %1", tmpdir))
	    )
	{
	    y2milestone ("Detectig other Linux parts");
	    list filesystems = maplist (`p, other_l, ``(p["used_fs"]:""));
	    filesystems = toset (filter (`f, filesystems, ``(f != "")));
	    filesystems = filter (`f, filesystems, ``(f != `ext2));
	    y2milestone ("Have to modprobe %1", filesystems);
	    foreach (`f, filesystems, ``{
		map fsmods = $[
		    `ext2 : "",
		    `ext3 : "ext3",
		    `reiser : "reiserfs",
		    `xfs : "xfs",
		    `jfs : "jfs"
		];
		string modname = fsmods[f]:"";
		y2milestone ("Module name is %1", modname);
		if (modname != "")
		{
		    integer r = SCR::Execute (.target.bash,
			sformat ("/sbin/modprobe %1", modname));
		    y2milestone ("result of loading %1 is %2", modname, r);
		}
	    });
	    foreach (`o, other_l, ``{
		string dev = o["device"]:"";
		if (dev != "" && 0 == SCR::Execute (.target.bash,
		    sformat ("/bin/mount %1 %2", dev, tmpdir)))
		{
		    y2milestone ("Mounted %1", dev);
		    list(string) filenames = [];
		    foreach (string fn, [
			tmpdir + "grub/menu.lst",
			tmpdir + "boot/grub/menu.lst"
		    ], ``{
			if (-1 != SCR::Read (.target.size, fn))
			    filenames = add (filenames, fn);
		    });
		    y2milestone ("Found files %1", filenames);
		    integer count = 0;
		    foreach (`f, filenames, ``{
			y2milestone ("Checking file %1", f);
			string fc = SCR::Read (.target.string, f);
			SCR::Write (.grub.fromstring, fc);
			list sects = SCR::Dir (.grub.sections);
			y2milestone ("Found sections %1", sects);
			count = count + size (sects);
			foreach (`s, sects, ``{
			    map opts_tmp = BootCommon::sectOptions2Map (
				"grub", "sections", s);
			    opts_tmp["title"] = sformat ("%1_%2",
				dev, opts_tmp["title"]:"");
			    opts_tmp["__intern__"] = $[
				"changed" : false,
				"auto" : true,
				"converted" : true,
			    ];
			    list devs = [];
			    devs = add (devs, grubDev2unixDev (select (
				splitDevPath (
				    opts_tmp["initrd"]:""), 0, "")));
			    devs = add (devs, grubDev2unixDev (select (
				splitDevPath (
				    opts_tmp["kernel"]:""), 0, "")));
			    devs = add (devs, grubDev2unixDev (
				opts_tmp["root"]:""));
			    devs = add (devs,
				BootCommon::getKernelParamFromLine (
				    opts_tmp["kernel"]:"", "root"));
			    devs = filter (`d, devs, ``(d != ""
				&& d != nil
				&& d != "/dev/null" && d != "false"));
			    devs = toset (devs);
			    opts_tmp["__intern__", "devs"] = devs;
			    y2milestone ("Converted sec: %1", opts_tmp);
			    out = add (out, opts_tmp);
			});
		    });
		    if (count > 0)
		    {
			others_ignore = add (others_ignore, dev);
		    }
		    SCR::Execute (.target.bash, sformat (
			"/bin/umount %1", dev));
		}
	    });
	    SCR::Execute (.target.bash, sformat ("/bin/rmdir %1", tmpdir));
	}

	if (others != nil)
	{
	    if (size (others) > 0)
	    {
		foreach (`o, others, ``{
		    list parts = splitstring (o, " ");
		    while (select (parts, 0, " ") == "")
			parts = remove (parts, 0);
		    string dev = select (parts, 0, "");
		    y2milestone ("Checking other partition %1", dev);
		    if (! contains (others_ignore, dev))
		    {
			string g_dev = unixDev2grubDev (dev);
			parts = remove (parts, 0);
			string label = mergestring (parts, " ");

                        // don't add rewritten location (#19990)
			if (g_dev != "" && label != ""
			    && dev != BootCommon::loader_device)
			{
			    map m = $[
				"__order__":["title", "root", "makeactive",
					"chainloader +1"],
				"title" : label,
				"root" : g_dev,
				"makeactive" : "",
				"chainloader" : "+1",
				"__intern__" : $[
				    "changed" : false,
				    "auto" : true,
				    "devs" : [dev],
				],
			    ];
			   out = add (out, m);
			}
		    }
		});
	    }
	}
	out = add (out, $[
	    "__order__" : ["title", "root", "chainloader"],
	    "title" : "floppy",
	    "root" : "(fd0)",
	    "chainloader" : "+1",
	]);
	out = add (out, createLinuxSection ("failsafe"));
	out = add (out, createLinuxSection ("memtest86"));
	out = filter (`s, out, ``(s != $[] && s != nil));
	BootCommon::sections = out;
    }

    /**
      * Propose global options of bootloader
      * modifies internal structures
      */
    global define void createGlobals () ``{
	map bcg = $[];
	bcg["color"] = "white/blue black/light-gray";
	bcg["default"] = 0;
	bcg["timeout"] = 8;
	bcg["gfxmenu"] = file2grub ("/boot/message");
	bcg["__intern__"] = $[
	    "changed" : false,
	    "auto" : true,
	    "disks" : [BootCommon::BootPartitionDevice],
        ];
	BootCommon::globals = bcg;
    }

    /**
      * Update sections of bootloader menu
      * modifies internal sreuctures
      * @param replace boolean true if old sectinos shall be replaced
      */
    global define void updateSections (boolean replace) ``{
	list out = BootCommon::sections;

	foreach (`t, ["linux", "failsafe", "memtest86"], ``{
	    map m = createLinuxSection (t);
	    boolean changed = false;
	    list out = maplist (`s, out, ``{
		if (s["title"]:"" == m["title"]:"")
		{
		    changed = true;
		    if (replace)
			return m;
		    else
			return s;
		}
		else
		{
		    return s;
		}
	    });
	    if (! changed)
		if (t == "normal")
		    out = prepend (out, m);
		else
		    out = add (out, m);
	});
	BootCommon::sections = out;
    }

    /**
      * Update global options of bootloader
      * modifies internal sreuctures
      */
    global define void updateGlobals () ``{
        map bcg = BootCommon::globals;
        bcg["color"] = "white/blue black/light-gray";
        bcg["timeout"] = 8;
	bcg["gfxmenu"] = file2grub ("/boot/message");
        BootCommon::globals = bcg;
    }

    /**
      * Fix sections of bootloader menu during proposal regeneration
      * modifies internal sreuctures
      * @param disks_changed boolean should be true if bootloader location
      *   relevant disk locations have changed
      */
    global define void fixSections (boolean disks_changed) ``{
	list parts = BootCommon::getPartitionList(`parts_old);
	if (BootCommon::partitioning_last_change
		!= Storage::GetTargetChangeTime()
	    && BootCommon::files_edited)
	{
	    displayFilesEditedPopup ();
	    BootCommon::files_edited = false;
	    return;
	}
	list(map) old_sect_list = BootCommon::sections;
	createSections ();
	map new_sect = listmap (`s, BootCommon::sections, ``{
	    return [s["title"]:"", s];
	});
	old_sect_list = maplist (`s, old_sect_list, ``{
	    string title = s["title"]:"";
	    if (! s["__intern__", "auto"]:false)
	    {
		y2milestone ("Leaving section %1", title);
		return s;
	    }
	    else if (! s["__intern__", "changed"]:false)
	    {
		y2milestone ("Recreating section %1", title);
		return new_sect[title]:$[];
	    }
	    else
	    {
		y2milestone ("Possible warning on section %1", title);
		boolean cont = true;
		if (s["title"]:"" != "linux" && s["title"]:"" != "failsafe"
		    && s["title"]:"" != "memtest86" && s["title"]:"" !="gloppy")
		{
		    foreach (`n, s["__intern__", "devs"]:[], ``{
		        if (! contains (parts, n))
		        {
			    cont = false;
		        }
		    });
		}
		list new_devs = toset(new_sect[title, "__intern__", "devs"]:[]);
		list old_devs = toset(s["__intern__", "devs"]:[]);
		if (size (new_devs) != size (old_devs))
		{
		    cont = false;
		}
		else
		{
		    foreach (`d, old_devs, ``{
			if (! contains (new_devs, d))
			    cont = false;
		    });
		}
		if (! cont)
		{
		    s["__intern__", "auto"] = false;
		    y2milestone ("Warning, ND: %1, OD: %2, P: %3",
			new_devs, old_devs, parts);
		    displayDiskChangePopup (s["title"]:"");
		}
		return s;
	    }
	});
	boolean has_memtest = false;
	foreach (`s, old_sect_list, ``{
	    if (s["title"]:"" == "memtest86")
		has_memtest = true;
	});
	if (new_sect["memtest86"]:$[] != $[] && ! has_memtest)
	    old_sect_list = add (old_sect_list, new_sect["memtest86"]:$[]);
	y2milestone ("Checking for sections needing some of %1dd", del_parts);
	list(string) to_remove = [];
	foreach (`s, BootCommon::sections, ``{
	    list(string) devs = s["__intern__", "devs"]:[];
	    y2milestone ("Section %1 needs %2", s["title"]:"", devs);
	    boolean to_add = false;
	    foreach (string d, devs, ``{
		if (contains (del_parts, d))
		{
		    to_add = true;
		}
	    });
	    if (to_add)
	    {
		map old_sect = listmap (`s, old_sect_list, ``{
		    return [s["title"]:"", s];
		});

		string title = s["title"]:"";
		if (title != "" && ! haskey(old_sect, title))
		{
		    y2milestone ("Adding %1", s);
		    to_remove = add (to_remove, d);
		    old_sect_list = add (old_sect_list, s);
		}
	    }
	});
	del_parts = BootCommon::difflist (del_parts, to_remove);
	old_sect_list = filter (`s, old_sect_list, ``(s != $[]));
	BootCommon::sections = old_sect_list;
    }

    /**
      * Fix global options of bootloader during proposal regeneration
      * modifies internal sreuctures
      * @param disks_changed boolean should be true if bootloader location
      *   relevant disk locations have changed
      */
    global define void fixGlobals (boolean disks_changed) ``{
	if (size (BootCommon::sections) <= BootCommon::globals["default"]:0)
	    BootCommon::globals["default"] = 0;
	if (BootCommon::globals["gfxmenu"]:"" == "")
	    BootCommon::globals["__intern__", "auto"] = false;
	y2milestone ("Have GFXMenu");
	if (BootCommon::globals["gfxmenu"]:"" != "")
	{
	    if (! BootCommon::globals["__intern__", "changed"]:false)
		BootCommon::globals["gfxmenu"] = file2grub ("/boot/message");
	    else if (BootCommon::globals["__intern__", "auto"]:false)
	    { // automatic, but changed
//	y2error ("Checking %1", BootCommon::globals);
		if (BootCommon::BootPartitionDevice
		    != BootCommon::globals["__intern__", "disks", 0]:""
		    && ! BootCommon::globals["__intern__", "warned"]:false)
		{
		    BootCommon::globals["__intern__", "warned"] = true;
		    displayGfxMenuChangePopup ();
		}
	    }
	}
    }

    /**
      * Create strings representing cfg. files for by-hand editation
      * @return map filename -> contents
      */
    global define map GetFiles() ``{
	BootCommon::saveCfgFileToAgent ();
	grub_conf["device"] = unixDev2grubDev (BootCommon::loader_device);
        return $[
	    "default" : "/boot/grub/menu.lst",
            "/boot/grub/menu.lst" : SCR::Read (.grub.tostring),
	    "/boot/grub/device.map" : devMap2string (device_map),
	    "/etc/grub.conf" : getGrubConf (grub_conf),
        ];
    }

    /**
      * Store strings representing cfg. files to internal structures
      * @param files map filename -> contents
      */
    global define void SetFiles (map files) ``{
	if ((devMap2string (device_map) != files["/boot/grub/device.map"]:"")
	    || (SCR::Read (.grub.tostring) != files["/boot/grub/menu.lst"]:""))
	{
	    BootCommon::files_edited = true;
	}
	device_map = string2devMap (files["/boot/grub/device.map"]:"");
	SCR::Write (.grub.fromstring, files["/boot/grub/menu.lst"]:"");
	if (getGrubConf (grub_conf) != files["/etc/grub.conf"]:"")
	{
	    BootCommon::files_edited = true;
	    BootCommon::location = "custom";
	}
	grub_conf = parseGrubConf (files["/etc/grub.conf"]:"");
	BootCommon::loader_device = grubDev2unixDev (grub_conf["device"]:"");
	BootCommon::loadCfgFileFromAgent ();
    }

    /**
      * Update bootlaoder configuration sequence
      * @param ws_data map of wizard sequencer data
      * @return map modified map of wizard sequencer data
      */
    global define map FixSequence (map ws_data) ``{
	map aliases = $[
	    "order" : ``(BootGRUB::runOrderDialog ())
	];
	map gs = ws_data["glob_seq"]:$[];
	map ts = gs["target"]:$[];
	gs["order"] = $[ `next : "target", `abort: `abort];
	ts = add (ts, `order, "order");
	gs["target"] = ts;
	ws_data["aliases"] = aliases;
	ws_data["glob_seq"] = gs;
	return ws_data;
    }

}
