
/**
 * File:
 *      modules/BootELILO.ycp
 *
 * Module:
 *      Bootloader installation and configuration
 *
 * Summary:
 *      Module containing specific functions for ELILO configuration
 *      and installation
 *
 * Authors:
 *      Joachim Plack <jplack@suse.de>
 *      Jiri Srain <jsrain@suse.cz>
 *      Andreas Schwab <schwab@suse.de>
 *
 * $Id$
 *
 */

{

// FIXME paths will be probably changed because of bugzilla 21644

module "BootELILO";

textdomain "bootloader";

import "BootArch";
import "BootCommon";
import "Installation";
import "Kernel";
import "Mode";
import "Report";
import "Stage";
import "Storage";
import "String";

include "bootloader/elilo/helps.ycp";
include "bootloader/routines/popups.ycp";
include "bootloader/generic/dialogs.ycp";


// private variables

/**
  * Name of EFI entry when read settings
  */
global string old_efi_entry = nil;

/**
  * Should be original EFI entry removed?
  */
global boolean remove_old_efi = true;

/**
  * elilo.conf path
  */
global string elilo_conf_filename = "/boot/efi/SuSE/elilo.conf";

/**
  * True if EFI entry should be recreated
  */
global boolean create_efi_entry = true;

/**
  * True if the EFI layout was changed
  */
global boolean efi_layout_changed = false;

/**
 * The name of the entry in the EFI menu
 */
global string efi_entry_name = "";

string efi_vendor = "SuSE";

// misc. functions

/**
  * Return mountpoint of partition holding EFI data
  * @return mountpoint if partition holding EFI data
  */
global define string getEfiMountPoint () {
    string mountpoint = "/";
    // FIXME: UGLY HACK because of testsuites
    map mountpoints = $[];
    if (Mode::test ())
        mountpoints = $["/" : ["/dev/hda2"], "/boot" : ["/dev/hda1"]];
    else
        mountpoints = Storage::GetMountPoints();
    if (haskey (mountpoints, "/boot/efi"))
    {
        mountpoint = "/boot/efi";
    }
    else if (haskey (mountpoints, "/boot"))
    {
        mountpoint = "/boot";
    }
    y2milestone ("Mountpoint of EFI: %1", mountpoint);
    return mountpoint;
}


/**
  * Get directory containing elilo.conf relative to EFI partition's root
  * @return directory containing elilo.conf relative to EFI root
  */
global define string getEliloConfSubdir () {
    return sformat ("/efi/%1", efi_vendor);
}


/**
  * Get path of elilo.conf relative to EFI partition's root
  * @return string path of elilo.conf relative to EFI partition's root
  */
global define string getEliloConfSubpath () {
    return sformat ("%1/elilo.conf", getEliloConfSubdir ());
}


/**
  * Return path to elilo.conf file
  * @return string path to elilo.conf
  */
global define string getEliloConfFilename () {
    // FIXME config file name location should be read from Library
    //  and it should not be needed here!!!
    string ret = sformat ("%1/efi/%2/elilo.conf", getEfiMountPoint (),
        efi_vendor);
    y2milestone ("elilo.conf sould be located at %1", ret);
    return ret;
}

// wrapper function to adjust to new grub name sceme
map<string,any> CreateLinuxSection (string title) {
    map<string,any> section =
      BootCommon::CreateLinuxSection (title);

    // replace "kernel" by "image"
    if (haskey(section, "kernel")) {
      section["image"] = section["kernel"]:"";
      section = remove(section, "kernel");
    }
 
    return section;
}



/**
 * Propose sections to bootloader menu
 * modifies internal sreuctures
 */
global void CreateSections () {
    map<string,any> linux = CreateLinuxSection ("linux");
    map<string,any> failsafe = CreateLinuxSection ("failsafe");

    // append for default section is in global
    // FIXME do it later
    //    if (haskey (linux, "append"))
    //  	linux = remove (linux, "append");

    BootCommon::sections = [ linux, failsafe ];
}


/**
 * Propose global options of bootloader
 * modifies internal structures
 */
global void CreateGlobals () {
    BootCommon::globals = $[
    // FIXME do it later
    //	"append" : BootArch::DefaultKernelParams (""),
	"default" : BootCommon::translateSectionTitle ("linux"),
	"timeout" : "80",
	"prompt" : "true",
	"read-only" : "true",
	"relocatable" : "true"
    ];
}


// general functions


/**
  * Export bootloader settings to a map
  * @return bootloader settings
  */
global define map Export () {
    map ret = BootCommon::Export ();
    ret["old_efi_entry"] = old_efi_entry;
    ret["remove_old_efi"] = remove_old_efi;
    ret["elilo_conf_filename"] = elilo_conf_filename;
    ret["create_efi_entry"] = create_efi_entry;
    return ret;
}


/**
  * Import settings from a map
  * @param settings map of bootloader settings
  */
global define boolean Import (map settings) {
    BootCommon::Import (settings);
    old_efi_entry = (string) (settings["old_efi_entry"]:nil);
    remove_old_efi = settings["remove_old_efi"]:true;
    elilo_conf_filename = getEliloConfFilename ();
    create_efi_entry
        = settings["create_efi_entry"]:(settings["location"]:"" != "");
    return true;
}


/**
  * Read settings from disk
  * @return boolean true on success
  */
global define boolean Read (boolean reread) {
	import "Product";
	boolean efi_entry_found = false;
	elilo_conf_filename = getEliloConfFilename ();
	// copy old elilo.conf from /boot/<something> to /etc in case of upgrade
	// (if /etc/elilo.conf doesn't exist)
	if (SCR::Read (.target.size, "/etc/elilo.conf") <= 0
	    && SCR::Read (.target.size, elilo_conf_filename) > 0)
	{
	    SCR::Execute (.target.bash, sformat (
		"/bin/cp %1 /etc/elilo.conf", elilo_conf_filename));
	}
	SCR::Execute (.target.bash, "/bin/touch /etc/elilo.conf");
	BootCommon::DetectDisks ();
	boolean ret = BootCommon::Read (reread);
	efi_entry_name
	    = (string)SCR::Read (.sysconfig.bootloader.LOADER_LOCATION);
	y2milestone ("EFI entry: %1", efi_entry_name);
	// check for meaningless EFI entry name in sysconfig
	if ("mbr" == efi_entry_name || "" == efi_entry_name
	    || nil == efi_entry_name)
	{
	    string efi_path = BootCommon::replaceAll (
		getEliloConfSubpath (), "/", "\\");
	    // Read Firmware setting from NVRam
	    map efi_status = (map)SCR::Execute (.target.bash_output, sformat (
		"/usr/sbin/efibootmgr |grep \"%1\"", efi_path));
	    if (efi_status["exit"]:0 != 0)
	    {
		efi_entry_name = Product::name;
	    }
	    else
	    {
		string output = efi_status["stdout"]:"";
		list lines = splitstring (output, "\n");
		output = lines[0]:"";
		if (regexpmatch (output, "Boot.*\* (.*)  HD"))
		{
		    efi_entry_name
			= regexpsub (output, "Boot.*\* (.*)  HD", "\\1");
		    efi_entry_found = true;
		}
		else
		{
		    efi_entry_name = Product::name;
		}
	    }
	}
	else
	{
	    efi_entry_found = 0 == SCR::Execute (.target.bash, sformat (
            "/usr/sbin/efibootmgr |grep \"%1\"", efi_entry_name));
	}
	create_efi_entry = false;
	old_efi_entry = efi_entry_found ? efi_entry_name : (string)nil;
	return ret;
}


/**
  * Reset bootloader settings
  */
global define void Reset (boolean init) {
    if (Mode::autoinst ())
        return;
    remove_old_efi = true;
    create_efi_entry = true;
    BootCommon::Reset(init);
}


/**
  * Propose bootloader settings
  */
global define void Propose () {
    import "Product";
    if (! BootCommon::was_proposed)
    {
        create_efi_entry = true;
        efi_entry_name = Product::name;
    }
    if (! Stage::initial ())
        create_efi_entry = true;
    if (Mode::update ())
        create_efi_entry = false;
    elilo_conf_filename = getEliloConfFilename ();
    BootCommon::DetectDisks ();
    BootCommon::del_parts = BootCommon::getPartitionList (`deleted);

    if (BootCommon::sections == nil || size (BootCommon::sections) == 0)
    {
        CreateSections ();
        BootCommon::kernelCmdLine = Kernel::GetCmdLine ();
    }
    else
    {
        if (Mode::autoinst ())
        {
    	y2debug ("Nothing to do for propose in AI mode");
        }
        else
    	BootCommon::FixSections (BootELILO::CreateSections);
    }
    if (BootCommon::globals == nil || size (BootCommon::globals) == 0)
    {
        CreateGlobals ();
    }

    if (efi_entry_name == "" || efi_entry_name == nil)
    {
        efi_entry_name = Product::name;
    }
    y2milestone ("EFI entry name: %1", efi_entry_name);
    y2milestone ("Proposed sections: %1", BootCommon::sections);
    y2milestone ("Proposed globals: %1", BootCommon::globals);
}


/**
 * Save all bootloader configuration files
 * @return boolean true if success
 */
global boolean Save (boolean clean, boolean init, boolean flush) {
    BootCommon::globals["efi_entry_name"] = efi_entry_name;
    // FIXME modify EFI? Entries to remove...
    boolean ret = BootCommon::Save (clean, init, flush);
    importMetaData();
    return ret;
}


/**
  * Display bootloader summary
  * @return a list of summary lines
  */
global define list<string> Summary () {
    // summary text, %1 is bootloader name (eg. LILO)
    list<string> result = [ sformat (_("Boot loader type: %1"),
        BootCommon::getLoaderName (BootCommon::getLoaderType (false), `summary)) ];
    if ( efi_entry_name == "" || efi_entry_name == nil || !create_efi_entry )
    {
        result =
    	    // summary text
    	    add (result, _("Do Not Create EFI Boot Manager Entry"));
    }
    else
    {
        result = add (result, sformat (
    	// summary text, %1 is label of the entry of EFI boot manager
    	_("Create EFI Boot Manager Entry %1"),
        efi_entry_name));
    }
    list<string> sects = [];
    foreach (map<string,any> s, BootCommon::sections, {
        string title = s["name"]:"";
            // section name "suffix" for default section
        string def = title == BootCommon::globals["default"]:"" ?
	      _(" (default)") :
	      "";
        sects = add (sects, sformat ("%1%2", title, def));
    });
    // summary text. %1 is list of bootloader sections
    result = add (result, sformat (_("Sections: %1"),
        mergestring (sects, ", ")));
    return result;
}


/**
 * Update read settings to new version of configuration files
 */
global define void Update () {
    /*
     * Update global options of bootloader
     * modifies internal sreuctures
     */
    BootCommon::globals["timeout"] = "8";
    BootCommon::globals["append"] = BootArch::DefaultKernelParams ("");

    BootCommon::UpdateSections (true, CreateLinuxSection);
    // FIXME EFI entry name
}


/**
  * Install the bootloader, display a popup with log if something
  *  goes wrong
  * @param command string command to install the bootloader
  * @param logfile string filename of file used to write bootloader log
  * @return boolean true on success
  */
// FIXME get rid of this function
define boolean installBootLoader (string command, string logfile) {
    y2milestone ("Running command %1", command);
    map exit = (map)SCR::Execute (.target.bash_output, command);
    boolean ret = 0 == exit["exit"]:1;
    if (! ret)
    {
        y2milestone ("Exit code of %1: %2", command, exit["exit"]:-1);
        string log = (string)SCR::Read (.target.string, logfile);
        log = log + exit["stdout"]:"" + exit["stderr"]:"";
        if (exit["exit"]:1 == 139)
        {
            // means: process received signal SIGSEGV
            // please, use some usual translation
            // proofreaders: don't change this text
            log = log + _("Segmentation fault");
        }

        errorWithLogPopup (sformat (
            // error popup - label, %1 is bootloader name
            _("Error Occurred while Installing %1"),
            BootCommon::getLoaderName (BootCommon::getLoaderType (false), `summary)), log);
    }
    return ret;
}


/**
  * Write bootloader settings to disk
  * @return boolean true on success
  */
global define boolean Write () {
    //	SCR::Execute (.target.bash, "/sbin/elilo");
    boolean ret = BootCommon::UpdateBootloader ();

    if (BootCommon::location_changed || create_efi_entry)
    {
        // FIXME should be handled completly through the library
        // remove existing end old menu entry
        list<string> efi_entries_to_remove = toset ([
			efi_entry_name,
			remove_old_efi ? old_efi_entry : ""
        ]);
        efi_entries_to_remove = filter (
			string e,
			efi_entries_to_remove,
			``(	e != nil && e != "")
		);

		map mp = Storage::GetMountPoints();
		string boot_dev = mp[getEfiMountPoint (), 0]:"/boot/efi";
		map splited = Storage::GetDiskPartition (boot_dev);
		any boot_part = splited["nr"]:0;
		any	boot_disk = splited["disk"]:"";
		y2milestone ("Disk: %1, Part: %2", boot_disk, boot_part);

		if (efi_entry_name != "" && efi_entry_name != nil)
		{
			string bl_logfile = "/var/log/YaST2/y2log_bootloader";
		    string bl_command = sformat (
			"/usr/sbin/efibootmgr -v --create --label \"%1\" " +
			"--disk %2 --part %3 " +
			"--loader '\\efi\\SuSE\\elilo.efi' --write-signature >> %4 2>&1",
			efi_entry_name, boot_disk, boot_part, bl_logfile);
			ret = ret && installBootLoader (bl_command, bl_logfile);
		}

		// Detect the current default boot entry (e.g. "0007")
		map default_entry_map = (map)SCR::Execute (.target.bash_output,
			"/usr/sbin/efibootmgr |grep ^BootOrder: | " +
			"cut -d ' ' -f 2 | cut -d ',' -f 1"
		);
		string new_entry = default_entry_map["stdout"]:"";

		// Check for validity -- returned default_entry has to be 4 chars long
		// and be composed of numbers and characters only
		if (size (new_entry) != 4
		&& regexpmatch (new_entry, "[0-9A-F]") == false) {
			y2error ("BootELILO: Found default boot entry %1 isn't valid",
				new_entry);
		}
		else {
			// Remove newlines and carriage returns in string
			new_entry = deletechars (new_entry, "\n\r");

			// Attach prefix "Boot" for proper matching
			new_entry = "Boot" + new_entry;

			// Prepare command for fetching string "HD(...)"
			// from efibootmgr output
			string command = sformat (
				"set -o pipefail; /usr/sbin/efibootmgr -v | " +
				"grep '%1' | sed 's/%1.*\\(HD.*\\)File.*$/\\1/'",
				String::Quote (new_entry)
			);

			map hd_descr_map = (map)SCR::Execute (.target.bash_output, command);
			y2milestone ("BootELILO: hd_descr_map = %1", hd_descr_map);

			// Remove newlines and carriage returns in string
			string hd_descr = deletechars (hd_descr_map["stdout"]:"", "\n\r");

			// Prepare command for fetching boot entry number corresponding
			// to "HD(...)" string from efibootmgr output
			command = sformat (
				"set -o pipefail; /usr/sbin/efibootmgr -v |" +
				"grep '%1' |awk '{print $1}'",
				String::Quote (hd_descr)
			);

			map entries2remove_map = (map)SCR::Execute (.target.bash_output, command);
			y2milestone ("BootELILO: entries2remove_map = %1", entries2remove_map);
			string entries2remove_string = entries2remove_map["stdout"]:"";

			// Convert the string containing the entries to be removed to a list
			list<string> entries2remove_list = splitstring (entries2remove_string, "\n");

			// Check if there are entries to remove, thus if listsize is greater than 0
			integer listsize = size (entries2remove_list);
			if (listsize > 0) {
				// Rermove the last entry of the list (because it's an empty one)
				integer lastentry = listsize - 1;
				remove (entries2remove_list, lastentry);
				y2milestone ("BootELILO: entries2remove_list = %1", entries2remove_list);

				// Filter the bootnumbers from strings for further usage
				entries2remove_list = maplist (string entry2remove, entries2remove_list, {
					if (issubstring (entry2remove, new_entry) == false) {
						entry2remove = substring (entry2remove, 4, 4);
						return entry2remove;
					}
				});

				// Delete obsolete bootentries by bootnumbers
				foreach (string entry2remove, entries2remove_list, {
				    string command = sformat (
						"/usr/sbin/efibootmgr --delete-bootnum --bootnum %1 -q;",
						entry2remove
					);

				    map ret_map = (map)SCR::Execute (.target.bash_output, command);
					y2milestone ("BootELILO: ret_map = %1", ret_map);
				    ret = (ret_map["exit"]:1 == 0);
				});
			}
			else {
				y2milestone ("BootELILO: No obsolete entry to remove");
			}

		}
    }
    return ret;
}


global symbol WizardSequenzer() {
    y2milestone("Call generic WizardSequenzer");
    return `generic_new;
}


global map<string,symbol()> Dialogs () {
    return $[
	"loader"	: genericBootLoaderOptionsDialog,
    ];
}


/**
  * Return map of provided functions
  * @return a map of functions (eg. $["write"::Write])
  */
global map<string, any> GetFunctions () {
    return $[
        "export"	   : Export,
        "import"	   : Import,
        "read"		   : Read,
	"reset"		   : Reset,
        "propose"	   : Propose,
        "save"		   : Save,
        "summary"	   : Summary,
        "update"	   : Update,
        "write"		   : Write,
        "widgets"	   : genericWidgets,
        "wizard_sequencer" : WizardSequenzer,
        "dialogs"	   : Dialogs,
        "section_types"	   : section_types,
    ];
}


/**
 * Initializer of ELILO bootloader
 */
global void Initializer () {
    y2milestone ("Called ELILO initializer");
    BootCommon::current_bootloader_attribs = $[
        "propose" : true,
        "read" : true,
        "scratch" : true,
        "restore_mbr" : true,
        "bootloader_on_disk" : true,
    ];

    BootCommon::help_messages = (map<string,string>)
      union(BootCommon::help_messages,
    	mapmap(string key, string val, elilo_help_messages,
    	    { return $[ "elilo_" + key : val ]; }
    	       )
    	);
    y2debug("Initialized help_messages to %1", BootCommon::help_messages);
    BootCommon::descriptions = (map<string,string>)
      union(BootCommon::descriptions,
    	mapmap(string key, string val, elilo_descriptions,
    	    { return $[ "elilo_" + key : val ]; }
    	       )
    	);
    y2debug("Initialized help_messages to %1", BootCommon::help_messages);

    BootCommon::InitializeLibrary (false, "elilo");
    importMetaData();
}

/**
 * Constructor
 */
global define void BootELILO () {
    BootCommon::bootloader_attribs["elilo"] = $[
	"required_packages" : ["elilo"],
	"loader_name" : "ELILO",
	"initializer" : BootELILO::Initializer,
    ];
}
 
} // EOF

/*
 * Local variables:
 *     mode: ycp
 *     mode: font-lock
 *     mode: auto-fill
 *     indent-level: 4
 *     fill-column: 78
 * End:
 */

