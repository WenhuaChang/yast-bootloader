/**
 * File:
 *      modules/BootLILO.ycp
 *
 * Module:
 *      Bootloader installation and configuration
 *
 * Summary:
 *      Module containing specific functions for LILO configuration
 *      and installation
 *
 * Authors:
 *      Jiri Srain <jsrain@suse.cz>
 *
 * $Id$
 *
 */

{
    module "BootLILO";

    textdomain "bootloader";

    import "Mode";
    import "Kernel";
    import "Storage";

    import "BootCommon";
    import "Arch";
    import "BootLILO";

    include "bootloader/lilo/widgets.ycp";
    include "bootloader/lilo/helps.ycp";
    include "bootloader/routines/popups.ycp";
    include "bootloader/routines/routines.ycp";

// private variables

    /**
      * List of partitions deleted in primary proposal
      */
    list(string) del_parts = [];


// general functions

    /**
      * Constructor
      */
    global define void BootLILO () ``{
	BootCommon::bootloader_attribs["lilo"] = $[
	    "required_packages" : ["lilo"],
	    "loader_name" : "LILO",
	    "initializer" : ``(BootLILO::Initializer()),
	];
    }

    /**
      * Return map of provided functions
      * @return map map of functions (eg. $["write":``(BootLILO::Write ())])
      */
    global define map GetFunctions () ``{
	return $[
	    "read" :	``(BootLILO::Read ()),
	    "propose" : ``(BootLILO::Propose ()),
	    "save" :	``(BootLILO::Save ()),
	    "update" :	``(BootLILO::Update ()),
	    "write" :	``(BootLILO::Write ()),
	    "widgets" :	``(BootLILO::GetWidgetMaps ()),
	    "getfiles" :``(BootLILO::GetFiles ()),
	    "setfiles" :``(BootLILO::SetFiles ()),
	];
    }

    /**
      * Initializer of LILO bootloader
      */
    global define void Initializer () ``{
	y2milestone ("Called LILO initializer");
	BootCommon::current_bootloader_attribs = $[
	    "section_title" : "label",
	    "kernel_key" : "image",
	    "default_key" : "default",
	    "default_type" : `label,
	    "timeout_multiplier" : 10,
	    "alias_keys" : ["alias"],
	    "convert_function" : ``(BootLILO::convertSection ()),
	    "kernel_params" : $[
		"vga" : "vga",
		"root" : "root",
		`other : "append",
	    ],
	    "propose" : true,
	    "read" : true,
	    "scratch" : true,
	    "restore_mbr" : true,
	    "key_only_once" : true,
	    "bootloader_on_disk" : true,
	    "option_list" : BootCommon::GetOptions (),
	];
	BootCommon::cwm_options = union (
	    BootCommon::GetOptionMaps (),
	    BootLILO::GetOptionMaps ());
	BootCommon::cwm_widgets = union (
	    BootCommon::GetWidgetMaps (),
	    BootLILO::GetWidgetMaps ());
    }

    /**
      * Propose bootloader settings
      */
    global define void Propose () ``{
	y2debug ("Started propose: Glob: %1, Sec: %2",
	    BootCommon::globals, BootCommon::sections);
	if (! BootCommon::was_proposed)
	{
            BootCommon::DetectDisks ();
	    del_parts = BootCommon::getPartitionList (`deleted);
	    y2milestone ("Partitions planned to be deleted: %1", del_parts);
	}

	boolean disks_changed = BootCommon::RefreshDisks();
	if (disks_changed && ! Mode::autoinst)
	{
	    if (askLocationResetPopup (BootCommon::loader_device))
	    {
		BootCommon::location = "";
		BootCommon::DetectDisks ();
	    }
	}

	BootCommon::loader_device = BootCommon::GetBootloaderDevice ();

	// set activate flag
	if (! BootCommon::activate_changed)
	{
	    BootCommon::activate
	        = size (Storage::GetBootPartition (BootCommon::mbrDisk)) == 0;
	}

	if (BootCommon::sections == nil || size (BootCommon::sections) == 0)
	{
	    createSections ();
	    BootCommon::kernelCmdLine = Kernel::cmdLine;
	}
	else
	{
            if (Mode::autoinst)
            {
                // TODO whatever will be needed
            }
            else
		fixSections (disks_changed);
	}
	if (BootCommon::globals == nil || size (BootCommon::globals) == 0)
	{
	    createGlobals ();
	}
	else
	{
            if (Mode::autoinst)
            {
                // TODO whatever will be needed
            }
            else
		fixGlobals (disks_changed);
	}

	y2milestone ("Proposed sections: %1", BootCommon::sections);
	y2milestone ("Proposed globals: %1", BootCommon::globals);
	BootCommon::addValueToBootloaderSection (
	    `globals, "boot", BootCommon::loader_device);
	BootCommon::saveCfgFileToAgent ();
    }

    /**
      * Read settings from disk
      * @return boolean true on success
      */
    global define boolean Read () ``{
	BootCommon::DetectDisks ();
	boolean ret = BootCommon::Read ();
	BootCommon::finishReading ();
	return ret;
    }

    /**
      * Save all bootloader configuration files
      * @return boolean true if success
      */
    global define boolean Save () ``{
	SCR::Execute (.target.bash, "test -f /etc/lilo.conf && /bin/cp /etc/lilo.conf /etc/lilo.conf.old");
	SCR::Execute (.target.bash, "/usr/bin/touch /etc/lilo.conf");

	BootCommon::liloRemoveUnexistentSections ();
	BootCommon::liloUpdateIninrdAppend ();
	string message = lookup_value (BootCommon::globals, "message", "");
        if (message != "")
        {
            if (-1 == SCR::Read (.target.size, message))
	    {
                BootCommon::globals = modifySection (
		    BootCommon::globals, "message", nil);
	    }
        }
	BootCommon::globals = modifySection (BootCommon::globals, "boot",
	    BootCommon::loader_device);
	boolean ret = BootCommon::Save ();
	SCR::Execute (.target.bash, "/bin/chmod 600 /etc/lilo.conf");
	return ret;
    }

    /**
      * Update read settings to new version of configuration files
      */
    global define void Update () ``{
	updateSections (true);
	updateGlobals ();
    }
    /**
      * Write bootloader settings to disk
      * @return boolean true on success
      */
    global define boolean Write () ``{
	BootCommon::updateMBR ();
	boolean ret = true;
	if (! (BootCommon::installingToFloppy () && saveToFLoppyPopup ()))
	    ret = false;

	// create backup copy first
	if (BootCommon::createBackupBS ()
	    && BootCommon::getDeviceOfRaid (BootCommon::BootPartitionDevice)
		!= BootCommon::BootPartitionDevice)
	{
	    y2milestone ("Creating backup copy to bootsector");
	    SCR::Execute (.target.bash, sformat ("/sbin/lilo -b %1",
		BootCommon::BootPartitionDevice));
	}

	string bl_command = "/sbin/lilo >> /var/log/YaST2/y2loglilo 2>&1";
	string bl_logfile = "/var/log/YaST2/y2loglilo";
	boolean command_ret
	    = BootCommon::installBootLoader (bl_command, bl_logfile);
	ret = ret && command_ret;

	if (command_ret && BootCommon::installingToFloppy ())
        {
            BootCommon::updateTimeoutPopupForFloppy
		(BootCommon::getLoaderName ("lilo"));
        }

	return ret;
    }

// end of mandatory functions
//----------------------------------------------------------------------------

    /**
      * Create linux section
      * @param title strign section title (linux, failsafe, memtest)
      * @return section description structure
      */
    global define list createLinuxSection (string title) ``{
	if (title == "memtest86")
	{
          if ((Mode::normal && Pkg::IsProvided ("memtest86"))
                || ((! Mode::normal)))// && Pkg::IsSelected ("memtest86")))
	  {
	    return [
		$[ "key" : "image", "value" : "/boot/memtest.bin"],
		$[ "key" : "label", "value" : translateSectionTitle (title)],
		$[ "key" : "__intern__", "value" : $[
		    "auto" : true,
		    "changed" : false,
		    "devs" : [],
		    "type" : "memtest86",
		]],
	    ];
	  }
	  else
	    return $[];
	}
	// not using .shipped images any more
	string initrd = /*title == "failsafe" ? "initrd.shipped" :*/ "initrd";
	string image = /*title == "failsafe" ? "vmlinuz.shipped" :*/ "vmlinuz";
	string append = title == "failsafe"
	    ? "ide=nodma apm=off acpi=off vga=normal "
	      + ((Arch::x86_64)
		? "iommu=noforce maxcpus=0 "
		: "nosmp noapic maxcpus=0 ")
	      + "3"
	    : Kernel::cmdLine;
	if (title != "failsafe")
	{
	    append = BootCommon::setKernelParamToLine (append, "splash", "silent");
	    append = BootCommon::setKernelParamToLine (append, "desktop", "true");
	}
	string root = BootCommon::dev2majminIfNonStandard (
            BootCommon::RootPartitionDevice);
	if (regexpmatch (root, "^[0-9a-f]{4}$"))
	{
	    root = "0x" + root;
	}
	list ret = [
	    $[ "key" : "label", "value" : translateSectionTitle (title)],
	    $[ "key" : "image", "value" : "/boot/" + image],
	    $[ "key" : "initrd", "value" : "/boot/" + initrd],
	    $[ "key" : "root", "value" : root ],
	    $[ "key" : "append", "value" : append],
	    $[ "key" : "__intern__", "value" : $[
		"auto" : true,
		"changed" : false,
		"devs" : [BootCommon::RootPartitionDevice],
		"type" : title,
	    ]],
	];
	if (Kernel::vgaType != "" && title != "failsafe")
	    ret = add (ret, $["key" : "vga", "value" : Kernel::vgaType]);
	return ret;
    }

    /**
      * Propose sections to bootloader menu
      * modifies internal sreuctures
      */
    global define void createSections () ``{
	list out = [
	    createLinuxSection ("linux")
	];
	list others = Storage::GetForeignPrimary();
	if (others != nil)
	{
	    if (size (others) > 0)
	    {
		foreach (`o, others, ``{
		    list parts = splitstring (o, " ");
		    while (select (parts, 0, " ") == "")
			parts = remove (parts, 0);
		    string dev = select (parts, 0, "");
		    parts = remove (parts, 0);
		    string label = mergestring (parts, " ");

                    // don't add rewritten location (#19990)
		    if (dev != "" && label != ""
			&& dev != BootCommon::loader_device)
		    {
			list m = [
			    $["key" : "label",
				"value" : translateSectionTitle (
				BootCommon::removeBlanks (label))],
			    $[ "key" : "other", "value" : dev],
			    $[ "key" : "__intern__", "value" : $[
				"auto" : true,
				"changed" : false,
				"devs" : [dev],
				"type" : label,
			    ]],
			];
			out = add (out, m);
		    }
		});
	    }
	}
        out = add (out, createLinuxSection ("failsafe"));
	out = add (out, createLinuxSection ("memtest86"));
	out = filter (`s, out, ``(s != $[] && s != nil));
	BootCommon::sections = out;
    }

    /**
      * Propose global options of bootloader
      * modifies internal structures
      */
    global define void createGlobals () ``{
	list internal_bios = SCR::Read (.probe.bios);
	list bcg = [
	    $[ "key" : "menu-scheme", "value" : "Wb:kw:Wb:Wb"],
	    $[ "key" : "default", "value" : translateSectionTitle ("linux")],
	    $[ "key" : "timeout", "value" : 80],
	    $[ "key" : "message", "value" : "/boot/message"],
	    $[ "key" : "lba32",
	       "value" : internal_bios[0, "lba_support"]:false],
	    $[ "key" : "change-rules", "value" : "change-rules,reset"],
	    $[ "key" : "read-only", "value" :  true],
	    $[ "key" : "prompt", "value" : true],
	];
	if (Storage::DiskmapNeeded())
	{
	    string order = "";
	    // check if bios_id is given for a target
	    map targetMap = Storage::GetTargetMap();
	    foreach (`target_dev, `target, targetMap, ``{
		string bios_id = target["bios_id"]:"";
		if (bios_id != "")
		{
		    if (order != "")
			order = order + ",";
		    order = order + sformat ("disk=%1,bios=%2", target_dev,
			bios_id);
		}
	    });
	    if (order != "")
		bcg = add (bcg, $[ "key" : "disk", "value" : order]);
	}
	BootCommon::globals = bcg;
    }

    /**
      * Update sections of bootloader menu
      * modifies internal sreuctures
      * @param replace boolean true if old sectinos shall be replaced
      */
    global define void updateSections (boolean replace) ``{
	list out = BootCommon::sections;

	foreach (`t, ["linux", "failsafe", "memtest86"], ``{
	    list m = createLinuxSection (t);
	    boolean changed = false;
	    list out = maplist (`s, out, ``{
		if (lookup_value (s, "label", "") == t)
		{
		    changed = true;
		    if (replace)
			return m;
		    else
			return s;
		}
		else
		{
		    return s;
		}
	    });
            if (! changed)
                if (t == "normal")
                    out = prepend (out, m);
                else
                    out = add (out, m);
        });
        out = maplist (`s, out, ``{
	    string type = "";
	    foreach (`p, s, ``{
		if (p["key"]:"" == "label" && type == "")
		    type = p["value"]:"";
		if (p["key"]:"" == "__intern__")
		    type = p["value", "type"]:type;
	    });
            s = maplist (`p, s, ``{
		if (p["key"]:"" == "image" || p["key"]:"" == "initrd")
		{
		    string option = p["value"]:"";
		    if (regexpmatch (option, "^.*\.shipped.*$"))
		    {
			option = regexpsub (option,
			    "^(.*)\.shipped(.*)$", "\\1\\2");
		    }
		    else if (regexpmatch (option, "^.*\.suse.*$"))
		    {
			option = regexpsub (option,
			    "^(.*)\.suse(.*)$", "\\1\\2");
		    }
		    if (type == "linux" && p["key"]:"" == "append")
		    {
			// FIXME check the product
			if (! issubstring (option, "desktop"))
			    option = option + " desktop";
			if (! issubstring (option, "splash"))
			    option = option + " splash=silent";
		    }
		    p["value"] = option;
		}
		return p;
            });
	    return s;
        });
        BootCommon::sections = out;
    }

    /**
      * Update global options of bootloader
      * modifies internal sreuctures
      */
    global define void updateGlobals () ``{
	BootCommon::globals = maplist (`e, BootCommon::globals, ``{
	    if (e["key"]:"" == "menu-scheme")
		e["value"] = "Wb:kw:Wb:Wb";
	    else if (e["key"]:"" == "timeout")
		e["value"] = 80;
	    else if (e["key"]:"" == "message")
		e["value"] = "/boot/message";
	    return e;
	});
    }

    /**
      * Fix sections of bootloader menu during proposal regeneration
      * modifies internal sreuctures
      * @param disks_changed boolean should be true if bootloader location
      *   relevant disk locations have changed
      */
    global define void fixSections (boolean disks_changed) ``{
	BootCommon::liloFixSections ();
    }

    /**
      * Fix global options of bootloader during proposal regeneration
      * modifies internal sreuctures
      * @param disks_changed boolean should be true if bootloader location
      *   relevant disk locations have changed
      */
    global define void fixGlobals (boolean disks_changed) ``{
	BootCommon::liloFixGlobals ();
    }

    /**
      * Create strings representing cfg. files for by-hand editation
      * @return map filename -> contents
      */
    global define map GetFiles() ``{
	BootCommon::addValueToBootloaderSection (
	    `globals, "boot", BootCommon::loader_device);
        BootCommon::saveCfgFileToAgent ();
        return $[
            "/etc/lilo.conf" : SCR::Read (.lilo.tostring),
        ];
    }

    /**
      * Store strings representing cfg. files to internal structures
      * @param files map filename -> contents
      */
    global define void SetFiles (map files) ``{
	if (SCR::Read (.lilo.tostring) != files["/etc/lilo.conf"]:"")
	    BootCommon::files_edited = true;
        SCR::Write (.lilo.fromstring, files["/etc/lilo.conf"]:"");
        BootCommon::loadCfgFileFromAgent ();
	if (lookup_value (BootCommon::globals, "boot", "") != BootCommon::loader_device)
	    BootCommon::location = "custom";
	BootCommon::loader_device = lookup_value (BootCommon::globals, "boot", "");
    }

    /**
      * Convert section orig from type otype to ntype
      * Some information gets lost. ntype must be different from otype
      * @param otype string original section type, "image" or "other"
      * @param ntype string new section type, "image" or "other"
      * @param orig list original section
      * @return list new (converted) section
      */
    global define list convertSection (string otype, string ntype, list orig)
    ``{
	list ret = [];
	if (orig == nil)
	{
	    if (ntype == "other")
	    {
		ret = [ $[ "key" : "other", "value" : "" ]];
	    }
	    else
	    {
		ret = [
		    $[ "key" : "image", "value" : ""],
		    $[ "key" : "initrd", "value" : ""],
		    $[ "key" : "root", "value" : "" ]
		];
	    }
	    ret = add (ret, $[ "key" : "label", "value" :
		BootCommon::getFreeSectionLabel ()]);
	    return ret;
	}
	map label_map = getValueMap (orig, "label");
	if (ntype == "other")
	{
	    ret = [ $["key" : "other", "value" :
		select (BootCommon::splitPath (
		    lookup_value (orig, "image", "")), 0, "")]];
	}
	else
	{
	    ret = [
		$[ "key" : "image", "value" : "/boot/vmlinuz"],
		$[ "key" : "root", "value" : lookup_value (orig, "other", "")],
		$[ "key" : "initrd", "value" : "/boot/initrd"],
	    ];
	}
	ret = add (ret, label_map);
	return ret;
    }

}
