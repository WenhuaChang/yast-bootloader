/**
 * File:
 *      modules/BootLILO.ycp
 *
 * Module:
 *      Bootloader installation and configuration
 *
 * Summary:
 *      Module containing specific functions for LILO configuration
 *      and installation
 *
 * Authors:
 *      Jiri Srain <jsrain@suse.cz>
 *
 * $Id$
 *
 */

{
    module "BootLILO";

    textdomain "bootloader";

    import "Kernel";
    import "Storage";

    import "BootCommon";

    include "bootloader/lilo/widgets.ycp";
    include "bootloader/lilo/helps.ycp";
    include "bootloader/routines/popups.ycp";

// private variables

    /**
      * List of partitions deleted in primary proposal
      */
    list(string) del_parts = [];


// general functions

    /**
      * Return map of provided functions
      * @return map map of functions (eg. $["write":``(BootLILO::Write ())])
      */
    global define map GetFunctions () ``{
	return $[
	    "read" :	``(BootLILO::Read ()),
	    "propose" : ``(BootLILO::Propose ()),
	    "save" :	``(BootLILO::Save ()),
	    "update" :	``(BootLILO::Update ()),
	    "write" :	``(BootLILO::Write ()),
	    "widgets" :	``(BootLILO::GetWidgets ()),
	    "getfiles" : ``(BootLILO::GetFiles ()),
	    "setfiles" : ``(BootLILO::SetFiles ())
	];
    }

    /**
      * Propose bootloader settings
      */
    global define void Propose () ``{
	if (! BootCommon::was_proposed)
	{
            BootCommon::DetectDisks ();
	    del_parts = BootCommon::getPartitionList (`deleted);
	    y2milestone ("Partitions planned to be deleted: %1", del_parts);
	}

	boolean disks_changed = BootCommon::RefreshDisks();
	if (disks_changed)
	{
	    if (askLocationResetPopup (BootCommon::loader_device))
	    {
		BootCommon::location = "";
		BootCommon::DetectDisks ();
	    }
	}

	BootCommon::loader_device = BootCommon::GetBootloaderDevice ();

	if (size (BootCommon::sections) == 0)
	{
	    createSections ();
	    BootCommon::kernelCmdLine = Kernel::cmdLine;
	}
	else
	{
	    fixSections (disks_changed);
	}
	if (size (BootCommon::globals) == 0)
	{
	    createGlobals ();
	}
	else
	{
	    fixGlobals (disks_changed);
	}

	y2milestone ("Proposed sections: %1", BootCommon::sections);
	y2milestone ("Proposed globals: %1", BootCommon::globals);
	BootCommon::globals["boot"] = BootCommon::loader_device;
	BootCommon::saveCfgFileToAgent ();
    }

    /**
      * Read settings from disk
      * @return boolean true on success
      */
    global define boolean Read () ``{
	BootCommon::DetectDisks ();
	BootCommon::Read ();
	BootCommon::loader_device
	    = SCR::Read(BootCommon::list2path(["lilo", "boot"]));
	if (BootCommon::globals["default"]:"" == "")
	    BootCommon::globals["default"]
		= BootCommon::sections[0, "label"]:"";
    }

    /**
      * Save all bootloader configuration files
      * @return boolean true if success
      */
    global define boolean Save () ``{
	SCR::Execute (.target.bash, "test -f /etc/lilo.conf && /bin/cp /etc/lilo.conf /etc/lilo.conf.old");
	SCR::Execute (.target.bash, "/usr/bin/touch /etc/lilo.conf");

	BootCommon::sections = filter (`s, BootCommon::sections, ``{
            if (s["label"]:"" == "")
                return false;
	    if (! contains (["linux", "failsafe", "memtest86"], s["label"]:""))
		return true;

	    string kernel = s["image"]:"";
	    if (kernel == "")
		return true;
	    if (SCR::Read (.target.size, kernel) == -1)
		return false;
	    return true;
	});
        BootCommon::sections = maplist (`s, BootCommon::sections, ``{
            string initrd = s["initrd"]:"";
            if (initrd != "")
            {
                if (-1 == SCR::Read (.target.size, initrd))
                    s = remove (s, "initrd");
            }
            else if ((title == "linux" || title == "failsafe")
		&& BootCommon::write_settings["insert_initrd"]:false)
            {
                if (title == "linux")
                    s["initrd"] = "/boot/initrd";
                else
                    s["initrd"] = "/boot/initrd.shipped";
            }
            if (s["label"]:"" == "linux")
		s["append"] = BootCommon::updateKernelParams (s["append"]:"");
            return s;
	});
	string message = BootCommon::globals["message"]:"";
        if (message != "")
        {
            if (-1 == SCR::Read (.target.size, message))
                BootCommon::globals = remove (BootCommon::globals, "message");
        }
	BootCommon::globals["boot"] = BootCommon::loader_device;
	boolean ret = BootCommon::Save ();
	SCR::Execute (.target.bash, "/bin/chmod 600 /etc/lilo.conf");
	return ret;
    }

    /**
      * Update read settings to new version of configuration files
      */
    global define void Update () ``{
	updateSections (true);
	updateGlobals ();
    }
    /**
      * Write bootloader settings to disk
      * @return boolean true on success
      */
    global define boolean Write () ``{
	BootCommon::updateMBR ();
	boolean ret = true;
	if (true) // save always in case of LILO
//	if (BootCommon::location_changed)
	{
	    if (! (BootCommon::location == "floppy" && saveToFLoppyPopup ()))
		ret = false;
// save if mkfs or fdformat failed too
//            if (ret)
		ret = 0 == SCR::Execute (.target.bash,
		    "/sbin/lilo >> /var/log/YaST2/y2loglilo 2>&1");
	    if (! ret)
	    {
		string log = SCR::Read (.target.string,
		    "/var/log/YaST2/y2loglilo");
		// error popup - label
                errorWithLogPopup (_("Error occurred while installing LILO"),
                    log);
	    }
	}
	return ret;
    }

// end of mandatory functions
//----------------------------------------------------------------------------

    /**
      * Create linux section
      * @param title strign section title (linux, failsafe, memtest)
      * @return section description structure
      */
    global define map createLinuxSection (string title) ``{
	if (title == "memtest86")
	{
	    return $[
		"image" : "/boot/memtest.bin",
		"label" : "memtest86",
		"__intern__" : $[
		    "auto" : true,
		    "changed" : false,
		    "devs" : [],
		],
	    ];
	}
	string initrd = title == "failsafe" ? "initrd.shipped" : "initrd";
	string image = title == "failsafe" ? "vmlinuz.shipped" : "vmlinuz";
	string append = title == "failsafe"
	    ? "ide=nodma apm=off acpi=off vga=normal "
	      + ((Arch::x86_64) ? "iommu=noforce " : "nosmp noapic ")
	      + "maxcpus=0 3"
	    : Kernel::cmdLine;
	map ret = $[
	    "label" : title,
	    "image" : "/boot/" + image,
	    "initrd" : "/boot/" + initrd,
	    "root" : BootCommon::RootPartitionDevice,
	    "append" : append,
	    "__intern__" : $[
		"auto" : true,
		"changed" : false,
		"devs" : [BootCommon::RootPartitionDevice]
	    ],
	];
	if (Kernel::vgaType != "")
	    ret["vga"] = Kernel::vgaType;
	return ret;
    }

    /**
      * Propose sections to bootloader menu
      * modifies internal sreuctures
      */
    global define void createSections () ``{
	list out = [
	    createLinuxSection ("linux")
	];
	list others = Storage::GetForeignPrimary();
	if (others != nil)
	{
	    if (size (others) > 0)
	    {
		foreach (`o, others, ``{
		    list parts = splitstring (o, " ");
		    while (select (parts, 0, " ") == "")
			parts = remove (parts, 0);
		    string dev = select (parts, 0, "");
		    parts = remove (parts, 0);
		    string label = mergestring (parts, " ");

                    // don't add rewritten location (#19990)
		    if (dev != "" && label != ""
			&& dev != BootCommon::loader_device)
		    {
			map m = $[
			    "label" : BootCommon::removeBlanks (label),
			    "other" : dev,
			    "__intern__" : $[
				"auto" : true,
				"changed" : false,
				"devs" : [dev],
			    ],
			];
			out = add (out, m);
		    }
		});
	    }
	}
        out = add (out, createLinuxSection ("failsafe"));
	out = add (out, createLinuxSection ("memtest86"));
	BootCommon::sections = out;
    }

    /**
      * Propose global options of bootloader
      * modifies internal structures
      */
    global define void createGlobals () ``{
	map bcg = $[];
	bcg["menu-scheme"] = "Wg:kw:Wg:Wg";
	bcg["default"] = "linux";
	bcg["timeout"] = 80;
	bcg["message"] = "/boot/message";
	list internal_bios = SCR::Read (.probe.bios);
	bcg["lba32"] = internal_bios[0, "lba_support"]:false;
	bcg["change-rules"] = "change-rules,reset";
	bcg["read-only"] = true;
	bcg["prompt"] = true;
	if (Storage::DiskmapNeeded())
	{
	    string order = "";
	    // check if bios_id is given for a target
	    map targetMap = Storage::GetTargetMap();
	    foreach (`target_dev, `target, targetMap, ``{
		string bios_id = target["bios_id"]:"";
		if (bios_id != "")
		{
		    if (order != "")
			order = order + ",";
		    order = order + sformat ("disk=%1,bios=%2", target_dev,
			bios_id);
		}
	    });
	    if (order != "")
		bcg["disk"] = order;
	}
	BootCommon::globals = bcg;
    }

    /**
      * Update sections of bootloader menu
      * modifies internal sreuctures
      * @param replace boolean true if old sectinos shall be replaced
      */
    global define void updateSections (boolean replace) ``{
	list out = BootCommon::sections;

	foreach (`t, ["linux", "failsafe", "memtest86"], ``{
	    map m = createLinuxSection (t);
	    boolean changed = false;
	    list out = maplist (`s, out, ``{
		if (s["title"]:"" == m["title"]:"")
		{
		    changed = true;
		    if (replace)
			return m;
		    else
			return s;
		}
		else
		{
		    return s;
		}
	    });
            if (! changed)
                if (t == "normal")
                    out = prepend (out, m);
                else
                    out = add (out, m);
        });
        BootCommon::sections = out;
    }

    /**
      * Update global options of bootloader
      * modifies internal sreuctures
      */
    global define void updateGlobals () ``{
        map bcg = BootCommon::globals;
        bcg["menu-scheme"] = "Wg:kw:Wg:Wg";
        bcg["timeout"] = 8;
	bcg["message"] = "/boot/message";
        BootCommon::globals = bcg;
    }

    /**
      * Fix sections of bootloader menu during proposal regeneration
      * modifies internal sreuctures
      * @param disks_changed boolean should be true if bootloader location
      *   relevant disk locations have changed
      */
    global define void fixSections (boolean disks_changed) ``{
	list parts = BootCommon::getPartitionList(`parts_old);
	if (BootCommon::partitioning_last_change
		!= Storage::GetTargetChangeTime()
	    && BootCommon::files_edited)
	{
	    displayFilesEditedPopup ();
	    BootCommon::files_edited = false;
	    return;
	}
	list(map) old_sect_list = BootCommon::sections;
	createSections ();
	map old_sect = listmap (`s, old_sect_list, ``{
	    return [s["label"]:"", s];
	});
	map new_sect = listmap (`s, BootCommon::sections, ``{
	    return [s["label"]:"", s];
	});
	old_sect_list = maplist (`s, old_sect_list, ``{
	    string label = s["label"]:"";
	    if (! s["__intern__", "auto"]:false)
	    {
		y2milestone ("Leaving section %1", label);
		return s;
	    }
	    else if (! s["__intern__", "changed"]:false)
	    {
		y2milestone ("Recreating section %1", label);
		return new_sect[label]:$[];
	    }
	    else
	    {
		y2milestone ("Warning on section %1", label);
		boolean cont = true;
                if (s["label"]:"" != "linux" && s["label"]:"" != "failsafe"
                    && s["label"]:"" != "memtest86")
		{
		    foreach (`n, s["__intern__", "devs"]:[], ``{
		        if (! contains (parts, n))
		        {
			    cont = false;
		        }
		    });
		}
                list new_devs = toset(new_sect[title, "__intern__", "devs"]:[]);
                list old_devs = toset(s["__intern__", "devs"]:[]);
                if (size (new_devs) != size (old_devs))
                    cont = false;
                else
                {
                    foreach (`d, old_devs, ``{
                        if (! contains (new_devs, d))
                            cont = false;
                    });
                }
		if (! cont)
		    displayDiskChangePopup (s["label"]:"");
		return s;
	    }
	});
	y2milestone ("Checking for sections needing some of %1", del_parts);
	list(string) to_remove = [];
	foreach (`s, BootCommon::sections, ``{
	    list(string) devs = s["__intern__", "devs"]:[];
	    y2milestone ("Section %1 needs %2", s["label"]:"", devs);
	    boolean to_add = false;
	    foreach (string d, devs, ``{
		if (contains (del_parts, d))
		{
		    to_add = true;
		}
	    });
	    if (to_add)
	    {
		map old_sect = listmap (`s, old_sect_list, ``{
		    return [s["label"]:"", s];
		});

		string title = s["label"]:"";
		if (title != "" && ! haskey(old_sect, title))
		{
		    y2milestone ("Adding %1", s);
		    to_remove = add (to_remove, d);
		    old_sect_list = add (old_sect_list, s);
		}
	    }
	});
	del_parts = BootCommon::difflist (del_parts, to_remove);
	old_sect_list = filter (`s, old_sect_list, ``(s != $[]));
	BootCommon::sections = old_sect_list;
    }

    /**
      * Fix global options of bootloader during proposal regeneration
      * modifies internal sreuctures
      * @param disks_changed boolean should be true if bootloader location
      *   relevant disk locations have changed
      */
    global define void fixGlobals (boolean disks_changed) ``{
	if (BootCommon::globals["default"]:"" != "")
	{
	    boolean exists = false;
	    foreach (`s, BootCommon::sections, ``{
		if (s["label"]:"" == BootCommon::globals["default"]:"")
		    exists = true;
	    });
	    if (! exists)
		BootCommon::globals["default"]
		    = BootCommon::sections[0, "label"]:"";
	}
    }

    /**
      * Create strings representing cfg. files for by-hand editation
      * @return map filename -> contents
      */
    global define map GetFiles() ``{
	BootCommon::globals["boot"] = BootCommon::loader_device;
        BootCommon::saveCfgFileToAgent ();
        return $[
            "/etc/lilo.conf" : SCR::Read (.lilo.tostring),
        ];
    }

    /**
      * Store strings representing cfg. files to internal structures
      * @param files map filename -> contents
      */
    global define void SetFiles (map files) ``{
	if (SCR::Read (.lilo.tostring) != files["/etc/lilo.conf"]:"")
	    BootCommon::files_edited = true;
        SCR::Write (.lilo.fromstring, files["/etc/lilo.conf"]:"");
        BootCommon::loadCfgFileFromAgent ();
	if (BootCommon::globals["boot"]:"" != BootCommon::loader_device)
	    BootCommon::location = "custom";
	BootCommon::loader_device = BootCommon::globals["boot"]:"";
    }

}
