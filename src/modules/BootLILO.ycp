/**
 * File:
 *      modules/BootLILO.ycp
 *
 * Module:
 *      Bootloader installation and configuration
 *
 * Summary:
 *      Module containing specific functions for LILO configuration
 *      and installation
 *
 * Authors:
 *      Jiri Srain <jsrain@suse.cz>
 *
 * $Id$
 *
 */

{
    module "BootLILO";

    textdomain "bootloader";

    import "Mode";
    import "Kernel";
    import "Storage";

    import "BootCommon";
    import "Arch";
    import "Pkg";

//    include "bootloader/lilo/widgets.ycp";
    include "bootloader/lilo/helps.ycp";
    include "bootloader/routines/popups.ycp";

// private variables





/**
 * Propose sections to bootloader menu
 * modifies internal sreuctures
 */
global void CreateSections () {
    list<map<string,any> > out = [
	BootCommon::CreateLinuxSection ("linux")
    ];
    list<string> others = (list<string>)Storage::GetForeignPrimary();
    if (others != nil)
    {
	    if (size (others) > 0)
	    {
		foreach (string o, others, ``{
		    list<string> parts = splitstring (o, " ");
		    while (parts[0]:" " == "")
			parts = remove (parts, 0);
		    string dev = parts[0]:"";
		    parts = remove (parts, 0);
		    string label = mergestring (parts, " ");

                    // don't add rewritten location (#19990)
		    if (dev != "" && label != ""
			&& dev != BootCommon::loader_device)
		    {
			map<string,any> m = $[
			    "name" : BootCommon::translateSectionTitle (
				BootCommon::removeBlanks (label)),
			    "original_name" : label,
			    "type" : "chainloader",
			    "chainloader" : dev,
			    "__auto" : true,
			    "__changed" : false,
			    "__devs" : [dev],
			    "__type" : label,
			];
			out = add (out, m);
		    }
		});
	    }
    }
    out = add (out, BootCommon::CreateLinuxSection ("failsafe"));
    out = add (out, BootCommon::CreateLinuxSection ("memtest86"));
//    out = add (out, BootCommon::CreateLinuxSection ("wildcard"));
    out = filter (map<string,any> s, out, { return s != $[] && s != nil;});
    BootCommon::sections = out;
}

/**
 * Propose global options of bootloader
 * modifies internal structures
 */
global void CreateGlobals () {
    BootCommon::globals = $[
	"default" : BootCommon::sections[0, "name"]:"",
	"timeout" : "8",
	"gfxmenu" : "/boot/message",
    ];
}

/**
 * Update sections of bootloader menu
 * modifies internal sreuctures
 * @param replace boolean true if old sectinos shall be replaced
 */
global define void UpdateSections (boolean replace) {
    BootCommon::UpdateSections (replace, BootCommon::CreateLinuxSection);
}

    /**
      * Update global options of bootloader
      * modifies internal sreuctures
      */
    global define void UpdateGlobals () ``{
// FIXME whole function
return;
/*
	BootCommon::globals = maplist (map e, BootCommon::globals, ``{
	    if (e["key"]:"" == "menu-scheme")
		e["value"] = "Wb:kw:Wb:Wb";
	    else if (e["key"]:"" == "timeout")
		e["value"] = 80;
	    else if (e["key"]:"" == "message")
		e["value"] = "/boot/message";
	    else if (e["key"]:"" == "boot")
		e["value"] = BootCommon::UpdateDevice (e["value"]:"");
	    return e;
	});*/
    }

/**
 * Fix sections of bootloader menu during proposal regeneration
 * modifies internal sreuctures
 * @param disks_changed boolean should be true if bootloader location
 *   relevant disk locations have changed
 */
global void FixSections (boolean disks_changed) {
    BootCommon::FixSections (BootLILO::CreateSections);
}

/**
 * Fix global options of bootloader during proposal regeneration
 * modifies internal sreuctures
 * @param disks_changed boolean should be true if bootloader location
 *   relevant disk locations have changed
 */
global void FixGlobals (boolean disks_changed) {
    BootCommon::FixGlobals ();
}


// general functions

    /**
      * Propose bootloader settings
      */
    global define void Propose () ``{
	y2debug ("Started propose: Glob: %1, Sec: %2",
	    BootCommon::globals, BootCommon::sections);
	if (! BootCommon::was_proposed)
	{
            BootCommon::DetectDisks ();
	    BootCommon::del_parts = BootCommon::getPartitionList (`deleted);
	    y2milestone ("Partitions planned to be deleted: %1",
		BootCommon::del_parts);
	}

	boolean disks_changed = BootCommon::RefreshDisks();
	if (disks_changed && ! Mode::autoinst ())
	{
	    if (askLocationResetPopup (BootCommon::loader_device))
	    {
		BootCommon::selected_location = nil;
		BootCommon::loader_device = nil;
		BootCommon::DetectDisks ();
	    }
	}

	// set activate flag
	if (! BootCommon::activate_changed)
	{
	    BootCommon::activate
	        = size (Storage::GetBootPartition (BootCommon::mbrDisk)) == 0;
	}

	if (BootCommon::sections == nil || size (BootCommon::sections) == 0)
	{
	    CreateSections ();
	    BootCommon::kernelCmdLine = Kernel::GetCmdLine ();
	}
	else
	{
            if (Mode::autoinst ())
            {
                // TODO whatever will be needed
		y2debug ("nothing to to in AI mode if sections exist");
            }
            else
		FixSections (disks_changed);
	}
	if (BootCommon::globals == nil || size (BootCommon::globals) == 0)
	{
	    CreateGlobals ();
	}
	else
	{
            if (Mode::autoinst ())
            {
                // TODO whatever will be needed
		y2debug ("nothing to to in AI mode if globals are defined");
            }
            else
		FixGlobals (disks_changed);
	}

	y2milestone ("Proposed sections: %1", BootCommon::sections);
	y2milestone ("Proposed globals: %1", BootCommon::globals);
    }

/**
 * Read settings from disk
 * @return boolean true on success
 */
global boolean Read (boolean reread) {
    BootCommon::InitializeLibrary (reread, "lilo");
    if (reread)
    {
	BootCommon::ReadFiles ();
    }
    BootCommon::DetectDisks ();
    boolean ret = BootCommon::Read (false);
    BootCommon::loader_device = BootCommon::globals["stage1_dev"]:"";
    return ret;
}

/**
 * Save all bootloader configuration files to the cache of the PlugLib
 * PlugLib must be initialized properly !!!
 * @param clean boolean true if settings should be cleaned up (checking their
 *  correctness, supposing all files are on the disk
 * @param init boolean true to init the library
 * @param flush boolean true to flush settings to the disk
 * @return boolean true if success
 */
global boolean Save (boolean clean, boolean init, boolean flush) {
    BootCommon::globals["stage1_dev"] = BootCommon::loader_device;
    boolean ret = BootCommon::Save (clean, init, flush);
    return ret;
}

    /**
      * Update read settings to new version of configuration files
      */
    global define void Update () ``{
	UpdateSections (true);
	UpdateGlobals ();
	BootCommon::loader_device
	    = BootCommon::UpdateDevice (BootCommon::loader_device);
    }
    /**
      * Write bootloader settings to disk
      * @return boolean true on success
      */
    global define boolean Write () ``{
	boolean ret = BootCommon::UpdateBootloader ();
	BootCommon::updateMBR ();
	if (BootCommon::InstallingToFloppy ())
	{
	    if (! saveToFLoppyPopup ())
	    {
		y2error ("Preparing floppy disk failed.");
		ret = false;
	    }
	}
	// create backup copy first
	if (BootCommon::createBackupBS ()
	    && BootCommon::getDeviceOfRaid (BootCommon::BootPartitionDevice)
		!= BootCommon::BootPartitionDevice)
	{
	    y2milestone ("Creating backup copy to bootsector");
	    SCR::Execute (.target.bash, sformat ("/sbin/lilo -b %1",
		BootCommon::BootPartitionDevice));
	}

	ret = ret && BootCommon::InitializeBootloader ();
	return ret;
    }

    /**
      * Return map of provided functions
      * @return map map of functions (eg. $["write":``(BootLILO::Write ())])
      */
    global define map<string, any> GetFunctions () ``{
	return $[
	    "read"	: BootLILO::Read,
	    "propose"	: BootLILO::Propose,
	    "save"	: BootLILO::Save,
	    "update"	: BootLILO::Update,
	    "write"	: BootLILO::Write,
//	    "widgets"	: BootLILO::GetWidgetMaps,
	];
    }

    /**
      * Initializer of LILO bootloader
      */
    global define void Initializer () ``{
	y2milestone ("Called LILO initializer");
	BootCommon::current_bootloader_attribs = $[
	    "section_title" : "label",
	    "kernel_key" : "image",
	    "default_key" : "default",
	    "default_type" : `label,
	    "timeout_multiplier" : 10,
	    "alias_keys" : ["alias"],
	    "kernel_params" : $[
		"vga" : "vga",
		"root" : "root",
		`other : "append",
	    ],
	    "propose" : true,
	    "read" : true,
	    "scratch" : true,
	    "restore_mbr" : true,
	    "key_only_once" : true,
	    "bootloader_on_disk" : true,
	    "option_list" : BootCommon::GetOptions (),
	];
    }

    /**
      * Constructor
      */
    global define void BootLILO () ``{
	BootCommon::bootloader_attribs["lilo"] = $[
	    "required_packages" : ["lilo"],
	    "loader_name" : "LILO",
	    "initializer" : BootLILO::Initializer,
	];
    }



}
