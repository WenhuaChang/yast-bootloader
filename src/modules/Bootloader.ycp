/**
 * File:
 *      modules/Bootloader.ycp
 *
 * Module:
 *      Bootloader installation and configuration
 *
 * Summary:
 *      Bootloader installation and configuration base module
 *
 * Authors:
 *      Jiri Srain <jsrain@suse.cz>
 *
 * $Id$
 *
 */

{
    module "Bootloader";

    textdomain "bootloader";

    import "Arch";
    import "BootCommon";
    import "Initrd";

    include "bootloader/routines/switcher.ycp";
    include "bootloader/routines/popups.ycp";


    /**
      * Write is repeating again
      * Because of progress bar during inst_finish
      */
    global boolean repeating_write = false;

// installation proposal help variables

    /**
      * Configuration was changed during inst. proposal if true
      */
    global boolean proposed_cfg_changed = false;

// old vga value handling function

    /**
      * old value of vga parameter of default bootloader section
      */
    string old_vga = nil;


// general functions

    /**
      * Export bootloader settings to a map
      * @return bootloader settings
      */
    global define map Export () ``{
	ReadOrProposeIfNeeded ();
	map out = $[
	    "location" : BootCommon::location,
	    "loader_device" : BootCommon::loader_device,
	    "loader_type" : BootCommon::getLoaderType (false),
	    "initrd" : Initrd::Export (),
	    "specific" : blExport (),
	    "changed_settings" : BootCommon::changed_settings,
	    "write_settings" : BootCommon::write_settings,
	];
	return out;
    }
    /**
      * Import settings from a map
      * @param settings map of bootloader settings
      */
    global define void Import (map settings) ``{
	Reset ();
	BootCommon::was_read = true;
	BootCommon::was_proposed = true;
	BootCommon::changed = true;
	BootCommon::location_changed = true;
	BootCommon::location = settings["location"]:"";
	BootCommon::loader_device = settings["loader_device"]:"";
	BootCommon::setLoaderType (settings["loader_type"]:nil);
	if (settings["initrd"]:$[] != nil)
	    Initrd::Import (settings["initrd"]:$[]);
	blImport (settings["specific"]:$[]);
	BootCommon::changed_settings = settings["changed_settings"]:$[];
	BootCommon::write_settings = settings["write_settings"]:$[];
    }
    /**
      * Read settings from disk
      * @return boolean true on success
      */
    global define boolean Read () ``{
//	Initrd::Read ();
	boolean ret = blRead ();
	BootCommon::location
	    = SCR::Read (.sysconfig.bootloader.LOADER_LOCATION);
	if (BootCommon::location == "none")
	{
	    BootCommon::location = "custom";
	    BootCommon::loader_device = "/dev/null";
	}
	else if (BootCommon::location == nil || BootCommon::location == "")
	{
	    BootCommon::location = "custom";
	}
	BootCommon::loader_device = BootCommon::GetBootloaderDevice ();
	BootCommon::was_read = true;
	old_vga = getKernelParam (getDefaultSection (), "vga");
	return ret;
    }
    /**
      * Reset bootloader settings
      */
    global define void Reset () ``{
	BootCommon::was_proposed = false;
	BootCommon::was_read = false;
	BootCommon::location = "";
	BootCommon::loader_device = "";
//	BootCommon::setLoaderType (nil);
	BootCommon::changed = false;
	BootCommon::location_changed = false;
//	BootCommon::other_bl = $[];
	BootCommon::files_edited = false;
	BootCommon::changed_settings = $[];
	BootCommon::write_settings = $[];
	blReset ();
    }
    /**
      * Propose bootloader settings
      */
    global define void Propose () ``{
	blPropose ();
	BootCommon::was_proposed = true;
        BootCommon::changed = true;
        BootCommon::location_changed = true;
	BootCommon::partitioning_last_change = Storage::GetTargetChangeTime();
    }
    /**
      * Display bootloader summary
      * @return a list of summary lines
      */
    global define list(string) Summary () ``{
	return blSummary ();
    }
    /**
      * Write bootloader settings to disk
      * @return boolean true on success
      */
    global define boolean Write () ``{
	boolean ret = true;
	ReadOrProposeIfNeeded ();

	if (BootCommon::write_settings["save_all"]:false)
	{ // force saving everything
	    BootCommon::changed = true;
	    BootCommon::location_changed = true;
	    Initrd::changed = true;
	}

	y2milestone ("Writing bootloader configuration");

// run Progress bar
        list stages = [
            // progress stage, text in dialog (short)
            _("Creating initrd..."),
            // progress stage, text in dialog (short)
            _("Saving boot loader configuration files..."),
            // progress stage, text in dialog (short)
            _("Installing boot loader..."),
        ];
        list titles = [
            // progress stage, text in dialog (short)
            _("Creating initrd..."),
            // progress stage, text in dialog (short)
            _("Saving boot loader configuration files..."),
            // progress stage, text in dialog (short)
            _("Installing boot loader..."),
        ];
        // progress bar caption
        if (Mode::normal)
	{
	    // progress line
            Progress::New (_("Saving boot loader configuration..."),
                " ", 2, stages, titles, BootCommon::getSaveProgressHelp ());
	    Progress::NextStage ();
	}
        else
        {
            Progress::Title (titles[0]:"");
        }

	string new_vga = getKernelParam (getDefaultSection (), "vga");
	if (new_vga != old_vga && new_vga != "false" && new_vga != "")
	    Initrd::setSplash (new_vga);

	// save initrd
	if ((Initrd::changed || ! Mode::normal)
	    && ! (BootCommon::write_settings["forbid_save_initrd"]:false))
	{
	    string vga = getKernelParam (getDefaultSection (), "vga");
	    if (vga != "false" && vga != "")
		Initrd::setSplash (vga);
	    ret = Initrd::Write ();
	    BootCommon::changed = true;
	}

	if (! (BootCommon::changed
	    || BootCommon::write_settings["initrd_changed_externally"]:false))
	{
	    y2milestone ("No bootloader cfg. file saving needed, exiting");
	    return true;
	}

	if (Mode::normal)
	    Progress::NextStage ();
	else
        {
	    if (! repeating_write)
		Progress::NextStep ();
            Progress::Title (titles[1]:"");
        }

	// Write settings to /etc/sysconfig/bootloader
	if (BootCommon::location == "custom"
	    && BootCommon::loader_device == "/dev/null")
	{
	    BootCommon::location = "none";
	}
	y2milestone ("Saving configuration files");
        SCR::Write (.sysconfig.bootloader.LOADER_TYPE,
	    BootCommon::getLoaderType (false));
        SCR::Write (.sysconfig.bootloader.LOADER_LOCATION,
            BootCommon::location);

	if (! Mode::normal)
	{
	    string comment
		= SCR::Read (.sysconfig.bootloader.LOADER_TYPE.comment);
	    if (comment == nil)
		comment = "";
	    if (Arch::i386 || Arch::x86_64)
	    {
		comment = regexpsub (comment, "(.*\n## )Type:[^\n]*(\n.*)",
		    "\\1Type:	list(grub,lilo)\\2");
	    }
	    comment = regexpsub (comment, "(.*\n## )Default:[^\n]*(\n.*)",
		sformat ("\\1Default:  %1\\2", getLoaderType ()));
	    if (comment != nil)
		SCR::Write (.sysconfig.bootloader.LOADER_TYPE.comment, comment);
	    comment = SCR::Read (.sysconfig.bootloader.LOADER_LOCATION.comment);
	    if (comment == nil)
		comment = "";
	    if (Arch::i386 || Arch::x86_64)
            {
                comment = regexpsub (comment, "(.*\n## )Type:[^\n]*(\n.*)",
                    "\\1Type:	list(floppy,mbr,root,boot,custom,none)\\2");
            }
	    comment = regexpsub (comment, "(.*\n## )Default:[^\n]*(\n.*)",
		sformat ("\\1Default:  %1\\2", BootCommon::location));
	    if (comment != nil)
		SCR::Write (.sysconfig.bootloader.LOADER_LOCATION.comment,
		    comment);
	}
	SCR::Write (.sysconfig.bootloader, nil);

	// save bootloader settings
	ret = ret && blSave ();

        if (Mode::normal)
            Progress::NextStage ();
        else
        {
	    if (! repeating_write)
		Progress::NextStep ();
            Progress::Title (titles[2]:"");
        }

        if (BootCommon::location == "none" || BootCommon::location == "")
            return ret;

	// call bootloader executable
	y2milestone ("Calling bootloader executable");
	ret = ret && blWrite ();
	while (! ret)
	{
	    if (writeErrorPopup ())
	    {
		repeating_write = true;
		map res = WFM::CallFunction( `bootloader_proposal ("AskUser",
		    $[ "has_next": false]));
		if (res["workflow_sequence"]:nil == `next)
		    return Bootloader::Write ();
		else
		    break;
	    }
	    else
		break;
	}
	return ret;
    }

// write mode settings function

    /**
      * Set settings how to write bootloader
      * @param settings map of settings
      */
    global define void SetWriteMode (map settings) ``{
	y2milestone ("Setting mode for writing: %1", settings);
	foreach (`k, `v, settings, ``{
	    BootCommon::write_settings[k] = v;
	});
    }

// sections handling functions

    /**
      * return default section label
      * @return string default section label
      */
    global define string getDefaultSection () ``{
	ReadOrProposeIfNeeded ();
	string bl = BootCommon::getLoaderType(false);
	list all = [];
	string def = sformat ("%1", BootCommon::globals["default"]:nil);
	if (bl != "grub")
	{
	    if (def == nil || def == "nil")
		def = "0";
	    else
		return def;
	}
	else
	{
	   if (def == nil || def == "nil")
		def = "0";
	}
	string titlename = BootCommon::getLoaderType (false) == "grub"
	    ? "title"
	    : "label";
	list sections = maplist (`s, BootCommon::sections, ``{
	    return s[titlename]:"";
	});
	integer i = tointeger (def);
	return select (sections, i, nil);
    }

    /**
      * get kernel parameters from bootloader configuration file
      * @param section string section title, use DEFAULT for default section
      * @param key string
      * @return string value, "false" if not present,
      * "true" if present key without value
      */
    global define string getKernelParam (string section, string key) ``{
	ReadOrProposeIfNeeded ();

	if (section == "DEFAULT")
	    section = getDefaultSection ();
	if (section == nil)
	    return "";
	string bl = BootCommon::getLoaderType (false);
	string label = bl == "grub" ? "title" : "label";
	integer sectnum = -1;
	integer index = -1;
	foreach (`s, BootCommon::sections, ``{
	    index = index + 1;
	    if (s[label]:"" == section)
		sectnum = index;
	});
	if (sectnum == -1)
	    return "";
	string line = "";
	if (bl != "grub")
	{
	    if (key == "vga" || key == "root")
	    {
		return BootCommon::sections[sectnum, key]:"false";
	    }
	    else
	    {
		line = BootCommon::sections[sectnum, "append"]:"";
	    }
	}
	else
	{
	    line = BootCommon::sections[sectnum, "kernel"]:"";
	}
	return BootCommon::getKernelParamFromLine (line, key);
    }

    /**
      * Get list of bootloader sections
      * @param type symbol what sections to be returned
      *  `linux -> linux sections
      *  `other -> other sections
      *  `all   -> all sections
      * @return list of strings representing sections names
      */
    global define list getSectionsList (symbol type) ``{
	string bl = BootCommon::getLoaderType (false);
	string title = ((bl == "grub") ? "title" : "label");
	string linux = ((bl == "grub") ? "kernel" : "image");

	list sects = BootCommon::sections;
	if (type == `other)
	    sects = filter (`s, sects, s[linux]:nil == nil);
	else if (type == `linux)
	    sects = filter (`s, sects, s[linux]:nil != nil);
	sects = maplist (`s, sects, ``(s[title]:""));
	sects = filter (`s, sects, ``(s != ""));
	return sects;
    }


    /**
      * set kernel parameter to menu.lst
      * @param section string section title, use DEFAULT for default section
      * @param key string parameter key
      * @param value string value, "false" to remove key,
      *   "true" to add key without value
      * @return boolean true on success
      */
    global define boolean setKernelParam
	(string section, string key, string value)
    ``{
	ReadOrProposeIfNeeded ();

	if (section == "DEFAULT")
	    section = getDefaultSection ();
	if (section == nil)
	    return false;
	string bl = BootCommon::getLoaderType (false);
        string label = bl == "grub" ? "title" : "label";
        integer sectnum = -1;
        integer index = -1;
        foreach (`s, BootCommon::sections, ``{
            index = index + 1;
            if (s[label]:"" == section)
                sectnum = index;
        });
        if (sectnum == -1)
            return false;
	string slabel = "";
	if ((key == "vga" || key == "root") && (value == "true"))
	    return false;
	if (bl != "grub")
	{
	    if (key == "vga" || key == "root")
	    {
		if (value != "false")
		    BootCommon::sections[sectnum, key] = value;
		else if (haskey (BootCommon::sections[sectnum]:$[], key))
		    BootCommon::sections[sectnum] = removekey
			(BootCommon::sections[sectnum]:$[], key);
	    }
	    else
	    {
		slabel = "append";
	    }
	}
	else
	{
	    slabel = "kernel";
	}
	string line = BootCommon::sections [sectnum, slabel]:"";
	line = BootCommon::setKernelParamToLine (line, key, value);
	BootCommon::sections [sectnum, slabel] = line;
	boolean ret = true;
	return ret;
    }

    /**
      * Get currently used bootloader, detect if not set yet
      * @return string botloader type
      */
    global define string getLoaderType () ``{
	return BootCommon::getLoaderType (false);
    }

    /**
      * Set type of bootloader
      * Just a wrapper to BootCommon::setLoaderType
      * @param bootloader string type of bootloader
      */
    global define void setLoaderType (string bootloader) ``{
	return BootCommon::setLoaderType (bootloader);
    }

    /**
      * Get root fs device
      * @return string root device
      */
    global define string getRootDevice () ``{
	ReadOrProposeIfNeeded ();
	return BootCommon::RootPartitionDevice;
    }

    /**
      * Set root fs device
      * @param string root device
      */
    global define void setRootDevice (string device) ``{
	ReadOrProposeIfNeeded ();
	BootCommon::RootPartitionDevice = device;
    }

    /**
      * Get device containing /boot directory
      * @return string boot device
      */
    global define string getBootDevice () ``{
	ReadOrProposeIfNeeded ();
	return BootCommon::BootPartitionDevice;
    }

    /**
      * Set device containing /boot directory
      * @param string boot device
      */
    global define void setBootDevice (string device) ``{
	ReadOrProposeIfNeeded ();
	BootCommon::BootPartitionDevice = device;
    }

    /**
      * Answer whether LBA is supported
      * @return boolean true if supported
      */
    global define boolean LbaSupport() ``{
	return BootCommon::LbaSupport ();
    }

    /**
      * Check whether settings were read or proposed, if not, decide
      * what to do and read or propose settings
      */
    global define void ReadOrProposeIfNeeded () ``{
        if (! (BootCommon::was_read || BootCommon::was_proposed))
        {
            if (Mode::initial && ! Mode::update)
            {
                Propose ();
            }
            else
            {
                Read ();
		if (Mode::update)
		{
		    blUpdate ();
		    BootCommon::changed = true;
		    BootCommon::location_changed = true;
		}
            }
        }
    }


}
