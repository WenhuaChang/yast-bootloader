/**
 * File:
 *      modules/Bootloader.ycp
 *
 * Module:
 *      Bootloader installation and configuration
 *
 * Summary:
 *      Bootloader installation and configuration base module
 *
 * Authors:
 *      Jiri Srain <jsrain@suse.cz>
 *
 * $Id$
 *
 */

{
    module "Bootloader";

    textdomain "bootloader";

    import "Arch";
    import "BootCommon";
    import "Installation";
    import "Initrd";
    import "Kernel";
    import "Mode";
    import "Progress";
    import "Stage";
    import "Storage";

//    import "BootABOOT";
    import "BootELILO";
    import "BootLILO";
//    import "BootMILO";
//    import "BootS390";
    import "BootGRUB";
    import "BootPOWERLILO"; // The ppc-LILO File

    global define map Export ();
    global define boolean Import (map settings);
    global define void Propose ();
    global define boolean Read ();
    global define void Reset ();
    global define boolean Write ();

    global define void ReadOrProposeIfNeeded ();
    global define string getDefaultSection ();
    global define string getKernelParam (string section, string key);
    global define boolean setKernelParam (string section, string key, string value);
    global define list<string> listKernelParams (string section);
    global define string getLoaderType ();
    global define string getProposedDefaultSection ();
    global define boolean UpdateGfxMenu ();


    /**
      * Write is repeating again
      * Because of progress bar during inst_finish
      */
    global boolean repeating_write = false;

// installation proposal help variables

    /**
      * Configuration was changed during inst. proposal if true
      */
    global boolean proposed_cfg_changed = false;

    /**
     * Cache for the installation proposal
     */
    global map cached_proposal = nil;
    global map cached_settings = $[];
    global integer cached_settings_base_data_change_time = nil;

// old vga value handling function

    /**
      * old value of vga parameter of default bootloader section
      */
    string old_vga = nil;

// UI helping variables

    global map aliases = $[];
    global map ws_data = $[];

    include "bootloader/routines/switcher.ycp";
    include "bootloader/routines/popups.ycp";


// general functions

    global boolean() test_abort = nil;

    /**
     * Check whether abort was pressed
     * @return boolean true if abort was pressed
     */
    boolean testAbort () {
        if (test_abort == nil)
    	return false;
        return test_abort ();
    }

    /**
      * Constructor
      */
    global define void Bootloader () {
	return;
    }

    /**
      * Export bootloader settings to a map
      * @return bootloader settings
      */
    global define map Export () {
	ReadOrProposeIfNeeded ();
	map out = $[
	    "loader_type" : getLoaderType (),
	    "initrd" : Initrd::Export (),
	    "specific" : blExport (),
	    "write_settings" : BootCommon::write_settings,
	];
	string loader_type = (string) (out["loader_type"]:nil);

	if ( ! ( loader_type == "grub" ) ) {
	    // export loader_device and selected_location only for bootloaders
	    // that have not phased them out yet
	    out["loader_device"] = BootCommon::loader_device;
	    out["loader_location"] = BootCommon::selected_location;
	}
	y2milestone ("Exporting settings: %1", out);
	return out;
    }
    /**
      * Import settings from a map
      * @param settings map of bootloader settings
      * @return boolean true on success
      */
    global define boolean Import (map settings) {
	y2milestone ("Importing settings: %1", settings);
	Reset ();

	BootCommon::was_read = true;
	BootCommon::was_proposed = true;
	BootCommon::changed = true;
	BootCommon::location_changed = true;

	if (settings["loader_type"]:nil == "")
	    settings["loader_type"] = nil;
	string loader_type = (string) (settings["loader_type"]:nil);
	BootCommon::setLoaderType (loader_type);
	BootCommon::getLoaderType (false);

	if ( ! ( loader_type == "grub" ) ) {
	    // import loader_device and selected_location only for bootloaders
	    // that have not phased them out yet
	    BootCommon::loader_device = settings["loader_device"]:"";
	    BootCommon::selected_location = settings["loader_location"]:"custom";
	    // FIXME: obsolete for grub (but inactive through the outer "if" now anyway):
	    // for lilo and grub, always correct the bootloader device according to
	    // selected_location (or fall back to value of loader_device)
	    // Why only for lilo and grub?
	    if (loader_type == "lilo" || loader_type == "grub"
		|| Arch::i386 () || Arch::x86_64 ())
	    {
		BootCommon::loader_device = BootCommon::GetBootloaderDevice ();
	    }
	}

	if (settings["initrd"]:$[] != nil)
	    Initrd::Import (settings["initrd"]:$[]);
	boolean ret = blImport (settings["specific"]:$[]);
	BootCommon::write_settings = settings["write_settings"]:$[];
	return ret;
    }
    /**
      * Read settings from disk
      * @return boolean true on success
      */
    global define boolean Read () {
	y2milestone ("Reading configuration");
// run Progress bar
	list<string> stages = [
	    // progress stage, text in dialog (short, infinitiv)
	    _("Check boot loader"),
	    // progress stage, text in dialog (short, infinitiv)
	    _("Read partitioning"),
	    // progress stage, text in dialog (short, infinitiv)
	    _("Load boot loader settings"),
	];
	list<string> titles = [
	    // progress step, text in dialog (short)
	    _("Checking boot loader..."),
	    // progress step, text in dialog (short)
	    _("Reading partitioning..."),
	    // progress step, text in dialog (short)
	    _("Loading boot loader settings..."),
	];
	// dialog header
	Progress::New (_("Initializing Boot Loader Configuration"),
	    " ", 3, stages, titles, "");

	Progress::NextStage ();
	if (testAbort ())
	    return false;

	Bootloader::getLoaderType ();

	Progress::NextStage ();
	if (testAbort ())
	    return false;

	BootCommon::DetectDisks ();
        Progress::NextStage ();
        if (testAbort ())
            return false;

	boolean ret = blRead (true);
	BootCommon::was_read = true;
	old_vga = getKernelParam (getDefaultSection (), "vga");

	Progress::Finish ();
	if (testAbort ())
	    return false;
	y2debug ("Read settings: %1", Export ());
	return ret;
    }
    /**
      * Reset bootloader settings
      * @param init boolean true if basic initialization of system-dependent
      * settings should be done
      */
    global define void ResetEx (boolean init) {
	if (Mode::autoinst ())
	    return;
	y2milestone ("Reseting configuration");
	BootCommon::was_proposed = false;
	BootCommon::was_read = false;
	BootCommon::loader_device = "";
//	BootCommon::setLoaderType (nil);
	BootCommon::changed = false;
	BootCommon::location_changed = false;
//	BootCommon::other_bl = $[];
	BootCommon::files_edited = false;
	BootCommon::write_settings = $[];
	blReset (init);
    }

    /**
      * Reset bootloader settings
      */
    global define void Reset () {
	return ResetEx (true);
    }
    /**
      * Propose bootloader settings
      */
    global define void Propose () {
	y2milestone ("Proposing configuration");
	// always have a current target map available in the log
	y2milestone ("unfiltered target map: %1", (map<string,map>)Storage::GetTargetMap());
	BootCommon::UpdateInstallationKernelParameters ();
	blPropose ();
	BootCommon::was_proposed = true;
        BootCommon::changed = true;
        BootCommon::location_changed = true;
	BootCommon::partitioning_last_change = Storage::GetTargetChangeTime();
	BootCommon::backup_mbr = true;
	y2milestone ("Proposed settings: %1", Export ());
    }
    /**
      * Display bootloader summary
      * @return a list of summary lines
      */
    global define list<string> Summary () {
        list<string> ret =[];

//F#300779 - Install diskless client (NFS-root) 
//kokso: additional warning that root partition is nfs type -> bootloader will not be installed

//B#355332 - Bootloader doesn't work if root partitions is like nfs
        map dev = Storage::GetDiskPartition(BootCommon::BootPartitionDevice);
        
        if (dev["disk"]:"" == "/dev/nfs")
        {
	   
           ret = add (ret, _("The boot partition is of type NFS. Bootloader cannot be installed."));
           y2milestone("Bootloader::Summary() -> Boot partition is nfs type, bootloader will not be installed.");
           return ret;

        }
//F#300779 - end
	ret = blSummary ();
	// check if default section was changed or not
        string main_section = getProposedDefaultSection ();
        if (main_section == nil)
            return ret;
	integer index = -1;
	integer sectnum = -1;
	if (getLoaderType () == "none")
	    return ret;
        foreach (map<string,any> s, BootCommon::sections, {
            index = index + 1;
            if (s["name"]:"" == main_section)
                sectnum = index;
        });
        if (sectnum == -1)
            return ret;
	if (BootCommon::sections[sectnum, "__changed"]:false)
	    return ret;
	string filtered_cmdline = filterchars (Kernel::GetCmdLine (),
	    "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890");
	if (size (filtered_cmdline) > 0)
	{
	    ret = add (ret, sformat (
		// part of summary, %1 is a part of kernel command line
		_("Added Kernel Parameters: %1"),
		Kernel::GetCmdLine ()));
	}
	return ret;
    }

    /**
      * Update read settings to new version of configuration files
      */
    global define void UpdateConfiguration () {
	// first run bootloader-specific update function
	blUpdate ();

	// remove ide-scsi emulation
	list<string> parameters = listKernelParams ("LINUX_DEFAULT");
	foreach (string p, parameters, {
	    if (regexpmatch (p, "^hd.=ide-scsi$")
		|| regexpmatch (p, "^hd.lun=.*$"))
	    {
		string param = regexpsub (p, "^(.*)=.*$", "\\1");
		setKernelParam ("LINUX_DEFAULT", param, nil);
	    }
	});
	// remove no more needed modules from MODULES_LOADED_ON_BOOT
	string mlob = (string)
	    SCR::Read (.sysconfig.kernel.MODULES_LOADED_ON_BOOT);
	list<string> mod_list = splitstring (mlob, " ");
	mod_list = filter (string s, mod_list, ``(
	    s != "" && s != "cdrom" && s != "ide-cd" && s != "ide-scsi"
	));
	mlob = mergestring (mod_list, " ");
	SCR::Write (.sysconfig.kernel.MODULES_LOADED_ON_BOOT, mlob);
	SCR::Write (.sysconfig.kernel, nil);
    }

    /**
     * Update the whole configuration
     * @param iv a map representing the installed (original) version
     * @param uv a map representing the version the system is upgraded to
     * @return boolean true on success
     */
    global boolean Update (map<string,any> iv, map<string,any> uv) {
        BootCommon::installed_version = iv;
        BootCommon::update_version = uv;
        return Write (); // write also reads the configuration and updates it
    }

    /**
     * Process update actions needed before packages update starts
     */
    global define void PreUpdate () {
	y2milestone ("Running bootloader pre-update stuff");
    }

/**
 * Function find partition for activating
 * it is special for activating partition for XEN
 * @return map disk and number of partition for activating
 */

define map<string, string> getXenPartitionForActivating()
{    
    map mp = Storage::GetMountPoints();

    map<string, string> ret = $[];

    list mountdata_boot = mp["/boot"]:(mp["/"]:[]);
    list mountdata_root = mp["/"]:[];

    // prepare return value
    ret["disk"] = mountdata_boot[2]:"";
    ret["number_partition"] = deletechars(mountdata_boot[0]:"", mountdata_boot[2]:"");

    y2milestone( "mountPoints %1", mp );
    y2milestone( "mountdata_boot %1", mountdata_boot );

    string root_device = mp["/", 0]:"";

    if (root_device == "")
    {
	y2error ("No mountpoint for / !");
	ret["disk"] = "";
    }
    y2milestone("XEN disk and number of partition for activating %1", ret);
    return ret;

}


    /**
      * Write bootloader settings to disk
      * @return boolean true on success
      */
    global define boolean Write () {
	boolean ret = true;

	// proposing anything is irrelevant during update, this forces reading
	// if settings weren't read before
	if (Mode::update ())
	{
	    BootCommon::was_proposed = false;
	    BootCommon::changed = true;
	    BootCommon::location_changed = true;
	    BootCommon::getLoaderType (! repeating_write);
	}

	if (repeating_write)
	    BootCommon::was_read = true;
	else
	    ReadOrProposeIfNeeded ();

	if (BootCommon::write_settings["save_all"]:false)
	    BootCommon::save_all = true;
	if (BootCommon::save_all)
	{ // force saving everything
	    BootCommon::changed = true;
	    BootCommon::location_changed = true;
	    Initrd::changed = true;
	}

	y2milestone ("Writing bootloader configuration");

	// run Progress bar
        list<string> stages = [
            // progress stage, text in dialog (short)
            _("Create initrd"),
            // progress stage, text in dialog (short)
            _("Save boot loader configuration files"),
            // progress stage, text in dialog (short)
            _("Install boot loader"),
        ];
        list<string> titles = [
            // progress step, text in dialog (short)
            _("Creating initrd..."),
            // progress step, text in dialog (short)
            _("Saving boot loader configuration files..."),
            // progress step, text in dialog (short)
            _("Installing boot loader..."),
        ];
        // progress bar caption
        if (Mode::normal ())
	{
	    // progress line
            Progress::New (_("Saving Boot Loader Configuration"),
                " ", 2, stages, titles, "");
	    Progress::NextStage ();
	}
        else
        {
            Progress::Title (titles[0]:"");
        }

	map<string,any> params_to_save = $[];

	string new_vga = getKernelParam (getDefaultSection (), "vga");
	if (new_vga != old_vga && new_vga != "false" && new_vga != "")
	{
	    Initrd::setSplash (new_vga);
	    if (Stage::initial ())
		params_to_save["vga"] = new_vga;
	}

	// Initialize device mapper and LVM in target system
	if (Stage::initial () || Mode::update ())
	{
	    // FIXME: should be handled by partitioner
	    map out = (map)SCR::Execute (.target.bash_output,
		"test -f /sbin/devmap_mknod.sh && /sbin/devmap_mknod.sh;" +
		"test -f /sbin/vgscan && /sbin/vgscan --mknodes"
	    );
	    if (out["exit"]:0 != 0)
	    {
		y2error ("Failed to initialize device mapper");
	    }
	    y2milestone ("Device mapper and LVM initialization output: %1", out);
	}

	// save initrd
	if ((Initrd::changed || ! Mode::normal ())
	    && ! (BootCommon::write_settings["forbid_save_initrd"]:false))
	{
	    string vga = getKernelParam (getDefaultSection (), "vga");
	    if (vga != "false" && vga != "")
	    {
		Initrd::setSplash (vga);
		if (Stage::initial ())
		    params_to_save["vga"] = new_vga;
	    }
	    ret = Initrd::Write ();
	    BootCommon::changed = true;
	}
	if (! ret)
	    y2error ("Error occurred while creating initrd");

	if (Mode::commandline ())
	    BootCommon::changed = true;

	if (! (BootCommon::changed
	    || BootCommon::write_settings["initrd_changed_externally"]:false))
	{
	    y2milestone ("No bootloader cfg. file saving needed, exiting");
//	    return true;
	}

	if (Mode::normal ())
	    Progress::NextStage ();
	else
        {
	    if (! repeating_write)
		Progress::NextStep ();
            Progress::Title (titles[1]:"");
        }

	// Write settings to /etc/sysconfig/bootloader
	y2milestone ("Saving configuration files");
	string lt = getLoaderType ();

        SCR::Write (.sysconfig.bootloader.LOADER_TYPE, lt);
//        SCR::Write (.sysconfig.bootloader.LOADER_LOCATION,
//            BootCommon::location);
// FIXME
	SCR::Write (.sysconfig.bootloader, nil);

	params_to_save["additional_failsafe_params"]
	    = BootCommon::GetAdditionalFailsafeParams ();
	params_to_save["installation_kernel_params"] = Kernel::GetCmdLine ();
	if (Stage::initial ())
	{
	    SCR::Write (.target.ycp, "/var/lib/YaST2/bootloader.ycp",
		params_to_save);
	}

	if (getLoaderType () == "none")
	{
	    // bnc #380982 - pygrub cannot boot kernel
	    // added activation for boot partition in XEN or root if boot partition doesn't exist
	    // it handles only the 1.- 4. partition other should be ignored
	    if (Arch::is_uml () || Arch::is_xenU())
    	    {
		y2milestone("Activating partition for XEN");
		map<string, string> active_disk = getXenPartitionForActivating();
		if ((active_disk["disk"]:"" != "") && (active_disk["number_partition"]:"" != "")
		   && (tointeger(active_disk["number_partition"]:"") < 5))
		{
		    string command = sformat
			("/usr/sbin/parted -s %1 set %2 boot on",active_disk["disk"]:"" , active_disk["number_partition"]:"");
		    y2milestone ("Running command %1", command);
		    map out = (map)SCR::Execute (.target.bash_output, command);
		    y2milestone ("Command output: %1", out);

		} else {

		    y2error("Finding partition for activating fault: %1", active_disk);
		}
		
 	    }
	    return ret;
	}


       // F#300779 - Install diskless client (NFS-root) 
       // kokso: additional warning that root partition is nfs type -> bootloader will not be installed

       // B#355332 - Bootloader doesn't work if root partitions is like nfs

        map dev = Storage::GetDiskPartition(BootCommon::BootPartitionDevice);
        
        if (dev["disk"]:"" == "/dev/nfs")       
        {
	   y2milestone("Bootloader::Write() -> Boot partition is nfs type, bootloader will not be installed.");
           return ret;

        }

        // F#300779 -end
	// update graphics menu where possible
	UpdateGfxMenu ();

	// save bootloader settings
	boolean reinit = ! (Mode::update () || Mode::normal ());
	y2milestone ("Reinitialize bootloader library before saving: %1",
	    reinit);
	ret = blSave (true, reinit, true) && ret;
	if (! ret)
	    y2error ("Error before configuration files saving finished");

        if (Mode::normal ())
            Progress::NextStage ();
        else
        {
	    if (! repeating_write)
		Progress::NextStep ();
            Progress::Title (titles[2]:"");
        }

	// call bootloader executable
	y2milestone ("Calling bootloader executable");
	ret = ret && blWrite ();

    if (! ret)
    {
	    y2error ("Installing bootloader failed");
	    if (writeErrorPopup ())
	    {
		repeating_write = true;
		map res = (map)WFM::call( "bootloader_proposal", ["AskUser",
		    $[ "has_next": false]]);
		if (res["workflow_sequence"]:nil == `next)
		{
		    return Write ();
		}
	    }
    }
    else
    {
	if (BootCommon::InstallingToFloppy ())
	{
	    BootCommon::updateTimeoutPopupForFloppy
		(BootCommon::getLoaderName (getLoaderType (), `summary));
	}


    }
    return ret;
}

// write mode settings function

    /**
      * Set settings how to write bootloader
      * @param settings map of settings
      */
    global define void SetWriteMode (map<string,any> settings) {
	y2milestone ("Setting mode for writing: %1", settings);
	foreach (string k, any v, settings, {
	    BootCommon::write_settings[k] = v;
	});
    }

// sections handling functions

/**
  * Resolve a single symlink in key image_key in section map s
  * @param section map map of section to change
  * @param image_key string key in section that contains the link
  * @return section map of the changed section
  */
global define map<string,any> ResolveSymlink(map<string,any> section, string key) {
    // The "-m" is needed in case the link is an absolute link, so that it does
    // not fail to resolve when the root partition is mounted in
    // Installation::destdir.
    string readlink_cmd = "/usr/bin/readlink -n -m " + Installation::destdir;
    map out = $[];
    string newval = "";

    // FIXME: find out why we need WFM::Execute() here (as olh used it above)
    out = (map) WFM::Execute (.local.bash_output, readlink_cmd + section[key]:"");
    if ( out["exit"]:0 == 0 && out["stdout"]:"" != "" ) {
	newval = substring(out["stdout"]:"", size(Installation::destdir));
	y2milestone("section %1: converting old %2 parameter from %3 to %4",
	    section["name"]:"", key, section[key]:"", newval);
	section[key] = newval;
    } else {
	y2error ("section %1: failed to remap %2 parameter",
	    section["name"]:"", key);
    }

    return section;
//  y2milestone("old kernel parameter in section %1: %2", s["name"], s["kernel"]);
//  s["kernel"] = SCR::Execute (.target.bash, "/usr/bin/readlink " + s["kernel"]);
//  y2milestone("converted kernel parameter to: %2", s["kernel"]);
}

/**
  * Resolve symlinks in kernel and initrd paths, for existing linux, xen and
  * failsafe sections
  */
// FIXME: this is the plan B solution, try to solve plan A in
//        BootCommon.ycp:CreateLinuxSection() (line 435)
global define void ResolveSymlinksInSections() {
    list image_key_names = ["kernel", "image"];
    string image_key_name = "";
    integer i = 0;

    y2milestone("sections before remapping: %1", BootCommon::sections);

    // change only linux, failsafe and xen sections
    BootCommon::sections = maplist (map<string,any> s, BootCommon::sections, {
	// skip sections that are not linux, xen or failsafe,
	// or that are not of type "image" (or "xen" <- needed?)
	if ( !contains ( ["linux", "xen", "failsafe"] , s["original_name"]:"") ||
	     !contains ( ["image", "xen"] , s["type"]:"") ) {
	    y2milestone("section %1: not linux, xen or failsafe, skipping kernel and initrd remapping",
		s["name"]:"");
	    return s;
	}

	// first, resolve kernel link name
	i = 0;
	while ( i < size(image_key_names) ) {
	    image_key_name = image_key_names[i]:"";
	    // also skip sections that start with a grub device name
	    // "(hd0,7)/boot/vmlinuz", and are not on the default (currently
	    // mounted) boot partition
	    if ( haskey (s, image_key_name) ) {
		if ( !regexpmatch(s[image_key_name]:"", "^\(hd.*\)") ) {
		    s = ResolveSymlink(s, image_key_name);
		} else {
		    y2milestone("section %1: skipping remapping kernel symlink on other partition: %2",
			s["name"]:"", s[image_key_name]:"");
		}
	    }
	    i = i + 1;
	}
	// resolve initrd link name, but skip if it is on a non-default boot
	// partition (see above)
	if ( haskey (s, "initrd") ) {
	    if ( !regexpmatch(s["initrd"]:"", "^\(hd.*\)") ) {
		s = ResolveSymlink(s, "initrd");
	    } else {
		y2milestone("section %1: skipping remapping initrd symlink on other partition: %2",
		    s["name"]:"", s["initrd"]:"");
	    }
	}
	return s;
    });

    y2milestone("sections after remapping: %1", BootCommon::sections);
}

    /**
      * return default section label
      * @return string default section label
      */
    global define string getDefaultSection () {
	ReadOrProposeIfNeeded ();
	return BootCommon::globals["default"]:"";
    }

    /**
      * Get default section as proposed during installation
      * @return section that was proposed as default during installation,
      * if not known, return current default section if it is of type "image",
      * if not found return first linux section, if no present, return empty
      * string
      */
    global define string getProposedDefaultSection () {
	ReadOrProposeIfNeeded ();
	string defaultv = "";
	string first_image = "";
	string default_image = "";
	foreach (map<string,any> s, BootCommon::sections, {
	    string title = s["name"]:"";
	    if (s["kernel"]:nil != nil)
	    {
		if (first_image == "")
		    first_image = title;
		if (title == getDefaultSection ())
		    default_image = title;
	    }
	    if (defaultv == "" && s["original_name"]:"" == "linux")
		defaultv = title;
	});
	if (defaultv != "")
	    return defaultv;
	if (default_image != "")
	    return default_image;
	if (first_image != "")
	    return first_image;
	return "";
    }


    /**
      * get kernel parameters from bootloader configuration file
      * @param section string section title, use DEFAULT for default section
      * @param key string
      * @return string value, "false" if not present,
      * "true" if present key without value
      */
    global define string getKernelParam (string section, string key) {
	ReadOrProposeIfNeeded ();
	if (section == "DEFAULT")
	    section = getDefaultSection ();
	else if (section == "LINUX_DEFAULT")
	    section = getProposedDefaultSection ();
	if (section == nil)
	    return "";
	map params = (map)BootCommon::getAnyTypeAttrib("kernel_params",$[]);
	integer sectnum = -1;
	integer index = -1;
	foreach (map<string,any> s, BootCommon::sections, {
	    index = index + 1;
	    if (s["name"]:"" == section)
		sectnum = index;
	});
	if (sectnum == -1)
	    return "";
	string line = "";
	if (contains (["root", "vga"], key))
	    return BootCommon::sections[sectnum, key]:"false";
	else
	{
	    line = BootCommon::sections[sectnum, "append"]:"";
	    return BootCommon::getKernelParamFromLine (line, key);
	}
    }

    /**
      * List kernel parameters
      * @param section string section title, use DEFAULT for default section
      * @return a list of kernel parameters (in the form 'hdd=ide-scsi')
      */
    global define list<string> listKernelParams (string section) {
	ReadOrProposeIfNeeded ();
	if (section == "DEFAULT")
	    section = getDefaultSection ();
	else if (section == "LINUX_DEFAULT")
	    section = getProposedDefaultSection ();
	if (section == nil)
	    return [];
	integer sectnum = -1;
	integer index = -1;
	foreach (map<string,any> s, BootCommon::sections, {
	    index = index + 1;
	    if (s["name"]:"" == section)
		sectnum = index;
	});
	if (sectnum == -1)
	    return [];
	string line = BootCommon::sections[sectnum, "append"]:"";
        list<string> par = splitstring (line, " ");
        par = filter (string p, par, ``(p != ""));
	return par;
    }

    /**
      * Get list of bootloader sections
      * @param type symbol what sections to be returned
      *  `linux -> linux sections
      *  `other -> other sections
      *  `all   -> all sections
      * @return list of strings representing sections names
      */
    global define list getSectionsList (symbol type) {
	list<map<string,any> > sects = BootCommon::sections;
	if (type == `other)
	{
	    sects = filter (map<string,any> s, sects, ``(
		! haskey (s, "chainloader")
	    ));
	}
	else if (type == `linux)
	{
	    sects = filter (map<string,any> s, sects, ``(
		! haskey (s, "kernel")));
	}
	list<string> sects_titles = maplist (map<string,any> s, sects, ``(
	    s["name"]:""));
	sects_titles = filter (string s, sects_titles, ``(s != ""));
	return sects_titles;
    }


    /**
      * set kernel parameter to menu.lst
      * @param section string section title, use DEFAULT for default section
      * @param key string parameter key
      * @param value string value, "false" to remove key,
      *   "true" to add key without value
      * @return boolean true on success
      */
    global define boolean setKernelParam
	(string section, string key, string value)
    {
	if ((! Mode::config ()) && key == "vga" && (
	    Arch::s390 () || Arch::ppc ()
	))
	{
	    y2warning ("Kernel of this architecture does not support the vga parameter");
	    return true;
	}

	ReadOrProposeIfNeeded ();

	if (section == "DEFAULT")
	    section = getDefaultSection ();
	else if (section == "LINUX_DEFAULT")
	    section = getProposedDefaultSection ();
	if (section == nil)
	    return false;
        integer sectnum = -1;
        integer index = -1;
        foreach (map<string,any> s, BootCommon::sections, {
            index = index + 1;
            if (s["name"]:"" == section)
                sectnum = index;
        });
        if (sectnum == -1)
            return false;
	string slabel = "";
	if ((key == "vga" || key == "root") && (value == "true"))
	    return false;
	if (contains (["root", "vga"], key))
	{
	    if (value != "false")
	    {
		BootCommon::sections[sectnum, key] = value;
	    }
	    else
	    {
		BootCommon::sections[sectnum] = remove (
		    BootCommon::sections[sectnum]:$[], key);
	    }
	}
	else
	{
	    string line = BootCommon::sections [sectnum, "append"]:"";
	    line = BootCommon::setKernelParamToLine (line, key, value);
	    BootCommon::sections [sectnum, "append"] = line;
	}
	BootCommon::changed = true;
	boolean ret = true;
	return ret;
    }

    /**
      * Get currently used bootloader, detect if not set yet
      * @return string botloader type
      */
    global define string getLoaderType () {
	return BootCommon::getLoaderType (false);
    }

    /**
      * Set type of bootloader
      * Just a wrapper to BootCommon::setLoaderType
      * @param bootloader string type of bootloader
      */
    global define void setLoaderType (string bootloader) {
	BootCommon::setLoaderType (bootloader);
    }

    /**
      * Get root fs device
      * @return string root device
      */
    global define string getRootDevice () {
	ReadOrProposeIfNeeded ();
	return BootCommon::RootPartitionDevice;
    }

    /**
      * Set root fs device
      * @param device string root device
      */
    global define void setRootDevice (string device) {
	ReadOrProposeIfNeeded ();
	BootCommon::RootPartitionDevice = device;
    }

    /**
      * Get device containing /boot directory
      * @return string boot device
      */
    global define string getBootDevice () {
	ReadOrProposeIfNeeded ();
	return BootCommon::BootPartitionDevice;
    }

    /**
      * Set device containing /boot directory
      * @param device string boot device
      */
    global define void setBootDevice (string device) {
	ReadOrProposeIfNeeded ();
	BootCommon::BootPartitionDevice = device;
    }

    /**
      * Check whether settings were read or proposed, if not, decide
      * what to do and read or propose settings
      */
    global define void ReadOrProposeIfNeeded () {
        if (! (BootCommon::was_read || BootCommon::was_proposed))
        {
	    y2milestone ("Stage::initial (): %1, update: %2, config: %3",
		Stage::initial (), Mode::update (), Mode::config ());
	    if (Mode::config ())
	    {
		y2milestone ("Not reading settings in Mode::config ()");
		BootCommon::was_read = true;
		BootCommon::was_proposed = true;
	    }
	    else if (Arch::ia64 () && Mode::update ()
)// FIXME		&& BootELILO::efi_layout_changed)
	    { // recreate config on IPF from scratch - request by rw
		y2milestone ("Reproposing new configuration - IPF, EFI layout has changed");
		Propose ();
	    }
            else if (Stage::initial () && ! Mode::update ())
            {
                Propose ();
            }
            else
            {
		boolean progress_orig = Progress::set (false);
                Read ();
		Progress::set (progress_orig);
		if (Mode::update ())
		{
		    UpdateConfiguration ();
		    ResolveSymlinksInSections();
		    BootCommon::changed = true;
		    BootCommon::location_changed = true;
		}
            }
        }
    }

    /**
     * Update the language of GFX menu according to currently selected language
     * @return boolean true on success
     */
    global define boolean UpdateGfxMenu () {
	if (getLoaderType () != "lilo" && getLoaderType () != "grub")
	    return true;

	boolean ret = BootCommon::UpdateGfxMenuContents ();
	if (! Mode::normal ())
	    return true;
	if (getLoaderType () == "lilo")
	{
	  /*
	   * This is extreme boolshit, Bootloader::Library has to be called
	   */
	    string bl_command = "/sbin/lilo >> /var/log/YaST2/y2log_bootloader 2>&1";
	    boolean command_ret = 0 == SCR::Execute (.target.bash, bl_command);
	    if (! command_ret)
	    {
		y2error ("Execution of installation command failed");
		return false;
	    }
	}
	return ret;
    }

}
