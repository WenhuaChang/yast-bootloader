/**
 * File:
 *      modules/BootPOWERLILO.ycp
 *
 * Module:
 *      Bootloader installation and configuration
 *
 * Summary:
 *      Module containing specific functions for LILO configuration
 *      and installation
 *
 * Authors:
 *      Jiri Srain <jsrain@suse.cz>
 *      Joachim Plack <jplack@suse.de>
 *
 * $Id$
 *
 */

{
module "BootPOWERLILO";

textdomain "bootloader";

import "Arch";
import "BootCommon";
import "Kernel";
import "Mode";
import "Pkg";
import "Storage";

/**
 * map of global options and types
 */
global map<string,any> global_options = $[];

/**
 * map of section options and types
 */
global map<string,any>   section_options = $[];

/**
 * map of other exported information
 */
global map<string,any>   exports = $[];


/*
 * include ppc specific help messages
 */
include "bootloader/ppc/helps.ycp";

/*
 * read my dialogs
 */
include "bootloader/ppc/dialogs.ycp";

void extract_exports() {
   // Extract exports from globals
    foreach(string key, any value, BootCommon::globals, {
        if (substring (key, 0, size ("__exports__")) != "__exports__")
            continue;
        // FIXME: delete(BootCommon::globals[key]);

        key = substring(key, size("__exports__"));

        if (substring (key, 0, 1) == "%") {
            list<string> s = splitstring(key,"%");
            string hash = s[1]:"";

            key = substring(key, 2 + size(hash));
            if (hash == "global_options") {
                global_options[key] = value;
            }
            else if (hash == "section_options") {
                section_options[key] = value;
            }
            else {
                if ( !haskey(exports, hash) ) exports[hash] = $[];
                exports[hash, key] = value;
            }
        }
        else if (substring (key, 0, 1) == "#") {
            list<string> s = splitstring(key,"#");
            string array = s[1]:"";

            key = substring(key, 2 + size(array));
            if ( ! haskey(exports, array) ) exports[array] = [];
            exports[array, tointeger(key)] = value;
        }
        else {
            exports[key] = value;
        }
    });
}

/**
  * Propose the location of the root device on disk and the boot device (if
  * any), according to the subarchitecture.
  * Results are stored in global variables.
  *
  */
global void LocationProposal () {
    // get map of lists: mountpoint -> [partitionName, fsid, targetdevice, raid_type]
    map mp = Storage::GetMountPoints();

    y2milestone( "mountPoints %1", mp );

    BootCommon::RootPartitionDevice = mp["/", 0]:"";
    if (BootCommon::RootPartitionDevice == "")
	y2error ("No mountpoint for / !!");
    else
	y2milestone("Root partition is %1", BootCommon::RootPartitionDevice);

    string arch = exports["arch"]:"chrp";
    if ( arch == "chrp" ) {
	// FIXME: really detect the boot partition (instead of leaving this to
	// lilo), see /lib/lilo/lilo-chrp.lib:76 (ie. GoodPrepOrFatPartition()
	// functionality)
	BootCommon::BootPartitionDevice =
	    regexpsub (BootCommon::RootPartitionDevice, "^(.*[^0-9])[0-9]*", "\\1");
	if (BootCommon::BootPartitionDevice == nil)
	    BootCommon::BootPartitionDevice = BootCommon::RootPartitionDevice;

	y2milestone("Boot partition is %1", BootCommon::BootPartitionDevice);
    }

/*
    // FIXME: create code for the cases below
    else if ( arch == "prep" ) {
        boot_map = $[
	    "boot_prep_custom"   :  GoodPrepPartition(BootCommon::RootPartitionDevice),
	];
    }
    else if ( arch == "pmac" ) {
        boot_map = $[
	    "boot_pmac_custom" : GoodHFSBootPartition(BootCommon::RootPartitionDevice),
        ]
    }
    else if ( arch == "iseries" ) {
        boot_map = $[
	    "boot_slot" 	 : "B",
            "boot_file" 	 : "/tmp/suse_linux_image",
	    "boot_iseries_custom": GoodPRePPartitionOnVDisk(BootCommon::RootPartitionDevice),
	 ];
    }
*/
}

// FIXME: evaluate partitions from Storage with the algorithm used in lilo to
// find a good prep or fat partition
global string GoodPrepOrFatPartition (string rootpartitiondev) {
    string bootpartitiondev = regexpsub (rootpartitiondev, "^(.*[^0-9])[0-9]*", "\\1");
    bootpartitiondev = bootpartitiondev != nil ? bootpartitiondev : rootpartitiondev;
    y2milestone("bootpartitiondev is %1", bootpartitiondev);
    return bootpartitiondev;
}

/**
 * Propose sections to bootloader menu
 * modifies internal sreuctures
 */
global void CreateSections () {
    // FIXME: use that bogus i386ism function no longer, works for now
    map<string,any> linux = BootCommon::CreateLinuxSection ("linux");

    // FIXME: I hate that i386 crap!!
    if (haskey(linux, "kernel")) {
        linux["image"] = linux["kernel"]:"boot/vmlinux";
        linux = remove(linux, "kernel");
    };

    // FIXME: create an 'other' section for MACs to boot MacOS

    BootCommon::sections = [ linux, ];
}

/**
 * Propose global options of bootloader
 * modifies internal structures
 */
global void CreateGlobals () {
    // FIXME: for iseries there are typically more than one boot option;
    //	  boot = B
    //	  boot = /dev/iseries/vda1
    //	  boot = /boot/suse_linux_bootfile

    BootCommon::globals = $[
	"activate": "true",
	"default" : BootCommon::sections[0, "name"]:"",
	"timeout" : "80",
    ];

    string arch = exports["arch"]:"chrp";
    map<string, string> boot_map = $[];

    y2milestone("RootPartDevice is %1",BootCommon::RootPartitionDevice);

    if ( arch == "chrp" ) {
        boot_map = $[
	    "boot_chrp_custom" : BootCommon::BootPartitionDevice,
        ];
    }
/*
    // FIXME: create code for the cases below
    else if ( arch == "prep" ) {
        boot_map = $[
	    "boot_prep_custom"   :  GoodPrepPartition(BootCommon::RootPartitionDevice),
	];
    }
    else if ( arch == "pmac" ) {
        boot_map = $[
	    "boot_pmac_custom" : GoodHFSBootPartition(BootCommon::RootPartitionDevice),
        ]
    }
    else if ( arch == "iseries" ) {
        boot_map = $[
	    "boot_slot" 	 : "B",
            "boot_file" 	 : "/tmp/suse_linux_image",
	    "boot_iseries_custom": GoodPRePPartitionOnVDisk(BootCommon::RootPartitionDevice),
	 ];
    }
*/
    BootCommon::globals = (map<string, string>) union(BootCommon::globals, boot_map);

}

// general functions

/**
  * Propose bootloader settings
  */
global define void Propose () ``{
    y2debug ("Started propose: Glob: %1, Sec: %2",
    	BootCommon::globals, BootCommon::sections);

    // Get root and boot partition (if any)
    LocationProposal();

    if (BootCommon::sections == nil || size (BootCommon::sections) == 0)
    {
        CreateSections ();  // make an initial proposal for at least one section
        BootCommon::kernelCmdLine = Kernel::GetCmdLine ();
    }
    else
    {
    	if (Mode::autoinst ())
    	{
	    y2debug ("Nothing to do in AI mode if sections exist");
    	}
    	else
	    BootCommon::FixSections (BootPOWERLILO::CreateSections);
    }

    if (BootCommon::globals == nil || size (BootCommon::globals) == 0)
    {
        CreateGlobals ();
    }
    else
    {
    	if (Mode::autoinst ())
    	{
	    y2debug ("Nothing to do in AI mode if globals are defined");
    	}
    	else
	    BootCommon::FixGlobals ();
    }

    y2milestone ("Proposed sections: %1", BootCommon::sections);
    y2milestone ("Proposed globals: %1", BootCommon::globals);
}


/**
  * Export bootloader settings to a map
  * @return bootloader settings
  */
global define map Export () ``{
    map exp = $[
		"global": BootCommon::globals,
		"sections" : BootCommon::sections,
		"activate" : BootCommon::activate,
	    ];
    return exp;
}


/**
  * Import settings from a map
  * @param settings map of bootloader settings
  * @return boolean true on success
  */
global define boolean Import (map settings) ``{
    BootCommon::globals = settings["global"]:$[];
    BootCommon::sections  = settings["sections"]:[];
    BootCommon::activate = settings["activate"]:false;
    return true;
}


/**
 * Read settings from disk
 * @return boolean true on success
 */
global boolean Read (boolean reread) {
    BootCommon::InitializeLibrary (reread, "ppc");
    if (reread)
    {
	BootCommon::ReadFiles ();
    }
    // Do we have to detect disks ?
    // in /src/routines/lilolike.ycp is usesless for PPC (calls FindMBRDisk)
    // BootCommon::DetectDisks ();

    boolean ret = BootCommon::Read (false);
    y2milestone (":: Read globals: %1", BootCommon::globals);

    extract_exports();

    return ret;
}


/**
 * Save all bootloader configuration files to the cache of the PlugLib
 * PlugLib must be initialized properly !!!
 * @param clean boolean true if settings should be cleaned up (checking their
 *  correctness, supposing all files are on the disk
 * @param init boolean true to init the library
 * @param flush boolean true to flush settings to the disk
 * @return boolean true if success
 */
global boolean Save (boolean clean, boolean init, boolean flush) {
    boolean ret = true;

    // FIXME: this is currently a copy from BootCommon::Save
    if (clean)
    {
	BootCommon::RemoveUnexistentSections ("", "");
	BootCommon::UpdateInitrdLine ();
	BootCommon::UpdateAppend ();
	// BootCommon::UpdateGfxMenu ();
    }

    if (! BootCommon::InitializeLibrary (init, "ppc"))
	return false;
    // Sanity check the sections list: we can only pass strings
    // through the perl interface
    list<map<string,string> > sects = maplist (map<string,any> s, BootCommon::sections, {
	return (map<string,string>)
	    filter (string k, any v, s, { return is (v, string); });
    });
    // ret = ret && BootCommon::SetDeviceMap (device_mapping);
    ret = ret && BootCommon::SetSections (sects);
    ret = ret && BootCommon::SetGlobal (BootCommon::globals);
    if (flush)
	ret = ret && BootCommon::FlushCache ();

    return ret;
}


/**
  * Display bootloader summary
  * @return a list of summary lines
  */
global define list<string> Summary () {

    string target_name = BootCommon::loader_device;
    list<string> result = [];

    // summary text, %1 is bootloader name
    result = add (result,
		  sformat (_("Boot loader type: %1"),
			   BootCommon::getLoaderName (BootCommon::getLoaderType (false), `summary)));

    // summary text for boot loader locations, sum up all locations to one string
    string boot_loader_locations = 
        mergestring(
	    filter( string bll,
		maplist( string key, any value, global_options, {
		    return (substring(key,0,5) == "boot_")
		            ? BootCommon::globals[key]:"" : "";
		}),
	        { return bll != ""; }
	    ),
	    ", "
	);
    result = add (result, sformat (_("Location: %1"), boot_loader_locations));

    list<string> sects = [];
    foreach (map<string,any> s, BootCommon::sections, {
        string title = s["name"]:"";
    	// section name "suffix" for default section
        string def = (title == BootCommon::globals["default"]:"")
	  ? _(" (default)")
	  : "";
        sects = add (sects, sformat ("%1%2", title, def));
    });
    // summary text. %1 is list of bootloader sections
    result = add (result, sformat (_("Sections: %1"),
        String::EscapeTags (mergestring (sects, ", "))));

    // FIXME: does the following code make any sense for ppc?
    if (BootCommon::loader_device == "/dev/null")
        // summary text
        result = add (result,
    		  _("Do not install boot loader; just create configuration files"));
    return result;
}


/**
 * Update read settings to new version of configuration files
 */
global void Update () {
    BootCommon::UpdateSections (true, BootCommon::CreateLinuxSection);
    BootCommon::UpdateGlobals ();
    BootCommon::loader_device
	= BootCommon::UpdateDevice (BootCommon::loader_device);
}

/**
  * Write bootloader settings to disk
  * @return boolean true on success
  */
global define boolean Write () {
    boolean ret = BootCommon::UpdateBootloader ();

    ret = ret && BootCommon::InitializeBootloader ();
    return ret;
}


global symbol WizardSequenzer() {
/*
blMainSequence () {
    map functions = getFunctions (BootCommon::getLoaderType (false));
    symbol () toEval = (symbol ())functions["wizard_sequencer"]:nil;
    if (toEval != nil)
	return toEval ();
    else
	return `generic;
*/
    y2milestone("Call PPC WizardSequenzer");
    return `generic_new;
}


global map<string,symbol()> Dialogs () {
    // PPC definitly needs other text modules
    return $[
	"loader"	: ppcBootLoaderOptionsDialog,
//	"installation"	: ppcInstallDetailsDialog,
    ];
}


/**
 * Return map of provided functions
 * @return map map of functions (eg. $["write":BootPOWERLILO::Write])
 */
global map<string, any> GetFunctions () {
    return $[
	"export"	   : Export,
	"import"	   : Import,
	"read"		   : Read,
	// "reset"
	"propose"	   : Propose,
	"save"		   : Save,
	"summary"	   : Summary,
	"update"	   : Update,
	"write"		   : Write,
	"widgets"	   : ppcWidgets,
	"wizard_sequencer" : WizardSequenzer,
	"dialogs"	   : Dialogs,
	"section_types"	   : section_types,
    ];
}

/**
  * Initializer of PowerLILO bootloader
  */
global void Initializer () {
    y2milestone ("Called PowerLILO initializer");
    BootCommon::current_bootloader_attribs = $[
	"propose" : true,
	"read" : true,
	"scratch" : true,
	"bootloader_on_disk" : true,
    ];
    BootCommon::help_messages = (map<string,string>)
        union(BootCommon::help_messages,
	      mapmap(string key, string val, ppc_help_messages,
		     { return $[ "ppc_" + key : val ]; }
		     )
	      );
    y2debug("Initialized help_messages to %1", BootCommon::help_messages);
    BootCommon::descriptions = (map<string,string>)
        union(BootCommon::descriptions,
	      mapmap(string key, string val, ppc_descriptions,
		     { return $[ "ppc_" + key : val ]; }
		     )
	      );
    y2debug("Initialized help_messages to %1", BootCommon::help_messages);
    // always read the config from perl-Bootloader as were piping our
    // type discription through here 
    // FIXME: This is a hack: we need another interface to get the
    // global and section options
    map<string,any> exports =
      filter(
	     string key, any v, BootCommon::GetGlobal(), {
	       return substring (key, 0, size ("__exports__")) == "__exports__";
	     });
    BootCommon::globals = union(BootCommon::globals, exports

    y2milestone ("Read exports into globals: %1", BootCommon::globals);
}

/**
  * Constructor
  */
global void BootPOWERLILO () {
    BootCommon::bootloader_attribs["ppc"] = $[
	"required_packages"	: ["lilo"],
	"loader_name"		: "ppc",
	"initializer"		: BootPOWERLILO::Initializer,
    ];
}


}
