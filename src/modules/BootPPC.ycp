/**
 * File:
 *      modules/BootPPC.ycp
 *
 * Module:
 *      Bootloader installation and configuration
 *
 * Summary:
 *      Module containing specific functions for PPC configuration
 *      and installation
 *
 * Authors:
 *      Jiri Srain <jsrain@suse.cz>
 *      Klaus Kaempf <kkaempf@suse.de>
 *      Anas Nashif <nashif@suse.de>
 *
 * $Id$
 *
 */

{
    module "BootPPC";

    textdomain "bootloader";

    import "Kernel";
    import "Storage";
    import "Arch";
    import "Installation";
    import "Mode";

    import "BootCommon";
    import "BootPPC";

    include "bootloader/ppc/misc.ycp";
    include "bootloader/ppc/prep.ycp";
    include "bootloader/ppc/chrp.ycp";
    include "bootloader/ppc/iseries.ycp";
    include "bootloader/routines/popups.ycp";
    include "bootloader/ppc/widgets.ycp";



    // ppc specific global settings

    // change the OpenFirmware variable 'boot-device' on CHRP or new PowerMacs
    global boolean  of_defaultdevice = true;

    // partition number for the bootloader (either 41PReP boot or Apple_HFS)
    // start with disabled value and let the partition scanner find a match.
    global string prep_boot_partition = "/dev/null";

    // map available of 41 PReP partitions, used on iSeries and CHRP
    global list prep_boot_partitions = [];

    // iSeries specific global settings

    // filename for the iSeries kernel, for streamfile *STMF booting
    global string   iseries_streamfile  = "/boot/suse_linux_bootfile";

    // write the install kernel to slot A, for rescue purpose
    global boolean  iseries_write_slot_a = false;

    // write the kernel to slot B
    global boolean  iseries_write_slot_b = false;

    // write the kernel to an 41 PReP boot partition
    global boolean  iseries_write_prepboot = false;

    // write the kernel to file, this must be transfered to OS/400
    global boolean  iseries_write_streamfile = false;

    // current board attribs
    global boolean prep_only_active = true;
    global boolean prep_only_hdx = true;
    global boolean prep_only_primary = true;
    global boolean prep_same_disk_as_root = true;
    global list table_items = [];



// general functions

    /**
      * Constructor
      */
    global define void BootPPC () ``{
        BootCommon::bootloader_attribs["ppc"] = $[
            "required_packages" : [],// FIXME
            "loader_name" : "yaboot",
            "initializer" : ``(BootPPC::Initializer()),
        ];
    }


    /**
      * Return map of provided functions
      * @return map map of functions (eg. $["write":``(BootPPC::Write ())])
      */
    global define map GetFunctions () ``{
	return $[
	    "read"	: ``(BootPPC::Read ()),
	    "reset"	: ``(BootPPC::Reset ()),
	    "propose"	: ``(BootPPC::Propose ()),
	    "save"	: ``(BootPPC::Save ()),
	    "update"	: ``(BootPPC::Update ()),
	    "write"	: ``(BootPPC::Write ()),
	    "widgets"	: ``(BootPPC::GetWidgets ()),
	    "getfiles"	: ``(BootPPC::GetFiles ()),
	    "setfiles"	: ``(BootPPC::SetFiles ()),
	];
    }

    /**
      * Initializer of LILO bootloader
      */
    global define void Initializer () ``{
	y2milestone ("Called PPC initializer");
	BootCommon::current_bootloader_attribs = $[
            "section_title" : "label",
            "kernel_key" : "image",
            "default_key" : "default",
            "default_type" : `label,
            "timeout_multiplier" : 10,
            "alias_keys" : ["alias"],
            "convert_function" : ``(BootPPC::convertSection ()),
            "kernel_params" : $[
                "vga" : "vga",
                "root" : "root",
                `other : "append",
            ],
            "propose" : true,
            "read" : true,
            "scratch" : true,
            "restore_mbr" : true,
            "key_only_once" : true,
            "bootloader_on_disk" : true,
	    "option_list" : GetOptions (),
	];
	BootCommon::cwm_options = union (
	    BootCommon::GetOptionMaps (),
	    BootPPC::GetOptionMaps ());
	BootCommon::cwm_widgets = union (
	    BootCommon::GetWidgetMaps (),
	    BootPPC::GetWidgetMaps ());
    }

    /**
      * Propose bootloader settings
      */
    global define void Propose () ``{
	boolean initial_propose = true;
	if (BootCommon::was_proposed)
	{
	    initial_propose = false;
	}
	else
	{
	    currentBoardInit ();
	}
        BootCommon::DetectDisks ();
	if (updatePrepBootPartitions () || prep_boot_partition == "")
	{
	    // TODO warning to user
	    choosePrepBootPartition ();
	}
        y2milestone("BootPPC::Proposal: BootCommon::loader_device %1", BootCommon::loader_device);

        if ( Arch::board_iseries )
        {
	    iSeriesPropose (initial_propose);
        }
        else if ( Arch::board_prep )
        {
	    PRePPropose (initial_propose);
        }
        else if ( Arch::board_chrp )
        {
	    CHRPPropose (initial_propose);
	}

        y2milestone("BootPPC::Proposal: BootCommon::loader_device %1", BootCommon::loader_device);

	if (BootCommon::sections == nil || size (BootCommon::sections) == 0)
	{
	    createSections ();
	    BootCommon::kernelCmdLine = Kernel::cmdLine;
	}
	else
	{
            if (Mode::autoinst)
            {
                // TODO whatever will be needed
            }
            else
		fixSections (disks_changed);
	}
	if (BootCommon::globals == nil || size (BootCommon::globals) == 0)
	{
	    createGlobals ();
	}
	else
	{
            if (Mode::autoinst)
            {
                // TODO whatever will be needed
            }
            else
		fixGlobals (disks_changed);
	}
    }

    /**
      * Read settings from disk
      * @return boolean true on success
      */
    global define boolean Read () ``{
	BootCommon::DetectDisks ();
	currentBoardInit ();
	updatePrepBootPartitions ();
        choosePrepBootPartition ();

	boolean ret = BootCommon::Read ();
	ret = currentBoardRead () && ret;
	BootCommon::finishReading ();
	return ret;
    }

    /**
      * Reset bootloader settings
      */
    global define void Reset () ``{
	BootCommon::Reset ();
	of_defaultdevice = true;
	iseries_streamfile = "/boot/suse_linux_bootfile";
	iseries_write_slot_a = false;
	iseries_write_slot_b = false;
	iseries_write_prepboot = false;
	iseries_write_streamfile = false;
	prep_boot_partitions = [];
	prep_boot_partition = "/dev/null";
	BootCommon::activate = true;
	currentBoardInit ();
    }

    /**
      * Save all bootloader configuration files
      * @return boolean true if success
      */
    global define boolean Save () ``{
        if (!( Arch::board_prep || Arch::board_chrp
	    || Arch::board_mac_new || Arch::board_iseries ))
	{
            return true;
	}
	boolean ret = currentBoardSave ();

        SCR::Execute (.target.bash, "test -f /etc/lilo.conf && /bin/cp /etc/lilo.conf /etc/lilo.conf.old");
        SCR::Execute (.target.bash, "/usr/bin/touch /etc/lilo.conf");

	BootCommon::liloRemoveUnexistentSections ("");
	BootCommon::liloUpdateInitrd ();
	BootCommon::liloUpdateAppend ();
	// iSeries can have multiple locations, are stored during
        // iSeriesSave ()
	if (! Arch::board_iseries )
	{
	    BootCommon::globals = modifySection (BootCommon::globals, "boot",
		BootCommon::loader_device);
	}
	ret = BootCommon::Save () && ret;
        SCR::Execute (.target.bash, "/bin/chmod 600 /etc/lilo.conf");
        return ret;
    }


    /**
      * Display bootloader summary
      * @return a list of summary lines
      */
    global define list(string) Summary () ``{
	list(string) ret = [];

	if ( Arch::board_iseries )
	{
	    ret = iSeriesSummary ();
	}
	else if ( Arch::board_prep )
	{
	    ret = PRePSummary ();
	}
	else if ( Arch::board_chrp )
	{
	    ret = CHRPSummary ();
	}
	// TODO modularize the rest when support exists
	else if ( Arch::board_mac_new )
	{
	    ret = [
		// summary part
		_("Boot configuration on new PowerMacs is not yet implemented.")
	    ];
	}
	else if ( Arch::board_mac_old )
	{
	    ret = [
		// summary part
		_("Configure the BootX App in classic MacOS to boot the file 'vmlinuz-oldworld'")
	    ];
	}
	else if ( Arch::board_mac_nubus )
	{
	    // summary part
	    ret = [ _("Use the Apple MkLinux Booter to boot the kernel.")];
	}
	else
	{
	    ret = [
		// summary part
		 _("Boot configuration for this board is not yet implemented.")
	    ];;
	}
	ret = prepend (ret, sformat (_("Board Type: %1"),
	    getNameOfCurrentBoard ()));
	y2milestone("BootPPC::Summary %1", ret);
	return ret;
    }

    /**
      * Update read settings to new version of configuration files
      */
    global define void Update () ``{
	updateSections (true);
	updateGlobals ();
    }

    /**
      * Write bootloader settings to disk
      * @return boolean true on success
      */
    global define boolean Write () ``{
	boolean ret = true;
	if (!( Arch::board_prep || Arch::board_chrp
	    || Arch::board_mac_new || Arch::board_iseries ))
	{
            return true;
	}

	boolean requires_initrd
	    = SCR::Read (.target.size, "/boot/initrd") != -1;

        string boot_device      = BootCommon::loader_device;
        string root_device      = BootCommon::RootPartitionDevice;

        if (Arch::board_iseries)
        {
	    iSeriesWrite (requires_initrd);
        }
        else if (Arch::board_prep)
        {
	    PRePWrite (requires_initrd);
        }
	else if (Arch::board_chrp)
	{
	    CHRPWrite (requires_initrd);
	}
	// TODO other subarchitectures

        if (BootCommon::activate)
	{
	    string bl_command = "/sbin/lilo --lilo-rootdrive "
		+ root_device + " >> /var/log/YaST2/y2loglilo 2>&1";
	    string bl_logfile = "/var/log/YaST2/y2loglilo";
	    ret = BootCommon::installBootLoader (bl_command, bl_logfile) && ret;
	}

        SCR::Execute(.target.bash, "/usr/lib/YaST2/bin/ppc_postinstall.sh " + boot_device + " " + root_device);

        return true;
    }

// end of mandatory functions
//----------------------------------------------------------------------------


    /**
      * Create linux section
      * @param title strign section title (linux, failsafe, memtest)
      * @return section description structure
      */
    global define list createLinuxSection (string title) ``{
	list section = [
	    $[ "key" : "image", "value" : "/boot/" + Kernel::binary ],
	    $[ "key" : "label", "value" : "linux" ],
	    $[ "key" : "root", "value" : BootCommon::RootPartitionDevice ],
	    $[ "key" : "initrd", "value" : "/boot/initrd" ],
	    $[ "key" : "append", "value" : Kernel::cmdLine ],
	    $[ "key" : "__intern__", "value" : $[
		"auto" : true,
		"changed" : false,
		"devs" : [BootCommon::RootPartitionDevice],
		"type" : title,
	    ]],
        ];
	return section;
    }

    /**
      * Propose sections to bootloader menu
      * modifies internal sreuctures
      * FIXME very similar to the one in BootLILO
      */
    global define void createSections () ``{
	list out = [
	    createLinuxSection ("linux")
	];
	list others = Storage::GetForeignPrimary();
	if (others != nil)
	{
	    if (size (others) > 0)
	    {
		integer index = 0;
		foreach (`o, others, ``{
		    index = index + 1;
		    list parts = splitstring (o, " ");
		    while (select (parts, 0, " ") == "")
			parts = remove (parts, 0);
		    string dev = select (parts, 0, "");
		    parts = remove (parts, 0);
		    string label = mergestring (parts, " ");
		    if (label == "")
		    {
			label = "macos";
			if (index != 0)
			{
			    label = sformat ("macos %1", index);
			}
		    }

		    // don't add rewritten location (#19990)
		    if (dev != "" && dev != BootCommon::loader_device)
		    {
			list m = [
			    $["key" : "label",
				"value" : translateSectionTitle (
				BootCommon::removeBlanks (label))],
			    $[ "key" : "other", "value" : dev],
			    $[ "key" : "__intern__", "value" : $[
				"auto" : true,
				"changed" : false,
				"devs" : [dev],
				"type" : label,
			     ]],
			];
			out = add (out, m);
		    }
		});
	    }
	}
	out = filter (`s, out, ``(s != $[] && s != nil));
	BootCommon::sections = out;
    }

    /**
      * Propose global options of bootloader
      * modifies internal structures
      */
    global define void createGlobals () ``{
	BootCommon::globals = [
	    $[ "key" : "default", "value" : "linux"],
	    $[ "key" : "timeout", "value" : 100],
	];
    }

    /**
      * Update sections of bootloader menu
      * modifies internal sreuctures
      * @param replace boolean true if old sectinos shall be replaced
      */
    global define void updateSections (boolean replace) ``{
	BootCommon::liloUpdateSections (replace);
    }

    /**
      * Update global options of bootloader
      * modifies internal sreuctures
      */
    global define void updateGlobals () ``{
    }

    /**
      * Fix sections of bootloader menu during proposal regeneration
      * modifies internal sreuctures
      * @param disks_changed boolean should be true if bootloader location
      *   relevant disk locations have changed
      */
    global define void fixSections (boolean disks_changed) ``{
	BootCommon::liloFixSections ();
    }

    /**
      * Fix global options of bootloader during proposal regeneration
      * modifies internal sreuctures
      * @param disks_changed boolean should be true if bootloader location
      *   relevant disk locations have changed
      */
    global define void fixGlobals (boolean disks_changed) ``{
	BootCommon::liloFixGlobals ();
    }

    /**
      * Create strings representing cfg. files for by-hand editation
      * @return map filename -> contents
      */
    global define map GetFiles() ``{
	currentBoardSave ();
        BootCommon::saveCfgFileToAgent ();
        return $[
            "/etc/lilo.conf" : SCR::Read (.lilo.tostring),
        ];
    }

    /**
      * Store strings representing cfg. files to internal structures
      * @param files map filename -> contents
      */
    global define void SetFiles (map files) ``{
	if (SCR::Read (.lilo.tostring) != files["/etc/lilo.conf"]:"")
	    BootCommon::files_edited = true;
        SCR::Write (.lilo.fromstring, files["/etc/lilo.conf"]:"");
        BootCommon::loadCfgFileFromAgent ();
	if (lookup_value (BootCommon::globals, "boot", "") != BootCommon::loader_device)
	    BootCommon::location = "custom";
	currentBoardRead ();
    }

    /**
      * Initialize the attribute of currently used board type
      */
    global define void currentBoardInit () ``{
        if (Arch::board_iseries)
        {
	    iSeriesInit ();
        }
        else if (Arch::board_prep)
        {
	    PRePInit ();
        }
        else if (Arch::board_chrp)
        {
	    CHRPInit ();
	}
	// TODO other boards
    }

    /**
      * Write the settings specific to current board
      * Cannot use SCR!!!
      */
    global define boolean currentBoardRead () ``{
	if ( Arch::board_iseries )
	{
	    return iSeriesRead ();
	}
	else if ( Arch::board_prep )
	{
	    return PRePRead ();
	}
	else if ( Arch::board_chrp )
	{
	    return CHRPRead ();
	}
	// TODO other boards

	return true;
    }

    /**
      * Read the settings specific to current board
      * Cannot use SCR!!!
      */
    global define boolean currentBoardSave () ``{
	if ( Arch::board_iseries )
	{
	    return iSeriesSave ();
	}
	else if ( Arch::board_prep )
	{
	    return PRePSave ();
	}
	else if ( Arch::board_chrp )
	{
	    return CHRPSave ();
	}
	// TODO other boards

	return true;
    }

}
