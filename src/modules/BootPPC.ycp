/**
 * File:
 *      modules/BootPPC.ycp
 *
 * Module:
 *      Bootloader installation and configuration
 *
 * Summary:
 *      Module containing specific functions for PPC configuration
 *      and installation
 *
 * Authors:
 *      Jiri Srain <jsrain@suse.cz>
 *      Klaus Kaempf <kkaempf@suse.de>
 *      Anas Nashif <nashif@suse.de>
 *
 * $Id$
 *
 */

{
    module "BootPPC";

    textdomain "bootloader";

    import "Kernel";
    import "Storage";
    import "Arch";
    import "Installation";
    import "Mode";

    import "BootCommon";
    import "BootPPC";

    include "bootloader/ppc/widgets.ycp";
    include "bootloader/ppc/misc.ycp";
    include "bootloader/routines/popups.ycp";



    // ppc specific global settings

    // change the OpenFirmware variable 'boot-device' on CHRP or new PowerMacs
    global boolean  ppc_of_defaultdevice = true;

    // partition number for the bootloader (either 41PReP boot or Apple_HFS)
    // start with disabled value and let the partition scanner find a match.
    global integer  ppc_boot_partition = 0;
    global integer  ppc_boot_partition_timestamp = 0;

    // filename for the iSeries kernel, for streamfile *STMF booting
    global string   ppc_iseries_streamfile              = "/boot/suse_linux_bootfile";

    // write the install kernel to slot A, for rescue purpose
    global boolean  ppc_iseries_write_slot_a            = true;

    // write the kernel to slot B
    global boolean  ppc_iseries_write_slot_b            = true;

    // write the kernel to an 41 PReP boot partition
    global boolean  ppc_iseries_write_prepboot          = true;

    // write the kernel to file, this must be transfered to OS/400
    global boolean  ppc_iseries_write_streamfile        = true;

    // list of widgets
    global list     ppc_iseries_widgets                 = [
                                                            `iseries_do_stmf,
                                                            `iseries_do_nwsstg,
                                                            `iseries_do_rescue_slot,
                                                            `iseries_do_kernel_slot
                                                          ];

    // map available of 41 PReP partitions, used on iSeries and CHRP
    global map      ppc_prep_boot_partitions = $[];

    // list of possible boot partitions, used in combobox
    global list     ppc_possible_boot_partitions = [];

// general functions

    /**
      * Constructor
      */
    global define void BootPPC () ``{
        BootCommon::bootloader_attribs["ppc"] = $[
            "section_title" : "label",
            "kernel_key" : "image",
            "required_packages" : [],// FIXME
            "loader_name" : "yaboot",
            "default_key" : "default",
            "default_type" : `label,
            "timeout_multiplier" : 10,
            "alias_keys" : ["alias"],
            "convert_function" : ``(BootPPC::convertSection ()),
            "kernel_params" : $[
                "vga" : "vga",
                "root" : "root",
                `other : "append",
            ],
            "propose" : true,
            "read" : true,
            "scratch" : true,
            "restore_mbr" : true,
            "key_only_once" : true,
            "bootloader_on_disk" : true,
        ];
    }


    /**
      * Return map of provided functions
      * @return map map of functions (eg. $["write":``(BootPPC::Write ())])
      */
    global define map GetFunctions () ``{
	return $[
	    "read" :	``(BootPPC::Read ()),
	    "reset" :	``(BootPPC::Reset ()),
	    "propose" : ``(BootPPC::Propose ()),
	    "save" :	``(BootPPC::Save ()),
	    "update" :	``(BootPPC::Update ()),
	    "write" :	``(BootPPC::Write ()),
	    "updoptlst":``(BootPPC::UpdateOptionsList ()),
	    "getoptions":``(BootPPC::GetOptions ()),
	    "widgets"  :``(BootPPC::GetWidgets ()),
	];
    }

    /**
      * Propose bootloader settings
      */
    global define void Propose () ``{
	if (BootCommon::was_proposed)
	{
	    return;
	}
        BootCommon::DetectDisks ();

        y2milestone("BootPPC::Proposal: BootCommon::location %1", BootCommon::location);
        y2milestone("BootPPC::Proposal: BootCommon::loader_device %1", BootCommon::loader_device);

        // probably the inital call
        if ( BootCommon::location == "mbr" )
        {
                if ( Arch::board_iseries )
                        BootCommon::location = "ppc_iseries";
                else if ( Arch::board_chrp )
                        BootCommon::location = "ppc_chrp"; // define it later
                else if ( Arch::board_prep )
                        BootCommon::location = "ppc_prep"; // define it later
                else if ( Arch::board_mac_new )
                        BootCommon::location = "ppc_chrp"; // define it later
                else if ( Arch::board_mac_old )
                        BootCommon::location = "ppc_mac_old"; // define it later
                else if ( Arch::board_mac_nubus )
                        BootCommon::location = "ppc_mac_nubus"; // define it later
                else
                        BootCommon::location = "ppc_undefined";
        }
        if ( Arch::board_iseries )
        {
                BootPPC::ppc_update_prep_boot_partitions ();

                // the last entry wins
                BootCommon::loader_device = "";
                if ( ppc_iseries_write_streamfile )
                {
                        BootCommon::loaderdevice = BootPPC::ppc_iseries_streamfile;
                }

                if ( ! (size (ppc_prep_boot_partitions) > 0 ) )
                        ppc_iseries_write_prepboot = false;

                if ( ppc_iseries_write_prepboot )
                {
                        BootCommon::loader_device = ppc_prep_boot_partitions[ppc_boot_partition]:"/dev/null";
                }

                if ( ppc_iseries_write_slot_b )
                {
                        BootCommon::loader_device = "B";
                }
                if ( !  ( ppc_iseries_write_prepboot ||
                          ppc_iseries_write_slot_b   ||
                          ppc_iseries_write_slot_a   ||
                          ppc_iseries_write_streamfile ) )
                {
                        BootCommon::activate = false;
                }

                y2milestone("prep_boot_partitions %1", ppc_prep_boot_partitions);
        }
        else if ( Arch::board_prep )
        {
                BootPPC::ppc_update_prep_boot_partitions ();

                if ( size (ppc_prep_boot_partitions) > 0)
                {
                        BootCommon::loader_device = ppc_prep_boot_partitions[ppc_boot_partition]:"/dev/null";
                }
        }
        else if ( Arch::board_chrp )
        {
                BootPPC::ppc_update_prep_boot_partitions ();

                if ( size (ppc_prep_boot_partitions) > 0)
                {
                        BootCommon::loader_device = ppc_prep_boot_partitions[ppc_boot_partition]:"/dev/null";
                }
        }

        y2milestone("BootCommon::location %1", BootCommon::location);
        y2milestone("BootPPC::Proposal: BootCommon::loader_device %1", BootCommon::loader_device);

	BootCommon::globals = [
	    $[ "key" : "default", "value" : "linux"],
	    $[ "key" : "timeout", "value" : 100],
	];

	BootCommon::sections = [
	    [
		$[ "key" : "image", "value" : "/boot/" + Kernel::binary ],
		$[ "key" : "label", "value" : "linux" ],
		$[ "key" : "root", "value" : BootCommon::RootPartitionDevice ],
		$[ "key" : "initrd", "value" : "/boot/initrd" ],
		$[ "key" : "append", "value" : Kernel::cmdLine ],
	    ]
	];
	string other_device = select (Storage::GetForeignPrimary(), 0, "");
	other_device = select (
	    filter (`d, splitstring (other_device, " "), ``(d != "")), 0, "");
	if (other_device != "")
	{
	    BootCommon::sections = add (BootCommon::sections, [
		$[ "key" : "label", "value" : "macos" ],
		$[ "key" : "other", "value" : other_device ],
	    ]);
	}
	// TODO set activate option -- maybe done above and should be done in Save only
    }

    /**
      * Read settings from disk
      * @return boolean true on success
      */
    global define boolean Read () ``{
	BootCommon::DetectDisks ();
	boolean ret = BootCommon::Read ();
	BootCommon::finishReading ();
// TODO read other sysconfig variables that will be needed
y2error ("Glob: %1, Sect: %2", BootCommon::globals, BootCommon::sections);
	return ret;
    }

    /**
      * Reset bootloader settings
      */
    global define void Reset () ``{
	BootCommon::Reset ();
	ppc_of_defaultdevice = true;
	ppc_boot_partition = 0;
	ppc_boot_partition_timestamp = 0;
	ppc_iseries_streamfile = "/boot/suse_linux_bootfile";
	ppc_iseries_write_slot_a = true;
	ppc_iseries_write_slot_b = true;
	ppc_iseries_write_prepboot = true;
	ppc_iseries_write_streamfile = true;
	ppc_prep_boot_partitions = $[];
	ppc_possible_boot_partitions = [];
	BootCommon::activate = true;
    }

    /**
      * Save all bootloader configuration files
      * @return boolean true if success
      */
    global define boolean Save () ``{
        if (!( Arch::board_prep || Arch::board_chrp
	    || Arch::board_mac_new || Arch::board_iseries ))
	{
            return true;
	}

        SCR::Execute (.target.bash, "test -f /etc/lilo.conf && /bin/cp /etc/lilo.conf /etc/lilo.conf.old");
        SCR::Execute (.target.bash, "/usr/bin/touch /etc/lilo.conf");

        BootCommon::sections = filter (`s, BootCommon::sections, ``{
            string label = lookup_value (s, "label", "");
            if (label == "")
                return false;
            if (! contains (["linux"], label))
                return true;

            string kernel = lookup_value (s, "image", "");
            if (kernel == "")
                return true;
            if (SCR::Read (.target.size, kernel) == -1)
                return false;
            return true;
        });
        BootCommon::sections = maplist (`s, BootCommon::sections, ``{
            string initrd = lookup_value ("initrd", "");
            string title = lookup_value (s, "label", "");
            if (initrd != "")
            {
                if (-1 == SCR::Read (.target.size, initrd))
                    s = modifySection (s, "initrd", nil);
            }
            else if ((title == "linux")
                && BootCommon::write_settings["insert_initrd"]:false)
            {
                initrd = "/boot/initrd";
                s = modifySection (s, "initrd", initrd);
            }
            if (title == "linux" && s["append"]:nil != nil
                && Mode::initial)
            {
                s = modifySection (s, "append", BootCommon::updateKernelParams (
                    lookup_value (s, "append", "")));
            }
            return s;
        });
        BootCommon::globals = modifySection (BootCommon::globals, "boot",
            BootCommon::loader_device);
        boolean ret = BootCommon::Save ();
        SCR::Execute (.target.bash, "/bin/chmod 600 /etc/lilo.conf");
        return ret;
    }


    /**
      * Display bootloader summary
      * @return a list of summary lines
      */
    global define list(string) Summary () ``{
	list(string) ret = [];

	if ( Arch::board_iseries )
	{
	    if ( ppc_iseries_write_streamfile )
	    {
		ret = add (ret, sformat (
		    // summary part
		    _("A stream file will be written to %1. Copy this file to OS400 side and boot with *STMF."),
		     BootPPC::ppc_iseries_streamfile));
	    }

	    if ( ppc_iseries_write_prepboot )
	    {
		ret = add (ret, sformat(
		    // summary part
		    _("The kernel will be written to %1. Use *NWSSTG on OS400 side."),
		     BootCommon::loader_device));
	    }

	    if ( ppc_iseries_write_slot_b )
	    {
		// summary part
		ret = add (ret, _("The kernel will be written to slot B."));
	    }

	    if ( ppc_iseries_write_slot_a )
	    {
		// summary part
		ret = add (ret, ("A rescue kernel will be written to slot A."));
	    }

	    if ( ppc_iseries_write_slot_a || ppc_iseries_write_slot_b )
	    {
		// summarry part
		ret = add (ret, _("This will take a while..."));
	    }
	    if ( BootCommon::activate == false )
	    {
		// summary part
		ret = [
		     _("No boot configuration. Configure booting manually.")
		];
	    }
	    if (! (ppc_iseries_write_prepboot || ppc_iseries_write_slot_b
		|| ppc_iseries_write_slot_a || ppc_iseries_write_streamfile))
	    {
		// summary part
		ret = [ _("No boot option selected.") ];
	    }
	    y2milestone("prep_boot_partitions %1", ppc_prep_boot_partitions);
	}
	else if ( Arch::board_prep )
	{
	    if ( size (ppc_prep_boot_partitions) > 0)
	    {
		ret = add (ret,
		    // summary part
		    _("The zImage.prep from CD1/boot must be written to a 41 PReP boot partition."));
	    }
	    else
	    {
		ret = add (ret,
		    // summary part
		    _("There is no 41 PReP boot partition. You cannot boot from the hard disk."));
	    }
	    if ( BootCommon::activate == false )
	    {
		ret = [
		    // summary part
		    _("No boot configuration. Configure booting manually.")
		];
	    }
	}
	else if ( Arch::board_chrp )
	{
	    if ( size (ppc_prep_boot_partitions) > 0)
	    {
		ret = add (ret, sformat(
		    // summary part
		    _("yaboot will be written to %1. Use SMS Multiboot to boot from this drive."),
		     BootCommon::loader_device));
	    }
	    else
	    {
		ret = add (ret,
		    // summary part
		    _("There is no 41 PReP boot partition. You cannot boot from the hard disk."));
	    }
	    if ( BootCommon::activate == false )
	    {
		ret = [
		    // summary part
		    _("No boot configuration. Configure booting manually.")
		];
	    }
	}

	else if ( Arch::board_mac_new )
	{
	    ret = [
		// summary part
		_("Boot configuration on new PowerMacs is not yet implemented.")
	    ];
	}
	else if ( Arch::board_mac_old )
	{
	    ret = [
		// summary part
		_("Configure the BootX App in classic MacOS to boot the file 'vmlinuz-oldworld'")
	    ];
	}
	else if ( Arch::board_mac_nubus )
	{
	    // summary part
	    ret = [ _("Use the Apple MkLinux Booter to boot the kernel.")];
	}
	else
	{
	    ret = [
		// summary part
		 _("Boot configuration for this board is not yet implemented.")
	    ];;
	}
	y2milestone("BootPPC::Summary %1", ret);
	return ret;
    }

    /**
      * Update read settings to new version of configuration files
      */
    global define void Update () ``{
    }
    /**
      * Write bootloader settings to disk
      * @return boolean true on success
      */
    global define boolean Write () ``{
        if (!( Arch::board_prep || Arch::board_chrp
	    || Arch::board_mac_new || Arch::board_iseries ))
	{
            return true;
	}

        string boot_device      = BootCommon::loader_device;
        string root_device      = BootCommon::RootPartitionDevice;
        // for MacOS 9/X partition or MacOS X ufs boot partition
        boolean lilo_activate   = BootCommon::activate;

        if (lilo_activate && Arch::board_iseries)
        {
                string ppc_iseries_bootbinary = "/boot/vmlinux64";
                if ( ppc_requires_initrd )
                {
                        ppc_iseries_bootbinary = "/tmp/vmlinux64.initrd";
                        SCR::Execute (.target.bash, "/bin/addRamDisk64 /boot/initrd $(rpm -ql kernel-iseries64 | grep ^/lib/modules/.\\\*/System.map$)  $(rpm -ql kernel-iseries64 | grep ^/lib/modules/.\\\*/vmlinux$) " + ppc_iseries_bootbinary + " >> /var/log/YaST2/y2loglilo_ppc_iseries_bootbinary 2>&1 " );
                }
                if ( ppc_iseries_write_slot_a )
                {
                        y2milestone("start writing rescue kernel to slot A ...");
                        SCR::Execute (.target.bash, "time dd if=`rpm -ql kernel-iseries64 | grep ^/boot | grep install | head -n1` of=/proc/iSeries/mf/A/vmlinux bs=4096 >>/var/log/YaST2/y2loglilo_iseries_slot_a 2>&1 ");
                        SCR::Execute (.target.bash, "echo 'start_shell manual=1 single' > /proc/iSeries/mf/A/cmdline");
                        y2milestone("done writing rescue kernel to slot A.");
                }
                if ( ppc_iseries_write_slot_b )
                {
                        if ( boot_device == "B" )
                        {
                        y2milestone("lilo will write the kernel to slot B. B is now activated");
                        SCR::Execute (.target.bash, "echo B > /proc/iSeries/mf/side");
                        }
                        else
                        {
                        y2milestone("start writing boot kernel to slot B ...");
                        SCR::Execute (.target.bash, "time dd if=" + ppc_iseries_bootbinary + " of=/proc/iSeries/mf/B/vmlinux bs=4096 >>/var/log/YaST2/y2loglilo_iseries_slot_b 2>&1 ");
                        SCR::Execute (.target.bash, "echo '" + root_device + " " + Kernel::cmdLine + "' > /proc/iSeries/mf/B/cmdline");
                        SCR::Execute (.target.bash, "echo B > /proc/iSeries/mf/side");
                        y2milestone("done writing boot kernel to slot B.");
                        }
                }
                if ( ppc_iseries_write_streamfile )
                {
                        y2milestone("create *STMF file %1 from %2", ppc_iseries_streamfile, ppc_iseries_bootbinary);
                        SCR::Execute (.target.bash, "cd / ; cp -av " + ppc_iseries_bootbinary + " " + ppc_iseries_streamfile);
                }
                if ( ppc_iseries_write_prepboot && size (ppc_prep_boot_partitions) > 0 )
                {
                        y2milestone("*NWSSTG: write %1 to %2", ppc_iseries_bootbinary, ppc_prep_boot_partitions[ppc_boot_partition]:"/dev/null");
                        SCR::Execute (.target.bash, "test -b " +
                        ppc_prep_boot_partitions[ppc_boot_partition]:"/dev/null" +
                        " && dd if=" + ppc_iseries_bootbinary + " bs=4096 of=" +
                        ppc_prep_boot_partitions[ppc_boot_partition]:"/dev/null"
                        );
                }

        }
        if (lilo_activate && Arch::board_prep)
        {
            // the PReP boot file (the kernel) is not in k_deflt.rpm
            // FIXME: this is one of the crudest hacks (cf #9718)
            WFM::Execute (.local.bash, "/bin/cp -pv " + Installation::sourcedir +
                        "/boot/mvlinuz-prep* /boot/zImage.prep");
            WFM::Execute (.local.bash, "/bin/cp -pv " + Installation::sourcedir +
                        "/boot/install-prep* /boot/zImage.initrd.prep");
        }
        if (lilo_activate)
                SCR::Execute(.target.bash, "/sbin/lilo --lilo-rootdrive " + root_device + ">>/var/log/YaST2/y2loglilo 2>>/var/log/YaST2/y2loglilo");

        SCR::Execute(.target.bash, "/usr/lib/YaST2/bin/ppc_postinstall.sh " + boot_device + " " + root_device);

        return true;
    }

// end of mandatory functions
//----------------------------------------------------------------------------

}
