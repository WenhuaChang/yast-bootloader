/**
 * File:
 *      modules/GfxMenu.ycp
 *
 * Module:
 *      Bootloader installation and configuration
 *
 * Summary:
 *      Routines to maintain translations in the graphical bootloader menu
 *
 * Authors:
 *      Jiri Srain <jsrain@suse.cz>
 *      Olaf Dabrunz <od@suse.de>
 *
 * $Id$
 *
 */

{
    module "GfxMenu";

    textdomain "bootloader";

    import "Mode";

    /**
     * Replace every match of given regular expression in a string with a
     * replacement string
     *
     * e.g. ReplaceRegexMatch( "abcdef12ef34gh000", "[0-9]+", "_A_" ) -> "abcdef_A_ef_A_gh_A_"
     *
     * @param input string that may contain substrings matching regex
     * @param regex regular expression to search for, must not contain brackets
     * @param repl  string that replaces every string of characters matching the regex
     * @return string that has matches replaced
     */
    global define string ReplaceRegexMatch(string input, string regex, string repl) ``{
	if(input == nil || size(input) < 1) return "";
	string rest = input;
	string output = "";
	if( regexpmatch( rest, regex ) )
	    {
	    list p = regexppos( rest, regex );
	    do
		{
		output = output +
			 substring( rest, 0, p[0]:0 ) +
		         repl;
		rest = substring( rest, p[0]:0+p[1]:0 );
		p = regexppos( rest, regex );
		}
	    while( size(p)>0 );
	    }
	return output + rest;
    }

    /**
      * Create translated name of a section
      * @param orig string original section name
      * @param allow_blanks boolean true if blanks are allowed in section name
      * @return translated section name
      */
    global define string translateSectionTitle (string orig, boolean allow_blanks)
    ``{
	//
	// FIXME: handling of bootloader-specific restrictions should be done
	// in perl-Bootloader
	//
        map trans = $[
	    // entry of bootloader menu - only a-z, A-Z, 0-9, _ and blank space
	    // are allowed, otherwise translartion won't be used
	    // try to keep short, may be shortened due to bootloader limitations
            "linux" : _("Linux"),
	    // entry of bootloader menu - only a-z, A-Z, 0-9, _ and blank space
	    // are allowed, otherwise translartion won't be used
	    // try to keep short, may be shortened due to bootloader limitations
            "failsafe" : _("Failsafe"),
	    // entry of bootloader menu - only a-z, A-Z, 0-9, _ and blank space
	    // are allowed, otherwise translartion won't be used
	    // try to keep short, may be shortened due to bootloader limitations
            "floppy" : _("Floppy"),
	    // entry of bootloader menu - only a-z, A-Z, 0-9, _ and blank space
	    // are allowed, otherwise translartion won't be used
	    // try to keep short, may be shortened due to bootloader limitations
            "hard disk" : _("Hard Disk"),
	    // entry of bootloader menu - only a-z, A-Z, 0-9, _ and blank space
	    // are allowed, otherwise translartion won't be used
	    // try to keep short, may be shortened due to bootloader limitations
            "memtest86" : _("Memory Test"),
	    // entry of bootloader menu - only a-z, A-Z, 0-9, _ and blank space
	    // are allowed, otherwise translartion won't be used
	    // try to keep short, may be shortened due to bootloader limitations
            "original MBR" : _("MBR before Installation"),
	    // entry of bootloader menu - only a-z, A-Z, 0-9, _ and blank space
	    // are allowed, otherwise translartion won't be used
	    // try to keep short, may be shortened due to bootloader limitations
            "previous" : _("Previous Kernel"),
	    // entry of bootloader menu - only a-z, A-Z, 0-9, _ and blank space
	    // are allowed, otherwise translartion won't be used
	    // try to keep short, may be shortened due to bootloader limitations
            "Vendor diagnostics" : _("Vendor Diagnostics"),
        ];
        map not_trans = $[
            "linux" : "Linux",
            "failsafe" : "Failsafe",
            "floppy" : "Floppy",
            "hard disk" : "Hard Disk",
            "memtest86" : "Memory Test",
            "original MBR" : "MBR before Installation",
            "windows" : "Windows",
	    "xen" : "XEN",
        ];
	string translated = trans[orig]:"\n"; // not allowed character
		// not_translated version will be used
	string filtered = filterchars (translated, "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890 _");
	if (size (filtered) != size (translated))
	{
	    y2warning ("Incorrect translation %1 -> %2", orig, translated);
	    return not_trans[orig]:orig;
	}
	// FIXME: find a better name: "! allow_blanks" really means that the bootloader is lilo
	if (! allow_blanks)
	{
	    y2milestone ("adapting section title for lilo: %1", filtered);
	    // label tag for lilo.conf has a restricted valid character set and
	    // limited allowed string length
	    string cutoff = "";

	    // Limit length to 11 characters, but keep it "nice"
	    // 1. cut off linux- prefix if found
	    if (size(filtered) > 11)
		filtered = regexpsub (filtered, "^[Ll][Ii][Nn][Uu][Xx]-", "");

	    while (size(filtered) > 11) {
		// 2. cut off last word, break if no more found
		cutoff = regexpsub (filtered, " [^ ]*$", "");
		if (size(cutoff) == size(filtered))
		    break;
		filtered = cutoff;
	    }
	    y2milestone ("section title for lilo without execess words: %1", filtered);

	    // 3. last resort: cutoff excess characters
	    filtered = substring (filtered, 0, 11);
	    y2milestone ("section title for lilo limited to 11 chars: %1", filtered);

	    // 4. convert not allowed chars to "_"
	    // (NOTE: this converts according to lilo requirements, ATM we do
	    // not allow ".-" above already; so ATM this converts only " ")
	    filtered = ReplaceRegexMatch (filtered, "[^a-zA-Z.-]", "_");
	    y2milestone ("section title for lilo: filtered unallowed characters: %1", filtered);
	}
	else if (contains (["linux", "failsafe", "previous", "xen"], orig)
	    && ! Mode::test ())
	{
	    import "Product";
	    string product = sformat ("%1 %2", Product::name, Product::version);
	    string prod_filtered = filterchars (product, "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890 _.");
	    if (product == prod_filtered && product != " ")
	    {
		if (orig == "linux")
		{
		    filtered = prod_filtered;
		}
		else
		{
		    filtered = sformat ("%1 -- %2", filtered, prod_filtered);
		}
	    }
	}
	return filtered;
    }

    /**
     * Get translated section names, including diacritics
     * @param allow_blanks boolean true if blanks are allowed in section name
     * @return a map section names translations
     */
    global define map<string,string> getTranslationsToDiacritics (boolean allow_blanks) ``{
        map<string,string> trans = $[
	    // entry of bootloader menu - only ISO 8859-1, -2 and -15 characters
	    // are allowed. Always remove the leading '_', its just to
	    // be able to have translations with and without diacritics
	    // please use diacritics here
            "linux" : _("_Linux"),
	    // entry of bootloader menu - only ISO 8859-1, -2 and -15 characters
	    // are allowed. Always remove the leading '_', its just to
	    // be able to have translations with and without diacritics
	    // please use diacritics here
            "failsafe" : _("_Failsafe"),
	    // entry of bootloader menu - only ISO 8859-1, -2 and -15 characters
	    // are allowed. Always remove the leading '_', its just to
	    // be able to have translations with and without diacritics
	    // please use diacritics here
            "floppy" : _("_Floppy"),
	    // entry of bootloader menu - only ISO 8859-1, -2 and -15 characters
	    // are allowed. Always remove the leading '_', its just to
	    // be able to have translations with and without diacritics
	    // please use diacritics here
            "hard disk" : _("_Hard Disk"),
	    // entry of bootloader menu - only ISO 8859-1, -2 and -15 characters
	    // are allowed. Always remove the leading '_', its just to
	    // be able to have translations with and without diacritics
	    // please use diacritics here
            "memtest86" : _("_Memory Test"),
	    // entry of bootloader menu - only ISO 8859-1, -2 and -15 characters
	    // are allowed. Always remove the leading '_', its just to
	    // be able to have translations with and without diacritics
	    // please use diacritics here
            "original MBR" : _("_MBR before Installation"),
	    // entry of bootloader menu - only ISO 8859-1, -2 and -15 characters
	    // are allowed. Always remove the leading '_', its just to
	    // be able to have translations with and without diacritics
	    // please use diacritics here
            "previous" : _("_Previous Kernel"),
	    // entry of bootloader menu - only ISO 8859-1, -2 and -15 characters
	    // are allowed. Always remove the leading '_', its just to
	    // be able to have translations with and without diacritics
	    // please use diacritics here
            "Vendor diagnostics" : _("_Vendor Diagnostics"),
	    "xen" : "XEN",
        ];
/*	trans = filter (string k, string v, trans, {
	    if (substring (v, 0, 1) == "_")
	    {
		y2warning ("Translation %1 contains leading underscore", v);
		return false;
	    }
	    return true;
	});*/
	trans = mapmap (string k, string v, trans, {
	    if (substring (v, 0, 1) == "_")
		v = substring (v, 1);
	    return $[ k : v ];
	});
	map<string,string> ret = mapmap (string k, string v, trans, {
	    string il1 = translateSectionTitle (k, allow_blanks);
	    if (contains (["linux", "failsafe", "previous", "xen"], k) && ! Mode::test ())
	    {
		import "Product";
		string product
		    = sformat ("%1 %2", Product::name, Product::version);
		if (product != " ")
		{
		    if (k == "linux")
		    {
			v = product;
		    }
		    else
		    {
			v = sformat ("%1 (%2)", product, v);
		    }
		}
	    }
	    return $[il1 : v];
	});
	return ret;
    }

/**
 * Update graphical bootloader to contain help text of current language
 * And make the selected installation language default
 * @param allow_blanks boolean true if blanks are allowed in section name
 * @return boolean true on success
 */
global define boolean UpdateGfxMenuContents (boolean allow_blanks) {
    y2milestone ("Updating GFX boot menu");
    if (SCR::Read (.target.size, "/boot/message") == -1)
	return true;
    if (SCR::Read (.target.size, "/etc/sysconfig/bootsplash") == -1)
	return true;
    // select the current language
    string main_lang = (string)SCR::Read (.sysconfig.language.RC_LANG);
    string langs = (string)
	SCR::Read (.sysconfig.language.INSTALLED_LANGUAGES);
    if (langs == nil)
	langs = "";
    list<string> languages = splitstring (langs, ",");
    languages = prepend (languages, main_lang);
    languages = filter (string l, languages, {return l != nil;});
    if (size (languages) == 0)
	return true;
    // check if theme is set
    string boot_theme = (string)SCR::Read (.sysconfig.bootsplash.THEME);
    if (boot_theme == nil)
    {
	return true;
    }
    // get available languages
    string data_dir = sformat ("/etc/bootsplash/themes/%1/bootloader",
	boot_theme);
    list<string> files = (list<string>)SCR::Read (.target.dir, data_dir);
    list<string> helps = filter (string f, files, {
	return regexpmatch (f, "\\.hlp$");
    });
    list<string> texts = filter (string f, files, {
	return regexpmatch (f, "\\.tr$");
    });
    helps = maplist (string h, helps, ``(substring (h, 0, 2)));
    texts = maplist (string t, texts, ``(substring (t, 0, 2)));
    y2milestone ("Texts available for %1", sort (texts));
    y2milestone ("Helps available for %1", sort (helps));
    string tmpdir = (string)SCR::Read (.target.tmpdir);
    string lang_params = "";

    list<string> selected = [];
    foreach (string lang, languages, {
	list<string> l = splitstring (lang, ".");
	lang = l[0]:"";
	y2milestone ("Selected language for booting menu: %1", lang);
	l = splitstring (lang, "_");
	string lang_short = l[0]:"";
	// check if lang is supported
	if (! (contains (helps, lang_short) || contains (texts, lang_short)))
	{
	    y2milestone ("Language %1 is not supported by gfxmenu", lang_short);
	}
	else if (! (contains (selected, lang)
		    || contains (selected, lang_short)))
	{
	    lang_params = sformat ("%1 %2 %3", lang_params, lang, lang_short);
	    selected = add (selected, lang);
	    selected = add (selected, lang_short);
	}
    });
    // update the boot message
    string trans_file = sformat ("%1/boot_translations", tmpdir);
    map<string,string> trans_map = getTranslationsToDiacritics (allow_blanks);
    list<string> trans_list = maplist (string k, string v, trans_map, {
	return sformat ("%1\n%2", k, v);
    });
    string trans_str = mergestring (trans_list, "\n");
    trans_str = trans_str + "\n";
    SCR::Write (.target.string, trans_file, trans_str);
    if (lang_params == "")
	lang_params = "en_EN en";
    string command = sformat (
	"/usr/lib/YaST2/bin/update_gfxmenu %1 %2 %3 %4",
	tmpdir, data_dir, trans_file, lang_params);

    y2milestone ("Runnign command %1", command);
    map ret = (map)SCR::Execute (.target.bash_output, command);
    y2milestone ("GFXMenu update result: %1", ret);
    return ret["exit"]:0 == 0;
}

/**
 * Updates GFX menu without requiring any information, reads loader type
 * from sysconfig, calls /sbin/lilo if LILO is being used directly
 * @return boolean true on success
 */
global boolean Update() {
    string loader = (string)SCR::Read (.sysconfig.bootloader.LOADER_TYPE);
    if (! UpdateGfxMenuContents (loader == "grub"))
	return false;

    if (loader == "lilo")
    {
	map out = (map)SCR::Execute (.target.bash_output, "/sbin/lilo");
	if (out["exit"]:0 != 0)
	{
	    y2error ("Output of /sbin/lilo: %1", out);
	    return false;
	}
    }
    return true;
}










} //end of module
