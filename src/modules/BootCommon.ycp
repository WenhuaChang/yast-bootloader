/**
 * File:
 *      modules/BootCommon.ycp
 *
 * Module:
 *      Bootloader installation and configuration
 *
 * Summary:
 *      Data to be shared between common and bootloader-specific parts of
 *      bootloader configurator/installator, generic versions of bootloader
 *      specific functions
 *
 * Authors:
 *      Jiri Srain <jsrain@suse.cz>
 *
 * $Id$
 *
 */

{
    module "BootCommon";

    import "Arch";

    import "Storage";

    textdomain "bootloader";

    include "bootloader/routines/misc.ycp";
    include "bootloader/routines/widgets.ycp";
    include "bootloader/routines/helps.ycp";
    include "bootloader/routines/lilolike.ycp";
    include "bootloader/routines/routines.ycp";

// common variables

    /**
      * type of bootloader to configuer/being configured
      * shall be one of "lilo", "grub", "silo", "milo", "aboot",
      * "elilo", "ppc", "s390", "mips"
      */
    string loader_type = nil;

// sysconfig variables

    /**
      * location description
      * on i386 can be mbr, root, boot, floppy, custom, none
      * other architectures may differ
      */
    global string location = "";

    /**
      * Device to install bootloader to
      */
    global string loader_device = "";

// installation proposal help variables

    /**
      * Last detection proposed to prefer lilo instead of grub
      */
    global boolean prefer_lilo = false;

// variables for storing data

    /**
      * list of section
      */
    global list sections = [];

    /**
      * map of global options and values
      */
    global list globals = [];

    /**
      * string sepresenting device name of /boot partition
      * same as RootPartitionDevice if no separate /boot partition
      */
    global string BootPartitionDevice = "";

    /**
      * string representing device name of / partition
      */
    global string RootPartitionDevice = "";
    /**
      * device holding MBR for bootloader
      */
    global string mbrDisk = "";
    /**
      * list of installed floppy devices
      */
    global list floppy_devices = nil;

// state variables

    /**
      * was the propose function called (== true)
      */
    global boolean was_proposed = false;
    /**
      * Were module settings read (== true)
      */
    global boolean was_read = false;
    /**
      * were settings changed (== true)
      */
    global boolean changed = false;
    /**
      * were sections settings changes (== true)
      */
    global boolean sections_changed = false;
    /**
      * was currently edited section changed (== true)
      */
    global boolean one_section_changed = false;
    /**
      * Was bootloader location changed? (== true)
      */
    global boolean location_changed = false;
    /**
      * Were configuration files manually edited and chamged?
      */
    global boolean files_edited = false;
    /**
      * Has been files edited warning already shown?
      */
    global boolean files_edited_warned = false;
    /**
      * Shall be settings saved when finishing bootloader configuration?
      */
    global boolean save_on_finish = true;
    /**
      * time of last change of partitioning
      */
    global integer partitioning_last_change = 0;

// saving mode setting functions

    /**
      * map of save mode settings
      */
    global map write_settings = $[];

// summary dialog state

    /**
      * Show verbose summary output
      */
    global boolean verbose = false;

// ui help variables

    /**
      * Curtrently edited section -- tmp store
      */
    global list current_section = [];
    /**
      * Name of currently edited section, `global for global section
      */
    global any current_section_name = `global;
    /**
      * Updated, but not yet confirmed sections -- tmp store
      */
    global list current_sections = [];
    /**
      * Updated, but not yet confirmed globals -- tmp store
      */
    global list current_globals = [];
    /**
      * Name of option, which is currently being edited in popup
      */
    global string current_option_name = "";
    /**
      * Index of current option in the section
      */
    global integer current_option_index = -1;

// other variables

    /**
      * Parameters of all bootloaders
      */
    global map bootloader_attribs = $[];
    /**
      * Parameters of currently used bootloader
      */
    global map current_bootloader_attribs = $[];
    /**
      * Settings of other bootloaders used when switching bootloader
      */
    global map other_bl = $[];
    /**
      * Option types for differnt bootloaders
      */
    global map opt_types = $[];
    /**
      * Kernel parameters at previous detection
      */
    global string kernelCmdLine = "";

// bootloader installation variables

    /**
      * Replace MBR with generic code after bootloader installation?
      */
    global boolean repl_mbr = false;
    /**
      * Activate bootloader partition during installation?
      */
    global boolean activate = false;
    /**
      * Save everything, not only changed settings
      */
    global boolean save_all = false;
    /**
      * Backup original MBR before installing bootloader
      */
    global boolean backup_mbr = false;

// generic versions of bootloader-specific functions

    /**
      * Export bootloader settings to a map
      * @return bootloader settings
      */
    global define map Export () ``{
        map exp = $[
		"global": globals,
		"sections" : sections,
		"repl_mbr" : repl_mbr,
		"activate" : activate,
	    ];
	return exp;
    }

    /**
      * Import settings from a map
      * @param settings map of bootloader settings
      */
    global define void Import (map settings) ``{
        globals = lookup(settings, "global", []);
        sections  = lookup(settings, "sections", []);
        repl_mbr = settings["repl_mbr"]:false;
        activate = settings["activate"]:false;
	return;
    }

    /**
      * Read settings from disk
      * @return boolean true on success
      */
    global define boolean Read () ``{
	SCR::Read (list2path ([getLoaderType (false), "reread"]));
	loadCfgFileFromAgent ();
	loader_device = lookup_value (globals, "boot", "/dev/null");
        return true;
    }

    /**
      * Reset bootloader settings
      */
    global define void Reset () ``{
        sections = [];
        globals = [];
//	DetectDisks ();
	repl_mbr = false;
	activate = false;
    }

    /**
      * Propose bootloader settings
      */
    global define void Propose () ``{
	y2error ("No generic propose function available");
    }
    /**
      * Save all bootloader configuration files
      * @return boolean true if success
      */
    global define boolean Save () ``{
	string bl = getLoaderType (false);
	if (bl == "s390")
	    bl = "zipl";
	saveCfgFileToAgent ();
	SCR::Write(list2path([bl]), nil);
	return true;
    }
    /**
      * Display bootloader summary
      * @return a list of summary lines
      */
    global define list(string) Summary () ``{
	map targetMap = Storage::GetTargetMap ();
	map boot_target = targetMap[loader_device]:$[];
	string target_name = "";
	if (boot_target == $[])
	    target_name = loader_device;
	else
	target_name = boot_target["name"]:"disk";

	list(string) result = [];
	// summary text, %1 is bootloader name (eg. LILO)
	result = add (result, sformat (_("Boot loader type: %1"),
		getLoaderName (getLoaderType (false))));
	// summary text, location is location description (eg. /dev/hda)
	result = add (result, sformat (_("Location: %1"), target_name));
	list(string) sects = [];
	foreach (`s, sections, ``{
	    string title = s[getSectionTitle ()]:"";
		// section name "suffix" for default section
	    string def = title == getDefaultSection () ? _(" (default)") : "";
	    sects = add (sects, sformat ("%1%2", title, def));
	});
	// summary text. %1 is list of bootloader sections
	result = add (result, sformat (_("Sections: %1"),
	    mergestring (sects, ", ")));
	if (loader_device == "/dev/null")
	    // summary text
	    result = add (result, _("Do not install boot loader -- just create
configuration files"));
	return result;
    }

    /**
      * Update read settings to new version of configuration files
      */
    global define void Update () ``{
    }

    /**
      * Write bootloader settings to disk
      * @return boolean true on success
      */
    global define boolean Write () ``{
	y2error ("No generic write possible");
	return false;
    }

    /**
      * Get map of bootloader options
      * @return map of options
      */
    global define map GetOptions () ``{
	map opts = $[
	    `global: [
	        "append",
	        "backup",
	        "boot",
	        "change-rules",
	        "compact",
	        "default",
	        "delay",
	        "disk",
	        "disktab",
	        "fix-table",
		"force-backup",
	        "ignore-table",
	        "install",
	        "lba32",
	        "linear",
	        "lock",
	        "map",
	        "menu-title",
	        "menu-scheme",
	        "message",
	        "nowarn",
	        "optional",
	        "password",
	        "prompt",
	        "restricted",
	        "serial",
	        "timeout",
	        "verbose",
	        "vga",
	    ],
	    "image" : [
	        "append",
	        "initrd",
	        "literal",
	        "ramdisk",
	        "read-only",
	        "read-write",
	        "root",
	        "vga",
	        "label",
	        "alias",
	        "lock",
	        "optional",
	        "password",
	        "restricted",
	    ],
	    "other" : [
	        "loader",
	        "table",
	        "change",
	        "map-drive",
	        "unsafe",
	        "label",
	        "alias",
	        "lock",
	        "optional",
	        "password",
	        "restricted",
	    ]
	];
	return opts;
    }

// end of generic versions of bootloader-specific functions
//-----------------------------------------------------------------------------

// functions for fetching settings to tmp map and storing back

    /**
      * Fetch settings to temporary variables
      * @return sumbol wizard sequencer symbol
      */
    global define symbol fetchSettings () ``{
	current_globals = eval(globals);
	current_sections = eval(sections);
	return `next;
    }

    /**
      * Store settings from temporary variables to globals
      * @return wizard sequencer symbol
      */
    global define symbol storeSettings () ``{
	globals = eval (current_globals);
	sections = eval (current_sections);
	loader_device = GetBootloaderDevice ();
	return `next;
    }

//-----------------------------------------------------------------------------
// common functions start

// bootloader type handling functions

    /**
      * Get currently used bootloader, detect if not set yet
      * @param recheck boolean force checking bootloader
      * @return string botloader type
      */
    global define string getLoaderType (boolean recheck) ``{
	if ((! recheck) && (loader_type != nil))
	    return loader_type;
	// read bootloader to use from disk
	if (Mode::update || Mode::normal || Mode::repair)
	{
	    loader_type = SCR::Read (.sysconfig.bootloader.LOADER_TYPE);
	    if (loader_type != nil && loader_type != "")
	    {
		y2milestone ("Sysconfig bootloader is %1, using", loader_type);
		current_bootloader_attribs
		    = bootloader_attribs[loader_type]:$[];
		return loader_type;
	    }
	    if (Mode::update)
	    {
		if (Arch::i386)
		{ // no sysconfig variable -> old version installed -> use LILO
		    loader_type = "lilo";
		    current_bootloader_attribs
			= bootloader_attribs[loader_type]:$[];
		    return loader_type;
		}
	    }
	}
	// detect bootloader
	loader_type = SCR::Read (.probe.boot_arch);
	y2milestone ("Bootloader detection returned %1", loader_type);
	if (loader_type == "grub" && Storage::UseLilo())
	{
	    loader_type = "lilo";
	    prefer_lilo = true;
	}
	else
	{
	    prefer_lilo = false;
	}

	y2milestone ("Detected bootloader %1", loader_type);
	current_bootloader_attribs = bootloader_attribs[loader_type]:$[];
	return loader_type;
    }
    /**
      * set type of bootloader
      * @param bootloader string type of bootloader
      */
    global define void setLoaderType (string bootloader) ``{
	if (contains(BootCommon::bootloaders, bootloader)
	    && ! Mode::test)
	{
	    // don't configure package maneger during autoinstallation preparing
	    if (! Mode::config)
	    {
		boolean installed = false;
		foreach (`p, getBootloaderPackages (bootloader), ``{
		    if (! Pkg::IsProvided (bootloader))
		    {
		        Pkg::PkgInstall (bootloader);
			installed = true;
		    }
		});
		if (installed && Mode::normal && ! Mode::config)
		{
		    Pkg::PkgSolve ();
		    Pkg::PkgCommit (0);
		    WFM::CallModule("inst_suseconfig", []);
		}
	    }
	}
	loader_type = bootloader;
	current_bootloader_attribs = bootloader_attribs[loader_type]:$[];
    }
    /**
      * List bootloaders available for configured architecture
      * @return list of bootloaders
      */
    global define list getBootloaders () ``{
	list ret = [getLoaderType (false)];
	if (Arch::i386 || Arch::x86_64)
	{
	    ret = merge (ret, ["lilo", "grub"]);
	}
	return toset (ret);
    }

}


