/**
 * File:
 *      modules/BootCommon.ycp
 *
 * Module:
 *      Bootloader installation and configuration
 *
 * Summary:
 *      Data to be shared between common and bootloader-specific parts of
 *      bootloader configurator/installator, generic versions of bootloader
 *      specific functions
 *
 * Authors:
 *      Jiri Srain <jsrain@suse.cz>
 *
 * $Id$
 *
 */

{
    module "BootCommon";

    import "Arch";

    import "Storage";

    textdomain "bootloader";

    include "bootloader/routines/misc.ycp";
    include "bootloader/routines/widgets.ycp";
    include "bootloader/routines/helps.ycp";
    include "bootloader/routines/lilolike.ycp";

// common variables

    /**
      * type of bootloader to configuer/being configured
      * shall be one of "lilo", "grub", "silo", "milo", "aboot",
      * "elilo", "ppc", "s390", "mips"
      */
    string loader_type = nil;

// sysconfig variables

    /**
      * location description
      * on i386 can be mbr, root, boot, floppy, custom, none
      * other architectures may differ
      */
    global string location = "";

    /**
      * Device to install bootloader to
      */
    global string loader_device = "";

// variables for storing data

    /**
      * list of section
      */
    global list sections = [];

    /**
      * map of global options and values
      */
    global map globals = $[];

    /**
      * string sepresenting device name of /boot partition
      * same as RootPartitionDevice if no separate /boot partition
      */
    global string BootPartitionDevice = "";

    /**
      * string representing device name of / partition
      */
    global string RootPartitionDevice = "";
    /**
      * device holding MBR for bootloader
      */
    global string mbrDisk = "";

// state variables

    /**
      * was the propose function called (== true)
      */
    global boolean was_proposed = false;
    /**
      * Were module settings read (== true)
      */
    global boolean was_read = false;
    /**
      * were settings changed (== true)
      */
    global boolean changed = false;
    /**
      * Was bootloader location changed? (== true)
      */
    global boolean location_changed = false;
    /**
      * Were configuration files manually edited and chamged?
      */
    global boolean files_edited = false;
    /**
      * Has been files edited warning already shown?
      */
    global boolean files_edited_warned = false;
    /**
      * Shall be settings saved when finishing bootloader configuration?
      */
    global boolean save_on_finish = true;
    /**
      * time of last change of partitioning
      */
    global integer partitioning_last_change = 0;

// saving mode setting functions

    /**
      * map of save mode settings
      */
    global map write_settings = $[];

// summary dialog state

    /**
      * Show verbose summary output
      */
    global boolean verbose = false;

// other variables

    /**
      * Settings of other bootloaders used when switching bootloader
      */
    global map other_bl = $[];

    /**
      * Option types for differnt bootloaders
      */
    global map opt_types = $[];

    /**
      * Map for temporary state storing
      */
    global map tmp_store = $[];

    /**
      * Map to remember what settings were changed
      */
    global map changed_settings = $[];
    /**
      * Kernel parameters at previous detection
      */
    global string kernelCmdLine = "";

// bootloader installation variables

    /**
      * Replace MBR with generic code after bootloader installation?
      */
    global boolean repl_mbr = false;

    /**
      * Activate bootloader partition during installation?
      */
    global boolean activate = true;

// generic versions of bootloader-specific functions

    /**
      * Export bootloader settings to a map
      * @return bootloader settings
      */
    global define map Export () ``{
        map exp = $[
		"global": globals,
		"sections" : sections,
	    ];
	return exp;
    }

    /**
      * Import settings from a map
      * @param settigns map of bootloader settings
      */
    global define void Import (map settings) ``{
        globals = lookup(settings, "global", $[]);
        sections  = lookup(settings, "sections", []);
	return;
    }
    /**
      * Read settings from disk
      * @return boolean true on success
      */
    global define boolean Read () ``{
	loadCfgFileFromAgent ();
	loader_device = globals["boot"]:"/dev/null";
        return true;
    }

    /**
      * Reset bootloader settings
      */
    global define void Reset () ``{
        sections = [];
        globals = $[];
//	DetectDisks ();
	repl_mbr = false;
	activate = true;
    }

    /**
      * Propose bootloader settings
      */
    global define void Propose () ``{
	y2error ("No generic propose function available");
    }
    /**
      * Save all bootloader configuration files
      * @return boolean true if success
      */
    global define boolean Save () ``{
	string bl = getLoaderType (false);
	saveCfgFileToAgent ();
	SCR::Write(list2path([bl]), nil);
	return true;
    }
    /**
      * Display bootloader summary
      * @return list of summary lines
      */
    global define list(string) Summary () ``{
	string default = BootCommon::getLoaderType (false) == "grub"
	    ? sections[globals["default"]:0, "title"]:sections[0, "title"]:""
	    : globals["default"]:sections[0, "label"]:"";
	map targetMap = Storage::GetTargetMap ();
	map boot_target = targetMap[loader_device]:$[];
	string target_name = "";
	if (boot_target == $[])
	    target_name = loader_device;
	else
	target_name = boot_target["name"]:"disk";

	list(string) result = [];
	result = add (result, sformat (_("Bootloader type: %1"),
		getLoaderName (getLoaderType (false))));
	result = add (result, sformat (_("Location: %1"), target_name));
	list(string) sects = [];
	foreach (`s, sections, ``{
	    string title = s[
		getLoaderType (false) == "grub" ? "title" : "label"
	    ]:"";
	    string def = title == default ? _(" (default)") : "";
	    sects = add (sects, sformat ("%1%2", title, def));
	});
	result = add (result, sformat (_("Sections: %1"),
	    mergestring (sects, ", ")));
	if (loader_device == "/dev/null")
	    result = add (result, _("Don't install bootloader, just create
configuration files"));
	return result;
    }

    /**
      * Update read settings to new version of configuration files
      */
    global define void Update () ``{
    }

    /**
      * Write bootloader settings to disk
      * @return boolean true on success
      */
    global define boolean Write () ``{
	y2error ("No generic write possible");
	return false;
    }

    /**
      * Get map of bootloader options
      * @return map of options
      */
    global define map GetOptions () ``{
	map opts = $[
	    `global: [
	        "append",
	        "backup",
	        "boot",
	        "change-rules",
	        "compact",
	        "default",
	        "delay",
	        "disk",
	        "disktab",
	        "fix-table",
		"force-backup",
	        "ignore-table",
	        "install",
	        "lba32",
	        "linear",
	        "lock",
	        "map",
	        "menu-title",
	        "menu-scheme",
	        "message",
	        "nowarn",
	        "optional",
	        "password",
	        "prompt",
	        "restricted",
	        "serial",
	        "timeout",
	        "verbose",
	        "vga",
	    ],
	    "image" : [
	        "append",
	        "initrd",
	        "literal",
	        "ramdisk",
	        "read-only",
	        "read-write",
	        "root",
	        "vga",
	        "label",
	        "alias",
	        "lock",
	        "optional",
	        "password",
	        "restricted",
	    ],
	    "other" : [
	        "loader",
	        "table",
	        "change",
	        "map-drive",
	        "unsafe",
	        "label",
	        "alias",
	        "lock",
	        "optional",
	        "password",
	        "restricted",
	    ]
	];
	return opts;
    }

// end of generic versions of bootloader-specific functions
//-----------------------------------------------------------------------------

// functions for fetching settings to tmp map and storing back

    /**
      * Fetch settings to temporary variables
      * @return sumbol wizard sequencer symbol
      */
    global define symbol fetchSettings () ``{
	tmp_store = $[];
	tmp_store["globals"] = eval(globals);
	tmp_store["sections"] = eval(sections);
	tmp_store["location"] = location;
	tmp_store["loader_device"] = loader_device;
	tmp_store["activate"] = activate;
	tmp_store["repl_mbr"] = repl_mbr;
	return `next;
    }

    /**
      * Store settings from temporary variables to globals
      * @return wizard sequencer symbol
      */
    global define symbol storeSettings () ``{
	globals = tmp_store["globals"]:$[];
	sections = tmp_store["sections"]:[];
	location = tmp_store["location"]:"";
	loader_device = tmp_store["loader_device"]:"";
	loader_device = GetBootloaderDevice ();
	repl_mbr = tmp_store["repl_mbr"]:false;
	activate = tmp_store["activate"]:false;
	return `next;
    }

//-----------------------------------------------------------------------------
// common functions start

// bootloader type handling functions

    /**
      * Get currently used bootloader, detect if not set yet
      * @param recheck boolean force checking bootloader
      * @return string botloader type
      */
    global define string getLoaderType (boolean recheck) ``{
	if ((! recheck) && (loader_type != nil))
	    return loader_type;
	// read bootloader to use from disk
	if (Mode::update || Mode::normal)
	{
	    loader_type = SCR::Read (.sysconfig.bootloader.LOADER_TYPE);
	    if (loader_type != nil && loader_type != "")
	    {
		y2milestone ("Sysconfig bootloader is %1, using", loader_type);
		return loader_type;
	    }
	}
	// detect bootloader
	loader_type = SCR::Read (.probe.boot_arch);
	y2milestone ("Bootloader detection returned %1", loader_type);
	if (loader_type == "grub" && Storage::UseLilo())
	    loader_type = "lilo";

	// this shall install packages if possible
	setLoaderType (loader_type);

	// this was wrong - storage, which initializes before package maneger,
	// needs calls this function
	// check bootloader package to be installed
/*	if ((Arch::i386 || Arch::x86_64) && (Mode::initial)){
	    if (loader_type == "grub" && ! Pkg::IsSelected ("grub"))
		loader_type = "lilo";
            if (loader_type == "lilo" && ! Pkg::IsSelected ("lilo"))
                loader_type = "grub";
	    if (loader_type == "grub" && ! Pkg::IsSelected ("grub"))
	    {
		// no bootloader is installed
		noBootloaderPopup ();
	    }
	}*/
	y2milestone ("Detected bootloader %1", loader_type);
	return loader_type;
    }
    /**
      * set type of bootloader
      * @param bootloader string type of bootloader
      */
    global define void setLoaderType (string bootloader) ``{
	if (contains(BootCommon::bootloaders, bootloader)
	    && ! Mode::test)
	{
	    if (Mode::normal)
	    {
		boolean installed = false;
		foreach (`p, getBootloaderPackages (bootloader), ``{
		    if (! Pkg::IsProvided (bootloader))
		    {
		        Pkg::PkgInstall (bootloader);
			installed = false;
		    }
		});
		if (installed)
		{
		    Pkg::PkgSolve ();
		    Pkg::PkgCommit (0);
		    WFM::CallModule("inst_suseconfig", []);
		}
	    }
	    else
	    {/* FIXME some checking must be added, this idea might be correct
		import "ForcedPackages";
		foreach (`b, bootloaders, ``{
		    foreach (p, getBootloaderPackages (b), ``{
			ForcedPackages::RemoveFromForceInstall (b);
		    });
		});
		foreach (`p, getBootloaderPackages (bootloader), ``{
		    ForcedPackages::RemoveFromForceNotInstall (p);
		    ForcedPackages::ForceInstall (p);
		});
	*/
	    }
	}
	loader_type = bootloader;
    }
    /**
      * List bootloaders available for configured architecture
      * @return list of bootloaders
      */
    global define list getBootloaders () ``{
	list ret = [getLoaderType (false)];
	if (Arch::i386)
	{
	    ret = merge (ret, ["lilo", "grub"]);
	}
	return toset (ret);
    }

}


