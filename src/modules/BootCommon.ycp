/**
 * File:
 *      modules/BootCommon.ycp
 *
 * Module:
 *      Bootloader installation and configuration
 *
 * Summary:
 *      Data to be shared between common and bootloader-specific parts of
 *      bootloader configurator/installator, generic versions of bootloader
 *      specific functions
 *
 * Authors:
 *      Jiri Srain <jsrain@suse.cz>
 *
 * $Id$
 *
 */

{
    module "BootCommon";

    textdomain "bootloader";

    import "Arch";
    import "HTML";
    import "Mode";
    import "Require";
    import "Storage";
    import "Pkg";

    /* These global variables and functions is needed in included files */

    /**
      * string sepresenting device name of /boot partition
      * same as RootPartitionDevice if no separate /boot partition
      */
    global string BootPartitionDevice = "";

    /**
      * string representing device name of / partition
      */
    global string RootPartitionDevice = "";

    /**
      * location description
      * on i386 can be mbr, root, boot, floppy, custom, none
      * other architectures may differ
      */
    global string location = "";

    /**
      * Parameters of currently used bootloader
      */
    global map<string, any> current_bootloader_attribs = $[];

    /**
      * Parameters of all bootloaders
      */
    global map<string, any> bootloader_attribs = $[];

    /**
      * Name of currently edited section, `global for global section
      */
    global any current_section_name = `global;

    /**
      * Curtrently edited section -- tmp store
      */
    global list<map> current_section = [];

    /**
      * map of global options and values
      */
    global list<map> globals = [];

    /**
      * Updated, but not yet confirmed globals -- tmp store
      */
    global list<map> current_globals = [];

    /**
      * list of section
      */
    global list<list<map> > sections = [];

    /**
      * list of installed floppy devices
      */
    global list<string> floppy_devices = nil;

    /**
      * Option types for differnt bootloaders
      */
    global map<string,map<string,string> > opt_types = $[];

    /**
      * device holding MBR for bootloader
      */
    global string mbrDisk = "";

    /**
      * Device to install bootloader to
      */
    global string loader_device = "";

    /**
      * was currently edited section changed (== true)
      */
    global boolean one_section_changed = false;

    /**
      * Backup original MBR before installing bootloader
      */
    global boolean backup_mbr = false;

    /**
      * Activate bootloader partition during installation?
      */
    global boolean activate = false;

    /**
      * Replace MBR with generic code after bootloader installation?
      */
    global boolean repl_mbr = false;

    /**
      * Kernel parameters at previous detection
      */
    global string kernelCmdLine = "";

    /**
      * were settings changed (== true)
      */
    global boolean changed = false;

    /**
      * Table/Popup options used by currently used bootloader
      */
    global map<string, any> cwm_options = $[];

// common variables

    /**
      * type of bootloader to configuer/being configured
      * shall be one of "lilo", "grub", "silo", "milo", "aboot",
      * "elilo", "ppc", "s390", "mips"
      */
    string loader_type = nil;

// sysconfig variables

// installation proposal help variables

    /**
      * Last detection proposed to prefer lilo instead of grub
      */
    global boolean prefer_lilo = false;

    /**
      * List of partitions deleted in primary proposal
      */
    global list<string> del_parts = [];

// variables for storing data


// saving mode setting functions

    /**
      * map of save mode settings
      */
    global map write_settings = $[];

// summary dialog state

    /**
      * Show verbose summary output
      */
    global boolean verbose = false;

// ui help variables

    /**
      * Updated, but not yet confirmed sections -- tmp store
      */
    global list<list<map> > current_sections = [];
    /**
      * Name of option, which is currently being edited in popup
      */
    global string current_option_name = "";
    /**
      * Index of current option in the section
      */
    global integer current_option_index = -1;

    global boolean redraw_table = false;
    global symbol(any, map) reset_button_handle = nil;
    global void(any, any) loader_type_store = nil;

    string additional_failsafe_params = "";


// other variables

    /**
      * Settings of other bootloaders used when switching bootloader
      */
    global map other_bl = $[];

// bootloader installation variables

    /**
      * Was the activate flag changed by user?
      */
    global boolean activate_changed = false;
    /**
      * Save everything, not only changed settings
      */
    global boolean save_all = false;
    /**
      * Widgets used by currently used bootloader
      */
    global map cwm_widgets = $[];
// state variables

    /**
      * was the propose function called (== true)
      */
    global boolean was_proposed = false;
    /**
      * Were module settings read (== true)
      */
    global boolean was_read = false;
    /**
      * were sections settings changes (== true)
      */
    global boolean sections_changed = false;
    /**
      * Was bootloader location changed? (== true)
      */
    global boolean location_changed = false;
    /**
      * Were configuration files manually edited and chamged?
      */
    global boolean files_edited = false;
    /**
      * Has been files edited warning already shown?
      */
    global boolean files_edited_warned = false;
    /**
      * Shall be settings saved when finishing bootloader configuration?
      */
    global boolean save_on_finish = true;
    /**
      * time of last change of partitioning
      */
    global integer partitioning_last_change = 0;



    global define string getLoaderType (boolean recheck);
    global define list<string> getBootloaders ();

    include "bootloader/routines/helps.ycp";
    include "bootloader/routines/popups.ycp";
    include "bootloader/routines/misc.ycp";
    include "bootloader/routines/lilolike.ycp";
    include "bootloader/routines/options.ycp";
    include "bootloader/routines/routines.ycp";
    include "bootloader/routines/widgets.ycp";


// generic versions of bootloader-specific functions

    /**
      * Export bootloader settings to a map
      * @return bootloader settings
      */
    global define map Export () ``{
        map exp = $[
		"global": globals,
		"sections" : sections,
		"repl_mbr" : repl_mbr,
		"activate" : activate,
	    ];
	return exp;
    }

    /**
      * Import settings from a map
      * @param settings map of bootloader settings
      */
    global define boolean Import (map settings) ``{
        globals = settings["global"]:[];
        sections  = settings["sections"]:[];
        repl_mbr = settings["repl_mbr"]:false;
        activate = settings["activate"]:false;
	activate_changed = true;
	return true;
    }

    /**
      * Read settings from disk
      * @return boolean true on success
      */
    global define boolean Read () ``{
	string bl = getLoaderType (false);
	if (bl == "none")
	    return true;
	if (bl == "s390")
	    bl = "zipl";
	else if (bl == "ppc")
	    bl = "lilo";
	SCR::Read (list2path ([bl, "reread"]));
	loadCfgFileFromAgent ();
	loader_device = (string)lookup_value (globals, "boot", "/dev/null");
        return true;
    }

    /**
      * Reset bootloader settings
      */
    global define void Reset () ``{
        sections = [];
        globals = [];
//	DetectDisks ();
	repl_mbr = false;
	activate = false;
	activate_changed = false;
    }

    /**
      * Propose bootloader settings
      */
    global define void Propose () ``{
	y2error ("No generic propose function available");
    }
    /**
      * Save all bootloader configuration files
      * @return boolean true if success
      */
    global define boolean Save () ``{
	string bl = getLoaderType (false);
	if (bl == "s390")
	    bl = "zipl";
	else if (bl == "ppc")
	    bl = "lilo";
	saveCfgFileToAgent ();
	SCR::Write(list2path([bl]), nil);
	return true;
    }
    /**
      * Display bootloader summary
      * @return a list of summary lines
      */
    global define list<string> Summary () ``{
	if (getLoaderType (false) == "none")
	{
	    return [HTML::Colorize (getLoaderName (getLoaderType (false)),
		"red") ];
	}
	map targetMap = Storage::GetTargetMap ();
	map boot_target = targetMap[loader_device]:$[];
	string target_name = "";
	if (boot_target == $[])
	    target_name = loader_device;
	else
	    target_name = boot_target["name"]:"disk";
	target_name = AddMbrToDescription (target_name, loader_device);

	list<string> result = [];
	// summary text, %1 is bootloader name (eg. LILO)
	result = add (result, sformat (_("Boot loader type: %1"),
		getLoaderName (getLoaderType (false))));
	// summary text, location is location description (eg. /dev/hda)
	result = add (result, sformat (_("Location: %1"), target_name));
	list<string> sects = [];
	foreach (list<map> s, sections, ``{
	    string title = (string)lookup_value (s, getSectionTitle (), "");
		// section name "suffix" for default section
	    string def = title == getDefaultSection () ? _(" (default)") : "";
	    sects = add (sects, sformat ("%1%2", title, def));
	});
	// summary text. %1 is list of bootloader sections
	result = add (result, sformat (_("Sections: %1"),
	    mergestring (sects, ", ")));
	if (loader_device == "/dev/null")
	    // summary text
	    result = add (result, _("Do not install boot loader -- just create
configuration files"));
	return result;
    }

    /**
      * Update read settings to new version of configuration files
      */
    global define void Update () ``{
	y2debug ("No generic update function available");
    }

    /**
      * Write bootloader settings to disk
      * @return boolean true on success
      */
    global define boolean Write () ``{
	y2error ("No generic write possible");
	return false;
    }

    /**
      * Get map of bootloader options
      * @return map of options
      */
    global define map GetOptions () ``{
	map opts = $[
	    `global: [
	        "append",
	        "backup",
	        "boot",
	        "change-rules",
	        "compact",
	        "default",
	        "delay",
	        "disk",
	        "disktab",
	        "fix-table",
		"force-backup",
	        "ignore-table",
	        "install",
	        "lba32",
	        "linear",
	        "lock",
	        "map",
	        "menu-title",
	        "menu-scheme",
	        "message",
	        "nowarn",
	        "optional",
	        "password",
	        "prompt",
	        "restricted",
	        "serial",
	        "timeout",
	        "verbose",
	        "vga",
	    ],
	    "image" : [
	        "append",
	        "initrd",
	        "literal",
	        "ramdisk",
	        "read-only",
	        "read-write",
	        "root",
	        "vga",
	        "label",
	        "alias",
	        "lock",
	        "optional",
	        "password",
	        "restricted",
	    ],
	    "other" : [
	        "loader",
	        "table",
	        "change",
	        "map-drive",
	        "unsafe",
	        "label",
	        "alias",
	        "lock",
	        "optional",
	        "password",
	        "restricted",
	    ]
	];
	return opts;
    }

// end of generic versions of bootloader-specific functions
//-----------------------------------------------------------------------------

// functions for fetching settings to tmp map and storing back

    /**
      * Fetch settings to temporary variables
      * @return sumbol wizard sequencer symbol
      */
    global define symbol fetchSettings () ``{
	current_globals = (list<map>)(eval(globals));
	current_sections = (list<list<map> >)(eval(sections));
	return `next;
    }

    /**
      * Store settings from temporary variables to globals
      * @return wizard sequencer symbol
      */
    global define symbol storeSettings () ``{
	globals = (list<map>)(eval (current_globals));
	sections = (list<list<map> >)(eval (current_sections));
	loader_device = GetBootloaderDevice ();
	return `next;
    }

//-----------------------------------------------------------------------------
// common functions start

// bootloader type handling functions

    /**
      * Set attributes of specified bootloader to variable containing
      * attributes of currently used bootloader, call its initializer
      * @param loader_type string loader type to initialize
      */
    global define void setCurrentLoaderAttribs (string loader_type) ``{
	y2milestone ("Setting attributes for bootloader %1", loader_type);
	// testsuite hack
	if (Mode::test)
	    return;
	if (loader_type != nil &&
	    bootloader_attribs[loader_type, "initializer"]:nil != nil)
	{
	    y2milestone ("Running bootloader initializer");
	    void () toEval = (void ()) (bootloader_attribs[loader_type, "initializer"]:nil);
	    toEval ();
	}
	else if (loader_type == nil)
	{
	    y2error ("Setting loader type to nil, this is wrong");
	    return;
	}
	else
	{
	    y2error ("No initializer found for >>%1<<", loader_type);
	    current_bootloader_attribs = $[];
	    cwm_options = GetOptionMaps ();
	    cwm_widgets = GetWidgetMaps ();
	}
	if (loader_type != nil)
	{
	    current_bootloader_attribs = (map<string, any>) union (
		current_bootloader_attribs,
		(map<string, any>) eval (bootloader_attribs[loader_type]:$[]));
	}
    }

    /**
      * Get currently used bootloader, detect if not set yet
      * @param recheck boolean force checking bootloader
      * @return string botloader type
      */
    global define string getLoaderType (boolean recheck) ``{
	if ((! recheck) && (loader_type != nil))
	    return loader_type;
	// read bootloader to use from disk
	if (Mode::update || Mode::normal || Mode::repair)
	{
	    loader_type = (string)SCR::Read (.sysconfig.bootloader.LOADER_TYPE);
	    if (loader_type != nil && loader_type != "")
	    {
		y2milestone ("Sysconfig bootloader is %1, using", loader_type);
		if (loader_type == "lilo" && Arch::ppc)
		    loader_type = "ppc";
		setCurrentLoaderAttribs (loader_type);
		return loader_type;
	    }
	    if (Mode::update)
	    {
		if (Arch::i386)
		{ // no sysconfig variable -> old version installed -> use LILO
		    loader_type = "lilo";
		    setCurrentLoaderAttribs (loader_type);
		    return loader_type;
		}
	    }
	}
	// detect bootloader
	loader_type = (string)SCR::Read (.probe.boot_arch);
	y2milestone ("Bootloader detection returned %1", loader_type);
	if (Arch::is_uml)
	{
	    y2milestone ("Not installing any bootloader for UML");
	    loader_type = "none";
	}
	if (loader_type == "grub" && Storage::UseLilo())
	{
	    loader_type = "lilo";
	    prefer_lilo = true;
	}
	else
	{
	    prefer_lilo = false;
	}

	y2milestone ("Detected bootloader %1", loader_type);
	setCurrentLoaderAttribs (loader_type);
	return loader_type;
    }
    /**
      * set type of bootloader
      * @param bootloader string type of bootloader
      */
    global define void setLoaderType (string bootloader) ``{
	y2milestone ("Setting bootloader to >>%1<<", bootloader);
	if (bootloader != nil
	    && contains(bootloaders, bootloader)
	    && ! Mode::test)
	{
	    // don't configure package maneger during autoinstallation preparing
	    if (Mode::normal && (! (Mode::config || Mode::repair)))
	    {
		Require::RequireAndConflict (
		    getBootloaderPackages (bootloader),
		    [],
		    // rich text, %1 is list of packages
		    _("YaST will install packages %1."));
	    }
	    else if (Mode::initial && (! (Mode::repair)))
	    {
		foreach (string p, getBootloaderPackages (bootloader), ``{
		    if (! Pkg::IsSelected (p))
		    {
		        Pkg::PkgInstall (bootloader);
		    }
		});
	    }
	}
	loader_type = bootloader;
	if (loader_type != nil)
	    setCurrentLoaderAttribs (loader_type);
    }
    /**
      * List bootloaders available for configured architecture
      * @return list of bootloaders
      */
    global define list<string> getBootloaders () ``{
	if (Mode::config)
	{
	    return ["grub", "lilo", "elilo", "s390", "ppc"];
	}
	list<string> ret = [getLoaderType (false)];
	if (Arch::i386 || Arch::x86_64)
	{
	    ret = (list<string>)merge (ret, ["lilo", "grub"]);
	}
	ret = toset (ret);
	ret = add (ret, "none");
	return ret;
    }

}


