/**
 * File:
 *   modules/Lilo.ycp
 *
 * Package:
 *   Configuration of lilo
 *
 * Summary:
 *   Data for configuration of lilo, input and output functions.
 *
 * Authors:
 *   Dan Meszaros <dmeszar@suse.cz>
 *
 * $Id$
 *
 * Representation of the configuration of lilo.
 * Input and output routines.
 *
 */

{

    // Set the name of the module

    module "Lilo";
    include "lilo/routines.ycp";
    textdomain "lilo";

    // Settings: Define all variables needed for configuration of exampleX
    //   // List of the configured cards
    //   list cards = [];
    //   // Some additional parameter needed for the confgiuration
    //   boolean additional_parameter

    /**
     * list of section
     */
    global list sections = [];

    /**
     * map of global options and values
     */
    global map globals = $[];


    /**
     * map of partitions and their descriptions.
     *      eg: $[`mbr    : $["label": _("Master boot record"),
     *                        "dev": lookup(eser_setts, "mbr_disk", "/dev/hda")],
     */
    global map partmap = $[];

    /**
     * name of previously used bootpartition (needed when removing lilo)
     */
    global string bootPart = "";

    /**
     *
     */

    global boolean autoinstallation = false;

    /**
     * flag that is used to signalize, that the config module was exited
     * with no wish to use the settings. in this case we need to return
     * empty map in Export function
     */

    global boolean discard_settings = false;

    /**
     * uninstall lilo?
     *
     */

    global boolean uninstallLilo = false;

    /**
     * returns section of given type and given label
     */

    global define void Lilo() ``{
	list fstab = SCR::Read(.etc.fstab);

//	list mbr = filter(`e, fstab, ``(lookup(e, "file", "") == "/"));

	list rootpart_l = filter(`e, fstab, ``(lookup(e, "file", "") == "/"));

	list bootpart_l = filter(`e, fstab, ``(lookup(e, "file", "") == "/boot"));
	if (size(bootpart_l) == 0)
	{
	    bootpart_l = rootpart_l;
	}

	list fd_l = filter(`e, fstab, ``(lookup(e, "file", "") == "/media/floppy"));


	string mbr_d = "/dev/hda"; // if everything fails, just pass this value...
	list disks = SCR::Read(.probe.disk);
	if (size(disks) > 0)
	{
	    map disk = select(disks, 0, $[]);
	    mbr_d = lookup(disk, "dev_name", "");
	}



	string rootpart_d = lookup(select(rootpart_l, 0, $[]), "spec", "/dev/hda3");
	string bootpart_d = lookup(select(bootpart_l, 0, $[]), "spec", "/dev/hda1");
	string fd_d = lookup(select(fd_l, 0, $[]), "spec", "/dev/fd0");

        partmap = $[`mbr    : $["label": _("Master boot record"), "dev" : mbr_d],
                    `boot   : $["label": _("Boot sector of boot partition"), "dev" : bootpart_d],
                    `root   : $["label": _("Boot sector of root partition"), "dev": rootpart_d],
                    `floppy : $["label": _("Floppy disk"), "dev": fd_d],
                    `uninstall :
                            // Uninstall [lilo | silo | elilo]
                              $["label": sformat(_("Uninstall %1"), boot())]
                    ];
    }

    /**
     * returns section map specified by label
     * @param label section label
     * @return map section options in map
     */

    global define map GetSection(string label) ``{
	list filt = filter(`s, sections, ``(lookup(s, "label", "")==label));

	if (size(filt) > 0)
	{
	    return select(filt, 0, $[]);
	}

	return $[];
    }

    /**
     * deletes section specified with given label
     * @param label section label
     * return void
     */

    global define void DeleteSection(string label) ``{
	sections = filter(`s, sections, ``(lookup(s, "label", "") != label));
    }

    /**
     * deletes section specified by position
     * @param pos section position
     * @return void
     *
     */

    global define void DeleteSectionPos(integer pos) ``{
	sections = remove(sections, pos);
    }

    /**
     * adds new section
     * @param options section options
     * @return void
     */

    global define void AddSection(map options) ``{
	sections = add(sections, options);
    }

    /**
     * changes section options in global section list. section is specified by name
     * @param sectname section label
     * @param options new setion options
     * @return void
     */

    global define void ChangeSectionOptions(string sectname, map options) ``{

	sections = maplist(`s, sections, ``((lookup(s, "label", "") == sectname) ? options: s));
    }

    /**
     * Read all example settings from the SCR
     * @param _unused increase_progress A block that will be evaluated after each milestone.
     *        It must return boolean to get known when we should stop after [Abort]
     * @return boolean True on success
     */
    global define boolean Read (block _unused) ``{
	sections = [];
	globals = $[];

	LiloRead();


	return true;
    }

    /**
     * Update the SCR according to example settings
     * @param increase_progress A block that will be evaluated after each milestone.
     *        It must return boolean to get known when we should stop after [Abort]
     * @param really_abort A block that will be evaluated after [Abort],
     *        because [Abort] in the time of writing could be critical...
     *        It must return boolean to get known if we should really stop.
     * @return map result
     */
    global define map Write (block increase_progress, block really_abort) ``{
	map conf = Export();
	map res = CallFunction(`lilo_write(conf));
	return res;
    }

    /**
     * writes config to temp file
     * @param file write configuration to file file
     * @return map return of write fundtion
     *
     */

    global define map WriteTest(string file) ``{
	map conf = Export();
	conf = add(conf, "file", file);
	conf = add(conf, "execute_lilo", false);
        map res = CallFunction(`lilo_write(conf));
        return res;
    }

    /**
     * Get all example settings from the first parameter
     * (For use by autoinstallation.)
     * @param settings The YCP structure to be imported.
     * @return boolean True on success
     */
    global define boolean Import (map settings) ``{
	map conf = lookup(settings, "conf", $[]);
	globals = lookup(conf, "global", $[]);
	sections  = lookup(conf, "sections", []);
	return true;
    }

    /**
     * Dump the example settings to a single map
     * (For use by autoinstallation.)
     * @return map Dumped settings (later acceptable by Import ())
     */
    global define map Export () ``{
	if (Lilo::discard_settings)
	{
	    return $[];
	}
	map conf = $["conf":
                        $[
                            "global": globals,
                            "sections" : sections,
                        ],
		    "file": "/etc/lilo.conf",
                    "execute_lilo": true
                    ];
	return conf;
    }

    /**
     * Build a textual summary that can be used e.g. in inst_hw_config () or
     * something similar.
     * @return string Summary of the configuration.
     */
    global define string Summary () ``{
	return _("Summary of the configuration...");
    }

    /**
     * reads specified section and returns values as list [$[option:$[value:..., comment:...]]]
     * @param type string sections / ""
     * @param section string
     * @return map map as described above
     */

    define map sectOptions2Map(string type, string section) ``{
	path p = .;
	if (type == "")
	{
	    p = list2path([boot()]);
	}
	else
	{
	    p = list2path([boot(), "sections" , section]);
	}

	map retval = $[];

	list optlist = SCR::Dir(p);

	if (type == "")
	{
	    optlist = filter(`e, optlist, ``(e != "sections"));
	}

	any value = "";

	// read global options and create map to be stored in settings

	list option = [];

	foreach(`e, optlist,
	``{
	    value = mod2ui(SCR::Read(add(p, e)));
	    if (isSpecial(e))
	    {
		retval = add(retval, e, mergestring(SCR::Read(add(p, e)), ","));
	    }
	    else
	    {
		retval = add(retval, e, sformat("%1", value));
	    }
	});

	return retval;
    }


    /**
     * Fill the map of all lilo settings from the SCR
     * @return map all needed lilo settings
     */

    define map LiloRead() ``{
	map liloconf = $[];
	map sets = $[];

	path p = list2path([boot(), "boot"]);

	list optlist = SCR::Dir(list2path([boot()]));

	any value = "";
	string comment = "";

	map options = sectOptions2Map("", "");

	// iterate for all sections and do the same as before

	list sects = [];
	map opts_tmp = $[];

	sects = SCR::Dir(list2path([boot(), "sections"]));
	sections = [];

	foreach(`e, sects,
	``{
	    opts_tmp = sectOptions2Map("sections", e);
	    sections = add(sections, opts_tmp);
	});

	globals = options;

	bootPart = SCR::`Read(list2path([boot(), "boot"]));


	return sets;
    }


    /*
     * functions for conversion from ui to modules and vice versa
     */

    /**
     * convert string values from agent representation to module representation
     * 1) if string is quoted, quotes are removed
     * 2) if string contains escaped quotes, they're unescaped
     * @param val value to transform
     * @return any transformed value
     */


    define any mod2ui(any val) ``{
	if (is(val, string))
	{
	    string v = sformat("%1", val);
	    v = strip(v);
	    // remove leading and trailing quotes
	    if (substring(v, 0, 1) == "\"" && substring(v, size(v)-1, 1) == "\"")
	    {
		v = substring(v, 1, size(v)-2);
	    }

	    // unescape backslashes
	    v = replaceAll(v, "\\\\", "\\");

	    // unescape quotes
	    v = replaceAll(v, "\\\"", "\"");
	    return v;
	}
	return val;
    }

    /**
     * reverse of ag2mod
     * @param val value to transform
     * @return any transformed value
     */

    define any ui2mod(any val) ``{
	if (is(val, string))
	{
	    string v = sformat("%1", val);
	    v = strip(v);
	    // if string contains backslashes, escape them
	    v = replaceAll(v, "\\", "\\\\");

	    // if string contains quotes, escape them
	    v = replaceAll(v, "\"", "\\\"");

	    // if string contains spaces or equal sign or is empty, quote it

	    if (size(splitstring(v, " ")) >= 2 || size(v) == 0 || find(v, "=") >= 0)
	    {
		v = "\"" + v + "\"";
	    }
	    return v;
	}
	return val;
    }

    /**     
     * converts array of string to path
     * @param strs list of string 
     * @return path whose components are taken from strs
     */


    global define path list2path(list strs) ``{
	path pth = .;
	foreach(`e, strs, 
	``{
	    pth = add(pth, e);
	}
	);
	return pth;
    }

    /**
     * reads the global settings and returns booloader for current platform.
     * this is just a helper function, present only because this setting is
     * frequently needed
     *
     * @return string architecture
     */

    global define string boot() ``{
	return SCR::Read(.probe.boot_arch); // FIXME!!
    }

}
