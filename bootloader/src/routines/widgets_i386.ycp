/**
 * File:
 *      include/bootloader/routines/widgets_i386.ycp
 *
 * Module:
 *      Bootloader installation and configuration
 *
 * Summary:
 *      Widgets for being used by bootloader for i368
 *
 * Authors:
 *      Jiri Srain <jsrain@suse.cz>
 *
 * $Id: widgets.ycp 20246 2004-11-09 07:17:07Z jsrain $
 *
 */


{

include "bootloader/routines/popups.ycp";

void InitBootMenu (string key) {
    boolean timeout_active = haskey (BootCommon::globals, "timeout");
    UI::ChangeWidget (`id (`timeout_act), `Value, timeout_active);
    UI::ChangeWidget (`id (`timeout), `Enabled, timeout_active);
    integer timeout = tointeger (BootCommon::globals["timeout"]:"0");
    UI::ChangeWidget (`id (`timeout), `Value, timeout);
    boolean show_menu = BootCommon::globals["prompt"]:"0" != "0";
    UI::ChangeWidget (`id (`show_menu), `Value, show_menu);
}

void StoreBootMenu (string key, map event) {
    integer timeout = (integer)UI::QueryWidget (`id (`timeout), `Value);
    boolean timeout_act = (boolean)UI::QueryWidget (`id (`timeout_act), `Value);
    if (timeout_act)
	BootCommon::globals["timeout"] = sformat ("%1", timeout);
    else if (haskey (BootCommon::globals, "timeout"))
	BootCommon::globals = remove (BootCommon::globals, "timeout");
    boolean show_menu = (boolean)UI::QueryWidget (`id (`show_menu), `Value);
    BootCommon::globals["prompt"] = show_menu ? "1" : "0";
}

symbol HandleBootMenu (string key, map event) {
    boolean active = (boolean)UI::QueryWidget (`id (`timeout_act), `Value);
    UI::ChangeWidget (`id (`timeout), `Enabled, active);
    return nil;
}

map<string,any> BootMenuWidget () {
    return $[
	"widget" : `custom,
	// frame
	"custom_widget" : `Frame (_("Boot Menu"), `HBox (
	    `HSpacing (2), `VBox (
		`VSpacing (0.4),
		// check box
		`Left (`CheckBox (`id (`show_menu), _("Show Boot Menu"))),
		`VSpacing (0.4),
		`Left (`CheckBox (`id (`timeout_act), `opt (`notify),
		    // check box
		    _("&Continue booting after a timeout"))),
		// integer field
		`IntField (`id (`timeout), _("Boot Menu Time-Out"), 0, 60, 0),
		`VSpacing (0.4)
	    ), `HSpacing (2)
	)),
	"init" : InitBootMenu,
	"store" : StoreBootMenu,
	"handle" : HandleBootMenu,
	"handle_events" : [ `timeout_act ],
	"help" : i386BootMenuHelp (),
    ];
}

/**
 * Init function of a popup
 * @param key any widget key
 */
void InitPasswdWidget (string key) {
    string passwd = BootCommon::globals["password"]:"";
    if (passwd == nil || passwd == "")
    {
	UI::ChangeWidget (`id (`use_pas), `Value, false);
	UI::ChangeWidget (`id (`pw1), `Enabled, false);
	UI::ChangeWidget (`id (`pw1), `Value, "");
	UI::ChangeWidget (`id (`pw2), `Enabled, false);
	UI::ChangeWidget (`id (`pw2), `Value, "");
    }
    else
    {
	UI::ChangeWidget (`id (`use_pas), `Value, true);
	UI::ChangeWidget (`id (`pw1), `Enabled, true);
	UI::ChangeWidget (`id (`pw1), `Value, "**********");
	UI::ChangeWidget (`id (`pw2), `Enabled, true);
	UI::ChangeWidget (`id (`pw2), `Value, "**********");
    }
    UI::SetFocus (`id (`use_pas));
}

/**
 * Handle function of a widget
 * @param key any widget key
 * @param event map event description of event that occured
 * @return symbol always nil
 */
symbol HandlePasswdWidget (string key, map event) {
    if (event["ID"]:nil == `use_pas)
    {
	boolean enabled = (boolean)UI::QueryWidget (`id (`use_pas), `Value);
	UI::ChangeWidget (`id (`pw1), `Enabled, enabled);
	UI::ChangeWidget (`id (`pw2), `Enabled, enabled);
    }
    return nil;
}

/**
 * Store function of a popup
 * @param key any widget key
 */
void StorePasswdWidget (string key, map event) {
    string password = nil;
    boolean usepass = (boolean)UI::QueryWidget (`id (`use_pas), `Value);
    y2milestone ("Usepass: %1", usepass);
    if (usepass)
    {
	if (UI::QueryWidget (`id (`pw1), `Value) != "**********")
	{
	    password = (string)UI::QueryWidget (`id (`pw1), `Value);
	    if (haskey (BootCommon::current_bootloader_attribs,
		"update_passwd"))
	    {
		string(string) f = (string(string))
		    BootCommon::current_bootloader_attribs[
			"update_passwd"]:nil;
		password = f (password);
	    }
	    BootCommon::globals["password"] = password;
	}
    }
    else if (haskey (BootCommon::globals, "password"))
    {
	BootCommon::globals = remove (BootCommon::globals, "password");
    }
    return nil;
}


/**
 * Validate function of a popup
 * @param key any widget key
 * @param event map event that caused validation
 * @return boolean true if widget settings ok
 */
boolean ValidatePasswdWidget (string key, map event) {
    if (! (boolean)UI::QueryWidget (`id (`use_pas), `Value))
	return true;
    if (UI::QueryWidget (`id (`pw1), `Value) == "")
    {
	emptyPasswdErrorPopup ();
	UI::SetFocus (`id (`pw1));
	return false;
    }
    if (UI::QueryWidget (`id (`pw1), `Value)
	== UI::QueryWidget (`id (`pw2), `Value)
    )
	return true;
    passwdMissmatchPopup ();
    UI::SetFocus (`id (`pw1));
    return false;
}




map<string,any> PasswordWidget () {
    return $[
	"widget" : `custom,
	// frame
	"custom_widget" : `Frame (_("Password Protection"), `VBox (
	    `VSpacing (0.4),
	    `HBox (
		`HSpacing (2), `VBox (
		    `Left (`CheckBox (`id (`use_pas), `opt (`notify),
			// check box
			_("Protect Boot Loader with Password"))),
		    `HBox (
			// text entry
			`Password (`id (`pw1), _("&Password")),
			// text entry
			`Password (`id (`pw2), _("Re&type Password"))
		    )
		), `HSpacing (2)
	    ),
	    `VSpacing (0.4)
	)),
	"init" : InitPasswdWidget,
	"handle" : HandlePasswdWidget,
	"store" : StorePasswdWidget,
	"validate_type" : `function,
	"validate_function" : ValidatePasswdWidget,
	"help" : i386PasswdHelp (),
    ];
}

map<string,map<string,any> > _i386_widgets = nil;

map<string,map<string,any> > i386Widgets () {
    if (_i386_widgets == nil)
    {
	_i386_widgets = $[
	    "boot_menu" : BootMenuWidget (),
	    "password" : PasswordWidget (),
	];
    }
    return _i386_widgets;
}

} // include end
